import "node:module";
import yargsParser from "yargs-parser";
import Hooks from "@poppinss/hooks";
import { cliui } from "@poppinss/cliui";
import { Prompt, errors } from "@poppinss/prompts";
import { distance } from "fastest-levenshtein";
import { Exception, InvalidArgumentsException, RuntimeException, createError } from "@poppinss/utils/exception";
import { debuglog, inspect } from "node:util";
import string from "@poppinss/utils/string";
import Macroable from "@poppinss/macroable";
import lodash from "@poppinss/utils/lodash";
import { AssertionError } from "node:assert";
import { defineStaticProperty, importDefault } from "@poppinss/utils";
import stringWidth from "string-width";
import * as cliHelpers from "@poppinss/cliui/helpers";
import { TERMINAL_SIZE, justify, wrap } from "@poppinss/cliui/helpers";
import { Validator } from "jsonschema";
import diagnostics_channel from "node:diagnostics_channel";
import { fileURLToPath } from "node:url";
import { fsReadAll } from "@poppinss/utils/fs";
import { basename, extname, join, relative } from "node:path";
import { copyFile, mkdir, writeFile } from "node:fs/promises";
var __defProp = Object.defineProperty;
var __exportAll = (all, no_symbols) => {
	let target = {};
	for (var name in all) __defProp(target, name, {
		get: all[name],
		enumerable: true
	});
	if (!no_symbols) __defProp(target, Symbol.toStringTag, { value: "Module" });
	return target;
};
const yarsConfig = {
	"camel-case-expansion": false,
	"combine-arrays": true,
	"short-option-groups": true,
	"dot-notation": false,
	"parse-numbers": true,
	"parse-positional-numbers": false,
	"boolean-negation": true,
	"flatten-duplicate-arrays": true,
	"greedy-arrays": false,
	"strip-aliased": true,
	"nargs-eats-options": false,
	"unknown-options-as-args": false
};
var Parser = class {
	#options;
	constructor(options) {
		this.#options = options;
	}
	#parseFlags(argv) {
		return yargsParser(argv, {
			...this.#options.flagsParserOptions,
			configuration: yarsConfig
		});
	}
	#scanUnknownFlags(parsed) {
		const unknownFlags = [];
		for (let key of Object.keys(parsed)) if (!this.#options.flagsParserOptions.all.includes(key)) unknownFlags.push(key);
		return unknownFlags;
	}
	#parseArguments(parsedOutput) {
		let lastParsedIndex = -1;
		const output = this.#options.argumentsParserOptions.map((option, index) => {
			if (option.type === "spread") {
				let value = parsedOutput._.slice(index);
				lastParsedIndex = parsedOutput._.length;
				if (!value.length) value = Array.isArray(option.default) ? option.default : option.default === void 0 ? void 0 : [option.default];
				if (value !== void 0 && option.parse) value = option.parse(value);
				return value;
			}
			let value = parsedOutput._[index];
			lastParsedIndex = index + 1;
			if (value === void 0) value = option.default;
			if (value !== void 0 && option.parse) value = option.parse(value);
			return value;
		});
		const { "_": args, "--": o, ...rest } = parsedOutput;
		return {
			args: output,
			nodeArgs: [],
			_: args.slice(lastParsedIndex === -1 ? 0 : lastParsedIndex),
			unknownFlags: this.#scanUnknownFlags(rest),
			flags: rest
		};
	}
	parse(argv) {
		return this.#parseArguments(this.#parseFlags(argv));
	}
};
var debug_default = debuglog("adonisjs:ace");
var errors_exports = /* @__PURE__ */ __exportAll({
	E_COMMAND_NOT_FOUND: () => E_COMMAND_NOT_FOUND,
	E_INVALID_FLAG: () => E_INVALID_FLAG,
	E_MISSING_ARG: () => E_MISSING_ARG,
	E_MISSING_ARG_VALUE: () => E_MISSING_ARG_VALUE,
	E_MISSING_COMMAND_NAME: () => E_MISSING_COMMAND_NAME,
	E_MISSING_FLAG: () => E_MISSING_FLAG,
	E_MISSING_FLAG_VALUE: () => E_MISSING_FLAG_VALUE,
	E_PROMPT_CANCELLED: () => E_PROMPT_CANCELLED,
	E_UNKNOWN_FLAG: () => E_UNKNOWN_FLAG
});
const E_PROMPT_CANCELLED = errors.E_PROMPT_CANCELLED;
const E_MISSING_COMMAND_NAME = createError("Cannot serialize command \"%s\". Missing static property \"commandName\"", "E_MISSING_COMMAND_NAME");
const E_COMMAND_NOT_FOUND = class CommandNotFound extends Exception {
	static status = 404;
	commandName;
	constructor(args) {
		super(`Command "${args[0]}" is not defined`, { code: "E_COMMAND_NOT_FOUND" });
		this.commandName = args[0];
	}
};
const E_MISSING_FLAG = createError("Missing required option \"%s\"", "E_MISSING_FLAG");
const E_MISSING_FLAG_VALUE = createError("Missing value for option \"%s\"", "E_MISSING_FLAG_VALUE");
const E_MISSING_ARG = createError("Missing required argument \"%s\"", "E_MISSING_ARG");
const E_MISSING_ARG_VALUE = createError("Missing value for argument \"%s\"", "E_MISSING_ARG_VALUE");
const E_UNKNOWN_FLAG = createError("Unknown flag \"%s\". The mentioned flag is not accepted by the command", "E_UNKNOWN_FLAG");
const E_INVALID_FLAG = createError("Invalid value. The \"%s\" flag accepts a \"%s\" value", "E_INVALID_FLAG");
var BaseCommand = class extends Macroable {
	static booted = false;
	static options;
	static aliases;
	static commandName;
	static description;
	static help;
	static args;
	static flags;
	static boot() {
		if (Object.hasOwn(this, "booted") && this.booted === true) return;
		this.booted = true;
		defineStaticProperty(this, "args", {
			initialValue: [],
			strategy: "inherit"
		});
		defineStaticProperty(this, "flags", {
			initialValue: [],
			strategy: "inherit"
		});
		defineStaticProperty(this, "aliases", {
			initialValue: [],
			strategy: "inherit"
		});
		defineStaticProperty(this, "commandName", {
			initialValue: "",
			strategy: "inherit"
		});
		defineStaticProperty(this, "description", {
			initialValue: "",
			strategy: "inherit"
		});
		defineStaticProperty(this, "help", {
			initialValue: "",
			strategy: "inherit"
		});
		defineStaticProperty(this, "options", {
			initialValue: {
				staysAlive: false,
				allowUnknownFlags: false
			},
			strategy: "inherit"
		});
	}
	static defineArgument(name, options) {
		this.boot();
		const arg = {
			name,
			argumentName: string.dashCase(name),
			required: true,
			...options
		};
		const lastArg = this.args[this.args.length - 1];
		if (!arg.type) throw new InvalidArgumentsException(`Cannot define argument "${this.name}.${name}". Specify the argument type`);
		if (lastArg && lastArg.type === "spread") throw new InvalidArgumentsException(`Cannot define argument "${this.name}.${name}" after spread argument "${this.name}.${lastArg.name}". Spread argument should be the last one`);
		if (arg.required && lastArg && lastArg.required === false) throw new InvalidArgumentsException(`Cannot define required argument "${this.name}.${name}" after optional argument "${this.name}.${lastArg.name}"`);
		if (debug_default.enabled) debug_default("defining arg %O, command: %O", arg, `[class: ${this.name}]`);
		this.args.push(arg);
	}
	static defineFlag(name, options) {
		this.boot();
		const flag = {
			name,
			flagName: string.dashCase(name),
			required: false,
			...options
		};
		if (!flag.type) throw new InvalidArgumentsException(`Cannot define flag "${this.name}.${name}". Specify the flag type`);
		if (debug_default.enabled) debug_default("defining flag %O, command: %O", flag, `[class: ${this.name}]`);
		this.flags.push(flag);
	}
	static getParserOptions(options) {
		this.boot();
		const argumentsParserOptions = this.args.map((arg) => {
			return {
				type: arg.type,
				default: arg.default,
				parse: arg.parse
			};
		});
		const flagsParserOptions = lodash.merge({
			all: [],
			string: [],
			boolean: [],
			array: [],
			number: [],
			alias: {},
			count: [],
			coerce: {},
			default: {}
		}, options);
		this.flags.forEach((flag) => {
			flagsParserOptions.all.push(flag.flagName);
			if (flag.alias) flagsParserOptions.alias[flag.flagName] = flag.alias;
			if (flag.parse) flagsParserOptions.coerce[flag.flagName] = flag.parse;
			if (flag.default !== void 0) flagsParserOptions.default[flag.flagName] = flag.default;
			switch (flag.type) {
				case "string":
					flagsParserOptions.string.push(flag.flagName);
					break;
				case "boolean":
					flagsParserOptions.boolean.push(flag.flagName);
					break;
				case "number":
					flagsParserOptions.number.push(flag.flagName);
					break;
				case "array":
					flagsParserOptions.array.push(flag.flagName);
					break;
			}
		});
		return {
			flagsParserOptions,
			argumentsParserOptions
		};
	}
	static serialize() {
		this.boot();
		if (!this.commandName) throw new E_MISSING_COMMAND_NAME([this.name]);
		const [namespace, name] = this.commandName.split(":");
		return {
			commandName: this.commandName,
			description: this.description,
			help: this.help,
			namespace: name ? namespace : null,
			aliases: this.aliases,
			flags: this.flags.map((flag) => {
				const { parse, ...rest } = flag;
				return rest;
			}),
			args: this.args.map((arg) => {
				const { parse, ...rest } = arg;
				return rest;
			}),
			options: this.options
		};
	}
	static validate(parsedOutput) {
		this.boot();
		this.args.forEach((arg, index) => {
			const value = parsedOutput.args[index];
			const hasDefinedArgument = value !== void 0;
			if (arg.required && !hasDefinedArgument) throw new E_MISSING_ARG([arg.name]);
			if (hasDefinedArgument && !arg.allowEmptyValue && (value === "" || !value.length)) {
				if (debug_default.enabled) debug_default("disallowing empty value \"%s\" for arg: \"%s\"", value, arg.name);
				throw new E_MISSING_ARG_VALUE([arg.name]);
			}
		});
		if (!this.options.allowUnknownFlags && parsedOutput.unknownFlags.length) {
			const unknowFlag = parsedOutput.unknownFlags[0];
			throw new E_UNKNOWN_FLAG([unknowFlag.length === 1 ? `-${unknowFlag}` : `--${unknowFlag}`]);
		}
		this.flags.forEach((flag) => {
			const hasMentionedFlag = Object.hasOwn(parsedOutput.flags, flag.flagName);
			const value = parsedOutput.flags[flag.flagName];
			switch (flag.type) {
				case "boolean":
					if (flag.required && !hasMentionedFlag) throw new E_MISSING_FLAG([flag.flagName]);
					break;
				case "number":
					if (flag.required && !hasMentionedFlag) throw new E_MISSING_FLAG([flag.flagName]);
					if (hasMentionedFlag && value === void 0) throw new E_MISSING_FLAG_VALUE([flag.flagName]);
					if (Number.isNaN(value)) throw new E_INVALID_FLAG([flag.flagName, "numeric"]);
					break;
				case "string":
				case "array":
					if (flag.required && !hasMentionedFlag) throw new E_MISSING_FLAG([flag.flagName]);
					if (hasMentionedFlag && !flag.allowEmptyValue && (value === "" || !value.length)) {
						if (debug_default.enabled) debug_default("disallowing empty value \"%s\" for flag: \"%s\"", value, flag.name);
						throw new E_MISSING_FLAG_VALUE([flag.flagName]);
					}
			}
		});
	}
	hydrated = false;
	exitCode;
	error;
	result;
	get logger() {
		return this.ui.logger;
	}
	get colors() {
		return this.ui.colors;
	}
	get isMain() {
		return this.kernel.getMainCommand() === this;
	}
	get commandName() {
		return this.constructor.commandName;
	}
	get options() {
		return this.constructor.options;
	}
	get args() {
		return this.constructor.args;
	}
	get flags() {
		return this.constructor.flags;
	}
	constructor(kernel, parsed, ui, prompt) {
		super();
		this.kernel = kernel;
		this.parsed = parsed;
		this.ui = ui;
		this.prompt = prompt;
	}
	hydrate() {
		if (this.hydrated) return;
		const CommandConstructor = this.constructor;
		CommandConstructor.args.forEach((arg, index) => {
			Object.defineProperty(this, arg.name, {
				value: this.parsed.args[index],
				enumerable: true,
				writable: true,
				configurable: true
			});
		});
		CommandConstructor.flags.forEach((flag) => {
			Object.defineProperty(this, flag.name, {
				value: this.parsed.flags[flag.flagName],
				enumerable: true,
				writable: true,
				configurable: true
			});
		});
		this.hydrated = true;
	}
	async run(..._) {}
	async exec() {
		this.hydrate();
		try {
			this.result = await this.run();
			this.exitCode = this.exitCode ?? 0;
			return this.result;
		} catch (error) {
			this.error = error;
			this.exitCode = this.exitCode ?? 1;
			throw error;
		}
	}
	toJSON() {
		return {
			commandName: this.constructor.commandName,
			options: this.constructor.options,
			args: this.parsed.args,
			flags: this.parsed.flags,
			error: this.error,
			result: this.result,
			exitCode: this.exitCode
		};
	}
	assertExitCode(code) {
		if (this.exitCode !== code) throw new AssertionError({
			message: `Expected '${this.commandName}' command to finish with exit code '${code}'`,
			actual: this.exitCode,
			expected: code,
			operator: "strictEqual",
			stackStartFn: this.assertExitCode
		});
	}
	assertNotExitCode(code) {
		if (this.exitCode === code) throw new AssertionError({
			message: `Expected '${this.commandName}' command to finish without exit code '${this.exitCode}'`,
			stackStartFn: this.assertNotExitCode
		});
	}
	assertSucceeded() {
		return this.assertExitCode(0);
	}
	assertFailed() {
		return this.assertNotExitCode(0);
	}
	assertLog(message, stream) {
		const logs = this.logger.getLogs();
		const logMessages = logs.map((log) => log.message);
		const matchingLog = logs.find((log) => log.message === message);
		if (!matchingLog) throw new AssertionError({
			message: `Expected log messages to include ${inspect(message)}`,
			actual: logMessages,
			expected: [message],
			operator: "strictEqual",
			stackStartFn: this.assertLog
		});
		if (stream && matchingLog.stream !== stream) throw new AssertionError({
			message: `Expected log message stream to be ${inspect(stream)}, instead received ${inspect(matchingLog.stream)}`,
			actual: matchingLog.stream,
			expected: stream,
			operator: "strictEqual",
			stackStartFn: this.assertLog
		});
	}
	assertLogMatches(matchingRegex, stream) {
		const matchingLog = this.logger.getLogs().find((log) => matchingRegex.test(log.message));
		if (!matchingLog) throw new AssertionError({
			message: `Expected log messages to match ${inspect(matchingRegex)}`,
			stackStartFn: this.assertLogMatches
		});
		if (stream && matchingLog.stream !== stream) throw new AssertionError({
			message: `Expected log message stream to be ${inspect(stream)}, instead received ${inspect(matchingLog.stream)}`,
			actual: matchingLog.stream,
			expected: stream,
			operator: "strictEqual",
			stackStartFn: this.assertLogMatches
		});
	}
	assertTableRows(rows) {
		const logs = this.logger.getLogs();
		if (!rows.every((row) => {
			const columnsContent = row.join("|");
			return !!logs.find((log) => log.message === columnsContent);
		})) throw new AssertionError({
			message: `Expected log messages to include a table with the expected rows`,
			operator: "strictEqual",
			stackStartFn: this.assertTableRows
		});
	}
};
const args = {
	string(options) {
		return function addArg(target, propertyName) {
			target.constructor.defineArgument(propertyName, {
				...options,
				type: "string"
			});
		};
	},
	spread(options) {
		return function addArg(target, propertyName) {
			target.constructor.defineArgument(propertyName, {
				...options,
				type: "spread"
			});
		};
	}
};
const flags = {
	string(options) {
		return function addArg(target, propertyName) {
			target.constructor.defineFlag(propertyName, {
				type: "string",
				...options
			});
		};
	},
	boolean(options) {
		return function addArg(target, propertyName) {
			target.constructor.defineFlag(propertyName, {
				type: "boolean",
				...options
			});
		};
	},
	number(options) {
		return function addArg(target, propertyName) {
			target.constructor.defineFlag(propertyName, {
				type: "number",
				...options
			});
		};
	},
	array(options) {
		return function addArg(target, propertyName) {
			target.constructor.defineFlag(propertyName, {
				type: "array",
				...options
			});
		};
	}
};
var FlagFormatter = class {
	#flag;
	#colors;
	constructor(flag, colors) {
		this.#flag = flag;
		this.#colors = colors;
	}
	#formatValueFlag(flag, valuePlaceholder) {
		return flag.required ? `=${valuePlaceholder}` : `[=${valuePlaceholder}]`;
	}
	#formatAliases(flag) {
		if (!flag.alias) return [];
		if (typeof flag.alias === "string") return [`-${flag.alias}`];
		return flag.alias.map((alias) => `-${alias}`);
	}
	#formatArrayFlag(flag) {
		const value = this.#formatValueFlag(flag, `${flag.flagName.toUpperCase()}...`);
		const aliases = this.#formatAliases(flag);
		const flagWithValue = `--${flag.flagName}${value}`;
		if (aliases.length) return `  ${this.#colors.green(`${aliases.join(",")}, ${flagWithValue}`)}  `;
		return `  ${this.#colors.green(flagWithValue)}  `;
	}
	#formatStringFlag(flag) {
		const value = this.#formatValueFlag(flag, `${flag.flagName.toUpperCase()}`);
		const aliases = this.#formatAliases(flag);
		const flagWithValue = `--${flag.flagName}${value}`;
		if (aliases.length) return `  ${this.#colors.green(`${aliases.join(",")}, ${flagWithValue}`)}  `;
		return `  ${this.#colors.green(flagWithValue)}  `;
	}
	#formatNumericFlag(flag) {
		const value = this.#formatValueFlag(flag, `${flag.flagName.toUpperCase()}`);
		const aliases = this.#formatAliases(flag);
		const flagWithValue = `--${flag.flagName}${value}`;
		if (aliases.length) return `  ${this.#colors.green(`${aliases.join(",")}, ${flagWithValue}`)}  `;
		return `  ${this.#colors.green(flagWithValue)}  `;
	}
	#formatBooleanFlag(flag) {
		const aliases = this.#formatAliases(flag);
		const negatedVariant = flag.showNegatedVariantInHelp ? `|--no-${flag.flagName}` : "";
		const flagWithVariant = `--${flag.flagName}${negatedVariant}`;
		if (aliases.length) return `  ${this.#colors.green(`${aliases.join(",")}, ${flagWithVariant}`)}  `;
		return `  ${this.#colors.green(flagWithVariant)}  `;
	}
	formatDescription() {
		const defaultValue = this.#flag.default !== void 0 ? `[default: ${this.#flag.default}]` : "";
		const separator = defaultValue && this.#flag.description ? " " : "";
		return this.#colors.dim(`${this.#flag.description || ""}${separator}${defaultValue}`);
	}
	formatOption() {
		switch (this.#flag.type) {
			case "array": return this.#formatArrayFlag(this.#flag);
			case "string": return this.#formatStringFlag(this.#flag);
			case "number": return this.#formatNumericFlag(this.#flag);
			case "boolean": return this.#formatBooleanFlag(this.#flag);
		}
	}
};
var ListFormatter = class {
	#tables;
	#largestOptionColumnWidth;
	constructor(tables) {
		this.#tables = tables;
		this.#largestOptionColumnWidth = Math.max(...this.#tables.map((table) => table.columns.map((column) => stringWidth(column.option))).flat());
	}
	#formatTable(table, terminalWidth) {
		const options = justify(table.columns.map(({ option }) => option), { maxWidth: this.#largestOptionColumnWidth });
		const descriptions = wrap(table.columns.map(({ description }) => description), {
			startColumn: this.#largestOptionColumnWidth,
			endColumn: terminalWidth,
			trimStart: true
		});
		return table.columns.map((_, index) => `${options[index]}${descriptions[index]}`);
	}
	format(terminalWidth = TERMINAL_SIZE) {
		return this.#tables.map((table) => {
			return {
				heading: table.heading,
				rows: this.#formatTable(table, terminalWidth)
			};
		});
	}
};
const schema = {
	$ref: "#/definitions/CommandMetaData",
	$schema: "http://json-schema.org/draft-07/schema#",
	definitions: {
		CommandMetaData: {
			description: "Command metdata required to display command help.",
			properties: {
				aliases: {
					description: "Command aliases. The same command can be run using these aliases as well.",
					items: { type: "string" },
					type: "array"
				},
				args: {
					description: "Args accepted by the command",
					items: {
						additionalProperties: false,
						properties: {
							allowEmptyValue: {
								description: "Whether or not to allow empty values. When set to false, the validation will fail if the argument is provided an empty string\n\nDefaults to false",
								type: "boolean"
							},
							argumentName: { type: "string" },
							default: {},
							description: { type: "string" },
							name: { type: "string" },
							required: { type: "boolean" },
							type: {
								enum: ["string", "spread"],
								type: "string"
							}
						},
						required: [
							"name",
							"argumentName",
							"type"
						],
						type: "object"
					},
					type: "array"
				},
				commandName: {
					description: "The name of the command",
					type: "string"
				},
				description: {
					description: "The command description to show on the help screen",
					type: "string"
				},
				flags: {
					description: "Flags accepted by the command",
					items: {
						additionalProperties: false,
						properties: {
							alias: { anyOf: [{ type: "string" }, {
								items: { type: "string" },
								type: "array"
							}] },
							allowEmptyValue: {
								description: "Whether or not to allow empty values. When set to false, the validation will fail if the flag is mentioned but no value is provided\n\nDefaults to false",
								type: "boolean"
							},
							default: {},
							description: { type: "string" },
							flagName: { type: "string" },
							name: { type: "string" },
							required: { type: "boolean" },
							showNegatedVariantInHelp: {
								description: "Whether or not to display the negated variant in the help output.\n\nApplicable for boolean flags only\n\nDefaults to false",
								type: "boolean"
							},
							type: {
								enum: [
									"string",
									"boolean",
									"number",
									"array"
								],
								type: "string"
							}
						},
						required: [
							"name",
							"flagName",
							"type"
						],
						type: "object"
					},
					type: "array"
				},
				help: {
					anyOf: [{ type: "string" }, {
						items: { type: "string" },
						type: "array"
					}],
					description: "Help text for the command"
				},
				namespace: {
					description: "Command namespace. The namespace is extracted from the command name",
					type: ["string", "null"]
				},
				options: {
					$ref: "#/definitions/CommandOptions",
					description: "Command configuration options"
				}
			},
			required: [
				"aliases",
				"args",
				"commandName",
				"description",
				"flags",
				"namespace",
				"options"
			],
			type: "object"
		},
		CommandOptions: {
			description: "Static set of command options",
			properties: {
				allowUnknownFlags: {
					description: "Whether or not to allow for unknown flags. If set to false, the command will not run when unknown flags are provided through the CLI\n\nDefaults to false",
					type: "boolean"
				},
				staysAlive: {
					description: "When flag set to true, the kernel will not trigger the termination process unless the command explicitly calls the terminate method.\n\nDefaults to false",
					type: "boolean"
				}
			},
			type: "object"
		}
	}
};
function sortAlphabetically(prev, curr) {
	if (curr > prev) return -1;
	if (curr < prev) return 1;
	return 0;
}
function renderErrorWithSuggestions(ui, message, suggestions) {
	const instructions = ui.sticker().fullScreen().drawBorder((borderChar, colors) => colors.red(borderChar));
	instructions.add(ui.colors.red(message));
	if (suggestions.length) {
		instructions.add("");
		instructions.add(`${ui.colors.dim("Did you mean?")} ${suggestions.slice(0, 4).join(", ")}`);
	}
	instructions.getRenderer().logError(instructions.prepare());
}
function validateCommandMetaData(command, exportPath) {
	if (!command || typeof command !== "object") throw new RuntimeException(`Invalid command metadata exported from ${exportPath}`);
	try {
		new Validator().validate(command, schema, { throwError: true });
	} catch (error) {
		throw new RuntimeException(`Invalid command exported from ${exportPath}. ${error.message}`);
	}
}
function validateCommand(command, exportPath) {
	if (typeof command !== "function" || !command.toString().startsWith("class ")) throw new RuntimeException(`Invalid command exported from ${exportPath}. Expected command to be a class`);
	const commandConstructor = command;
	if (typeof commandConstructor.serialize !== "function") throw new RuntimeException(`Invalid command exported from ${exportPath}. Expected command to extend the "BaseCommand"`);
	validateCommandMetaData(commandConstructor.serialize(), exportPath);
}
var ArgumentFormatter = class {
	#argument;
	#colors;
	constructor(argument, colors) {
		this.#argument = argument;
		this.#colors = colors;
	}
	#formatArgument(argument, valuePlaceholder) {
		return argument.required ? `${valuePlaceholder}` : `[${valuePlaceholder}]`;
	}
	formatDescription() {
		const defaultValue = this.#argument.default ? `[default: ${this.#argument.default}]` : "";
		const separator = defaultValue && this.#argument.description ? " " : "";
		return this.#colors.dim(`${this.#argument.description || ""}${separator}${defaultValue}`);
	}
	formatListOption() {
		switch (this.#argument.type) {
			case "spread": return `  ${this.#colors.green(this.#formatArgument(this.#argument, `${this.#argument.argumentName}...`))}  `;
			case "string": return `  ${this.#colors.green(this.#formatArgument(this.#argument, `${this.#argument.argumentName}`))}  `;
		}
	}
	formatOption() {
		switch (this.#argument.type) {
			case "spread": return this.#colors.dim(`${this.#formatArgument(this.#argument, `<${this.#argument.argumentName}...>`)}`);
			case "string": return this.#colors.dim(`${this.#formatArgument(this.#argument, `<${this.#argument.argumentName}>`)}`);
		}
	}
};
var CommandFormatter = class {
	#command;
	#colors;
	constructor(command, colors) {
		this.#command = command;
		this.#colors = colors;
	}
	formatListName(aliases) {
		const formattedAliases = aliases.length ? ` ${this.#colors.dim(`(${aliases.join(", ")})`)}` : "";
		return `  ${this.#colors.green(this.#command.commandName)}${formattedAliases}  `;
	}
	formatDescription() {
		return this.#command.description || "";
	}
	formatHelp(binaryName, terminalWidth = TERMINAL_SIZE) {
		const binary = binaryName ? `${binaryName}` : "";
		if (!this.#command.help) return "";
		return wrap((Array.isArray(this.#command.help) ? this.#command.help : [this.#command.help]).map((line) => string.interpolate(line, { binaryName: binary })), {
			startColumn: 2,
			trimStart: false,
			endColumn: terminalWidth
		}).join("\n");
	}
	formatListDescription() {
		if (!this.#command.description) return "";
		return this.#colors.dim(this.#command.description);
	}
	formatUsage(aliases, binaryName) {
		const binary = binaryName ? `${binaryName} ` : "";
		const flags = this.#command.flags.length ? this.#colors.dim("[options]") : "";
		const args = this.#command.args.map((arg) => new ArgumentFormatter(arg, this.#colors).formatOption()).join(" ");
		const separator = flags && args ? ` ${this.#colors.dim("[--]")} ` : "";
		return [`  ${binary}${this.#command.commandName} ${flags}${separator}${args}`].concat(aliases.map((alias) => `  ${binary}${alias} ${flags}${separator}${args}`));
	}
};
function __decorate(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var ListCommand = class extends BaseCommand {
	static commandName = "list";
	static description = "View list of available commands";
	static help = [
		"The list command displays a list of all the commands:",
		"  {{ binaryName }} list",
		"",
		"You can also display the commands for a specific namespace:",
		"  {{ binaryName }} list <namespace...>"
	];
	#makeCommandsTable(heading, commands) {
		return {
			heading: this.colors.yellow(heading),
			columns: commands.map((command) => {
				const aliases = this.kernel.getCommandAliases(command.commandName);
				const commandFormatter = new CommandFormatter(command, this.colors);
				return {
					option: commandFormatter.formatListName(aliases),
					description: commandFormatter.formatListDescription()
				};
			})
		};
	}
	#makeOptionsTable(heading, flagsList) {
		return {
			heading: this.colors.yellow(heading),
			columns: flagsList.map((flag) => {
				const flagFormatter = new FlagFormatter(flag, this.colors);
				return {
					option: flagFormatter.formatOption(),
					description: flagFormatter.formatDescription()
				};
			})
		};
	}
	#getCommandsTables(namespaces) {
		if (namespaces && namespaces.length) return namespaces.map((namespace) => {
			return this.#makeCommandsTable(namespace, this.kernel.getNamespaceCommands(namespace));
		});
		return [this.#makeCommandsTable("Available commands:", this.kernel.getNamespaceCommands()), ...this.kernel.getNamespaces().map((namespace) => this.#makeCommandsTable(namespace, this.kernel.getNamespaceCommands(namespace)))];
	}
	#getOptionsTable() {
		if (!this.kernel.flags.length) return [];
		return [this.#makeOptionsTable("Options:", this.kernel.flags)];
	}
	#validateNamespace() {
		if (!this.namespaces) return true;
		const namespaces = this.kernel.getNamespaces();
		const unknownNamespace = this.namespaces.find((namespace) => !namespaces.includes(namespace));
		if (unknownNamespace) {
			renderErrorWithSuggestions(this.ui, `Namespace "${unknownNamespace}" is not defined`, this.kernel.getNamespaceSuggestions(unknownNamespace));
			return false;
		}
		return true;
	}
	renderList() {
		new ListFormatter(this.#getOptionsTable().concat(this.#getCommandsTables(this.namespaces))).format().forEach((table) => {
			this.logger.log("");
			this.logger.log(table.heading);
			this.logger.log(table.rows.join("\n"));
		});
	}
	renderToJSON() {
		if (this.namespaces && this.namespaces.length) return this.namespaces.map((namespace) => {
			return this.kernel.getNamespaceCommands(namespace);
		}).flat(1);
		return this.kernel.getNamespaceCommands().concat(this.kernel.getNamespaces().map((namespace) => this.kernel.getNamespaceCommands(namespace)).flat(1));
	}
	async run() {
		if (!this.#validateNamespace()) {
			this.exitCode = 1;
			return;
		}
		if (this.json) {
			this.logger.log(JSON.stringify(this.renderToJSON(), null, 2));
			return;
		}
		this.renderList();
	}
};
__decorate([args.spread({
	description: "Filter list by namespace",
	required: false
})], ListCommand.prototype, "namespaces", void 0);
__decorate([flags.boolean({ description: "Get list of commands as JSON" })], ListCommand.prototype, "json", void 0);
var ListLoader = class {
	#commands;
	constructor(commands) {
		this.#commands = commands;
	}
	async getMetaData() {
		return this.#commands.map((command) => command.serialize());
	}
	async getCommand(metaData) {
		return this.#commands.find((command) => command.commandName === metaData.commandName) || null;
	}
};
var ExceptionHandler = class {
	debug = true;
	knownErrorCodes = [];
	internalKnownErrorCode = Object.keys(errors_exports);
	logError(error, kernel) {
		kernel.ui.logger.logError(`${kernel.ui.colors.bgRed().white("  ERROR  ")} ${error.message}`);
	}
	async prettyPrintError(error) {
		const { Youch } = await import("youch");
		const youch = new Youch();
		console.log(await youch.toANSI(error));
	}
	async render(error, kernel) {
		if (typeof error !== "object" || error === null || !("message" in error)) {
			this.logError({ message: String(error) }, kernel);
			return;
		}
		if (error instanceof E_COMMAND_NOT_FOUND) {
			renderErrorWithSuggestions(kernel.ui, error.message, kernel.getCommandSuggestions(error.commandName));
			return;
		}
		if (error instanceof errors.E_PROMPT_CANCELLED) {
			this.logError({ message: "Prompt cancelled" }, kernel);
			return;
		}
		if ("code" in error && typeof error.code === "string" && (this.internalKnownErrorCode.includes(error.code) || this.knownErrorCodes.includes(error.code))) {
			this.logError({ message: error.message }, kernel);
			return;
		}
		if ("render" in error && typeof error.render === "function") return error.render(error, kernel);
		if (!this.debug) {
			kernel.ui.logger.fatal(error);
			return;
		}
		return this.prettyPrintError(error);
	}
};
var tracing_channels_exports = /* @__PURE__ */ __exportAll({ commandExec: () => commandExec });
const commandExec = diagnostics_channel.tracingChannel("adonisjs.command.exec");
var Kernel = class Kernel {
	errorHandler = new ExceptionHandler();
	static commandExecutor = {
		create(command, parsedArgs, kernel) {
			return new command(kernel, parsedArgs, kernel.ui, kernel.prompt);
		},
		run(command) {
			return command.exec();
		}
	};
	static defaultCommand = ListCommand;
	static create() {
		return new Kernel(this.defaultCommand, this.commandExecutor);
	}
	#optionListeners = /* @__PURE__ */ new Map();
	#globalCommand = class extends BaseCommand {
		static options = { allowUnknownFlags: true };
	};
	#defaultCommand;
	#hooks = new Hooks();
	#executor;
	#mainCommand;
	#state = "idle";
	#loaders = [];
	#namespaces = [];
	#aliases = /* @__PURE__ */ new Map();
	#aliasExpansions = /* @__PURE__ */ new Map();
	#commands = /* @__PURE__ */ new Map();
	exitCode;
	ui = cliui();
	prompt = new Prompt();
	info = /* @__PURE__ */ new Map();
	get flags() {
		return this.#globalCommand.flags;
	}
	constructor(defaultCommand, executor) {
		this.#defaultCommand = defaultCommand;
		this.#executor = executor;
	}
	#processArgv(argv) {
		const commandNameIndex = argv.findIndex((value) => !value.startsWith("-"));
		if (commandNameIndex === -1) return {
			nodeArgv: [],
			commandName: null,
			commandArgv: argv
		};
		return {
			nodeArgv: argv.slice(0, commandNameIndex),
			commandName: argv[commandNameIndex],
			commandArgv: argv.slice(commandNameIndex + 1)
		};
	}
	async #create(Command, argv) {
		const parsed = new Parser(Command.getParserOptions()).parse(argv);
		Command.validate(parsed);
		const commandInstance = await this.#executor.create(Command, parsed, this);
		commandInstance.hydrate();
		return commandInstance;
	}
	async #exec(commandName, argv) {
		const Command = await this.find(commandName);
		const aliasExpansions = this.#aliasExpansions.get(commandName);
		if (aliasExpansions) {
			argv = aliasExpansions.concat(argv);
			debug_default("expanding alias %O, cli args %O", commandName, argv);
		}
		const commandInstance = await this.#create(Command, argv);
		await this.#hooks.runner("executing").run(commandInstance, false);
		await commandExec.tracePromise(this.#executor.run, commandExec.hasSubscribers ? {
			command: Command,
			commandInstance,
			argv
		} : void 0, this.#executor, commandInstance, this);
		await this.#hooks.runner("executed").run(commandInstance, false);
		return commandInstance;
	}
	async #execMain(commandName, nodeArgv, argv) {
		try {
			const Command = await this.find(commandName);
			const aliasExpansions = this.#aliasExpansions.get(commandName);
			if (aliasExpansions) {
				argv = aliasExpansions.concat(argv);
				debug_default("expanding alias %O, cli args %O", commandName, argv);
			}
			const parsed = new Parser(Command.getParserOptions(this.#globalCommand.getParserOptions().flagsParserOptions)).parse(argv);
			parsed.nodeArgs = nodeArgv;
			this.#globalCommand.validate(parsed);
			let shortcircuit = false;
			for (let [option, listener] of this.#optionListeners) if (parsed.flags[option] !== void 0) {
				debug_default("running listener for \"%s\" flag", option);
				shortcircuit = await listener(Command, this, parsed);
				if (shortcircuit) break;
			}
			Command.validate(parsed);
			if (shortcircuit) {
				debug_default("short circuiting from flag listener");
				this.exitCode = this.exitCode ?? 0;
				this.#state = "completed";
				return;
			}
			this.#mainCommand = await this.#executor.create(Command, parsed, this);
			this.#mainCommand.hydrate();
			await this.#hooks.runner("executing").run(this.#mainCommand, true);
			await commandExec.tracePromise(this.#executor.run, commandExec.hasSubscribers ? {
				command: Command,
				commandInstance: this.#mainCommand,
				argv
			} : void 0, this.#executor, this.#mainCommand, this);
			await this.#hooks.runner("executed").run(this.#mainCommand, true);
			this.exitCode = this.exitCode ?? this.#mainCommand.exitCode;
			this.#state = "completed";
		} catch (error) {
			this.exitCode = 1;
			this.#state = "completed";
			await this.errorHandler.render(error, this);
		}
	}
	on(option, callback) {
		debug_default("registering flag listener for \"%s\" flag", option);
		this.#optionListeners.set(option, callback);
		return this;
	}
	defineFlag(name, options) {
		if (this.#state !== "idle") throw new RuntimeException(`Cannot register global flag in "${this.#state}" state`);
		this.#globalCommand.defineFlag(name, options);
	}
	addLoader(loader) {
		if (this.#state !== "idle") throw new RuntimeException(`Cannot add loader in "${this.#state}" state`);
		this.#loaders.push(loader);
		return this;
	}
	addAlias(alias, command) {
		const [commandName, ...expansions] = command.split(" ");
		this.#aliases.set(alias, commandName);
		if (expansions.length) {
			debug_default("registering alias %O for command %O with options %O", alias, commandName, expansions);
			this.#aliasExpansions.set(alias, expansions);
		} else debug_default("registering alias %O for command %O", alias, commandName);
		return this;
	}
	hasCommand(commandName) {
		commandName = this.#aliases.get(commandName) || commandName;
		return this.#commands.has(commandName);
	}
	getState() {
		return this.#state;
	}
	getCommands() {
		return [...this.#commands.keys()].sort(sortAlphabetically).map((name) => this.#commands.get(name).metaData);
	}
	getNamespaceCommands(namespace) {
		let commandNames = [...this.#commands.keys()];
		if (namespace) commandNames = commandNames.filter((name) => this.#commands.get(name).metaData.namespace === namespace);
		else commandNames = commandNames.filter((name) => !this.#commands.get(name).metaData.namespace);
		return commandNames.sort(sortAlphabetically).map((name) => this.#commands.get(name).metaData);
	}
	getCommand(commandName) {
		return this.#commands.get(commandName)?.metaData || null;
	}
	getDefaultCommand() {
		return this.#defaultCommand;
	}
	getMainCommand() {
		return this.#mainCommand;
	}
	getAliases() {
		return [...this.#aliases.keys()];
	}
	getAliasCommand(alias) {
		const aliasCommand = this.#aliases.get(alias);
		if (!aliasCommand) return null;
		return this.#commands.get(aliasCommand)?.metaData || null;
	}
	getCommandAliases(commandName) {
		return [...this.#aliases.entries()].filter(([, command]) => {
			return command === commandName;
		}).map(([alias]) => alias);
	}
	getNamespaces() {
		return this.#namespaces;
	}
	getCommandSuggestions(keyword) {
		if (this.#namespaces.includes(keyword)) return this.getNamespaceCommands(keyword).map((command) => command.commandName);
		return [...this.#commands.keys()].concat([...this.#aliases.keys()]).map((value) => {
			return {
				value,
				distance: distance(keyword, value)
			};
		}).sort((current, next) => next.distance - current.distance).filter((rating) => {
			return rating.distance <= 3;
		}).map((rating) => rating.value);
	}
	getNamespaceSuggestions(keyword) {
		return this.#namespaces.map((value) => {
			return {
				value,
				distance: distance(keyword, value)
			};
		}).sort((current, next) => next.distance - current.distance).filter((rating) => {
			return rating.distance <= 3;
		}).map((rating) => rating.value);
	}
	finding(callback) {
		this.#hooks.add("finding", callback);
		return this;
	}
	loading(callback) {
		this.#hooks.add("loading", callback);
		return this;
	}
	loaded(callback) {
		this.#hooks.add("loaded", callback);
		return this;
	}
	executing(callback) {
		this.#hooks.add("executing", callback);
		return this;
	}
	executed(callback) {
		this.#hooks.add("executed", callback);
		return this;
	}
	async boot() {
		if (this.#state !== "idle") return;
		this.#globalCommand.boot();
		this.addLoader(new ListLoader([this.#defaultCommand]));
		this.#state = "booted";
		const namespaces = /* @__PURE__ */ new Set();
		for (let loader of this.#loaders) {
			let loaderInstance;
			if (typeof loader === "function") loaderInstance = await loader();
			else loaderInstance = loader;
			(await loaderInstance.getMetaData()).forEach((command) => {
				this.#commands.set(command.commandName, {
					metaData: command,
					loader: loaderInstance
				});
				command.aliases.forEach((alias) => this.addAlias(alias, command.commandName));
				command.namespace && namespaces.add(command.namespace);
			});
		}
		this.#namespaces = [...namespaces].sort(sortAlphabetically);
	}
	async find(commandName) {
		commandName = this.#aliases.get(commandName) || commandName;
		await this.#hooks.runner("finding").run(commandName);
		const command = this.#commands.get(commandName);
		if (!command) throw new E_COMMAND_NOT_FOUND([commandName]);
		await this.#hooks.runner("loading").run(command.metaData);
		const commandConstructor = await command.loader.getCommand(command.metaData);
		if (!commandConstructor) throw new E_COMMAND_NOT_FOUND([commandName]);
		await this.#hooks.runner("loaded").run(commandConstructor);
		return commandConstructor;
	}
	async exec(commandName, argv) {
		if (this.#state === "idle") await this.boot();
		if (this.#state === "completed") throw new RuntimeException("The kernel has been terminated. Create a fresh instance to execute commands");
		return this.#exec(commandName, argv);
	}
	async create(command, argv) {
		if (this.#state === "idle") await this.boot();
		return this.#create(command, argv);
	}
	async handle(argv) {
		if (this.#state === "running") throw new RuntimeException("Cannot run multiple main commands from a single process");
		if (this.#state === "completed") throw new RuntimeException("The kernel has been terminated. Create a fresh instance to execute commands");
		if (this.#state === "idle") await this.boot();
		this.#state = "running";
		const { commandName, nodeArgv, commandArgv } = this.#processArgv(argv);
		if (!commandName) {
			debug_default("running default command \"%s\"", this.#defaultCommand.commandName);
			return this.#execMain(this.#defaultCommand.commandName, nodeArgv, commandArgv);
		}
		debug_default("running main command \"%s\"", commandName);
		return this.#execMain(commandName, nodeArgv, commandArgv);
	}
	shortcircuit() {
		return true;
	}
};
var HelpCommand = class extends BaseCommand {
	static commandName = "help";
	static description = "View help for a given command";
	#makeArgumentsTable(heading, command) {
		if (!command.args.length) return [];
		return [{
			heading: this.colors.yellow(heading),
			columns: command.args.map((arg) => {
				const formatter = new ArgumentFormatter(arg, this.colors);
				return {
					option: formatter.formatListOption(),
					description: formatter.formatDescription()
				};
			})
		}];
	}
	#makeOptionsTable(heading, command) {
		if (!command.flags.length) return [];
		return [{
			heading: this.colors.yellow(heading),
			columns: command.flags.map((flag) => {
				const formatter = new FlagFormatter(flag, this.colors);
				return {
					option: formatter.formatOption(),
					description: formatter.formatDescription()
				};
			})
		}];
	}
	#validateCommandName() {
		if (!this.kernel.getCommand(this.name)) {
			renderErrorWithSuggestions(this.ui, `Command "${this.name}" is not defined`, this.kernel.getCommandSuggestions(this.name));
			return false;
		}
		return true;
	}
	renderDescription(command) {
		const description = new CommandFormatter(command, this.colors).formatDescription();
		if (!description) return;
		this.logger.log("");
		this.logger.log(this.colors.yellow("Description:"));
		this.logger.log(wrap([description], {
			startColumn: 2,
			trimStart: false,
			endColumn: TERMINAL_SIZE
		}).join("\n"));
	}
	renderUsage(command) {
		const aliases = this.kernel.getCommandAliases(command.commandName);
		const usage = new CommandFormatter(command, this.colors).formatUsage(aliases, this.kernel.info.get("binary")).join("\n");
		this.logger.log("");
		this.logger.log(this.colors.yellow("Usage:"));
		this.logger.log(usage);
	}
	renderList(command) {
		new ListFormatter(this.#makeArgumentsTable("Arguments:", command).concat(this.#makeOptionsTable("Options:", command))).format().forEach((table) => {
			this.logger.log("");
			this.logger.log(table.heading);
			this.logger.log(table.rows.join("\n"));
		});
	}
	renderHelp(command) {
		const help = new CommandFormatter(command, this.colors).formatHelp(this.kernel.info.get("binary"));
		if (!help) return;
		this.logger.log("");
		this.logger.log(this.colors.yellow("Help:"));
		this.logger.log(help);
	}
	async run() {
		if (!this.#validateCommandName()) {
			this.exitCode = 1;
			return;
		}
		const command = this.kernel.getCommand(this.name);
		this.renderDescription(command);
		this.renderUsage(command);
		this.renderList(command);
		this.renderHelp(command);
	}
};
__decorate([args.string({
	description: "Command name",
	argumentName: "command"
})], HelpCommand.prototype, "name", void 0);
const JS_MODULES = [
	".js",
	".cjs",
	".mjs"
];
var FsLoader = class {
	#comandsDirectory;
	#filter;
	#commands = [];
	constructor(comandsDirectory, filter) {
		this.#comandsDirectory = comandsDirectory;
		this.#filter = filter;
	}
	async #loadCommands() {
		const commands = {};
		const commandFiles = await fsReadAll(this.#comandsDirectory, {
			pathType: "url",
			ignoreMissingRoot: true,
			filter: (filePath) => {
				const ext = extname(filePath);
				if (basename(filePath).startsWith("_")) return false;
				if (JS_MODULES.includes(ext)) return true;
				if (ext === ".ts" && !filePath.endsWith(".d.ts")) return true;
				return false;
			}
		});
		for (let file of commandFiles) {
			if (file.endsWith(".ts")) file = file.replace(/\.ts$/, ".js");
			const relativeFileName = string.toUnixSlash(relative(this.#comandsDirectory, fileURLToPath(file)));
			if (!this.#filter || this.#filter(relativeFileName)) commands[relativeFileName] = await importDefault(() => import(file), relativeFileName);
		}
		return commands;
	}
	async getMetaData() {
		const commandsCollection = await this.#loadCommands();
		Object.keys(commandsCollection).forEach((key) => {
			const command = commandsCollection[key];
			validateCommand(command, `"${key}" file`);
			this.#commands.push({
				command,
				filePath: key
			});
		});
		return this.#commands.map(({ command, filePath }) => {
			return Object.assign({}, command.serialize(), { filePath });
		});
	}
	async getCommand(metaData) {
		return this.#commands.find(({ command }) => {
			return command.commandName === metaData.commandName;
		})?.command || null;
	}
};
const stubsRoot = import.meta.dirname;
var IndexGenerator = class {
	#commandsDir;
	constructor(commandsDir) {
		this.#commandsDir = commandsDir;
	}
	async generate() {
		const commandsMetaData = await new FsLoader(this.#commandsDir).getMetaData();
		const indexJSON = JSON.stringify({
			commands: commandsMetaData,
			version: 1
		});
		const indexFile = join(this.#commandsDir, "commands.json");
		const loaderFile = join(this.#commandsDir, "main.js");
		const loaderStub = join(stubsRoot, "commands_loader.stub");
		const loaderTypes = join(this.#commandsDir, "main.d.ts");
		const loaderTypesStub = join(stubsRoot, "commands_loader_types.stub");
		await mkdir(this.#commandsDir, { recursive: true });
		console.log(`artifacts directory: ${this.#commandsDir}`);
		await writeFile(indexFile, indexJSON);
		console.log("create commands.json");
		await copyFile(loaderStub, loaderFile);
		console.log("create main.js");
		await copyFile(loaderTypesStub, loaderTypes);
		console.log("create main.d.ts");
	}
};
export { BaseCommand, ExceptionHandler, FsLoader, HelpCommand, IndexGenerator, Kernel, ListCommand, ListLoader, Parser, args, cliHelpers, errors_exports as errors, flags, tracing_channels_exports as tracingChannels };
