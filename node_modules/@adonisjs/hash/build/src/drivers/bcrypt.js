import { PhcFormatter } from "../phc_formatter.js";
import { a as randomBytesAsync, i as RangeValidator, t as EnumValidator } from "../../utils-Cqz2R6j1.js";
import "node:module";
import { safeEqual } from "@poppinss/utils";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var import_bcrypt_base64 = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports, module) => {
	const BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
	const BASE64_INDEX = [
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		0,
		1,
		54,
		55,
		56,
		57,
		58,
		59,
		60,
		61,
		62,
		63,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		2,
		3,
		4,
		5,
		6,
		7,
		8,
		9,
		10,
		11,
		12,
		13,
		14,
		15,
		16,
		17,
		18,
		19,
		20,
		21,
		22,
		23,
		24,
		25,
		26,
		27,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		28,
		29,
		30,
		31,
		32,
		33,
		34,
		35,
		36,
		37,
		38,
		39,
		40,
		41,
		42,
		43,
		44,
		45,
		46,
		47,
		48,
		49,
		50,
		51,
		52,
		53,
		-1,
		-1,
		-1,
		-1,
		-1
	];
	function encode(buff) {
		const len = buff.byteLength;
		let off = 0;
		const stra = [];
		while (off < len) {
			let c1 = buff[off++] & 255;
			stra.push(BASE64_CODE[c1 >> 2 & 63]);
			c1 = (c1 & 3) << 4;
			if (off >= len) {
				stra.push(BASE64_CODE[c1 & 63]);
				break;
			}
			let c2 = buff[off++] & 255;
			c1 |= c2 >> 4 & 15;
			stra.push(BASE64_CODE[c1 & 63]);
			c1 = (c2 & 15) << 2;
			if (off >= len) {
				stra.push(BASE64_CODE[c1 & 63]);
				break;
			}
			c2 = buff[off++] & 255;
			c1 |= c2 >> 6 & 3;
			stra.push(BASE64_CODE[c1 & 63]);
			stra.push(BASE64_CODE[c2 & 63]);
		}
		return stra.join("");
	}
	function decode(str) {
		let off = 0;
		let olen = 0;
		const slen = str.length;
		const stra = [];
		const len = str.length;
		while (off < slen - 1 && olen < len) {
			let code = str.charCodeAt(off++);
			const c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
			code = str.charCodeAt(off++);
			const c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
			if (c1 === -1 || c2 === -1) break;
			let o = c1 << 2 >>> 0;
			o |= (c2 & 48) >> 4;
			stra.push(String.fromCharCode(o));
			if (++olen >= len || off >= slen) break;
			code = str.charCodeAt(off++);
			const c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
			if (c3 === -1) break;
			o = (c2 & 15) << 4 >>> 0;
			o |= (c3 & 60) >> 2;
			stra.push(String.fromCharCode(o));
			if (++olen >= len || off >= slen) break;
			code = str.charCodeAt(off++);
			const c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
			o = (c3 & 3) << 6 >>> 0;
			o |= c4;
			stra.push(String.fromCharCode(o));
			++olen;
		}
		const buffa = [];
		for (off = 0; off < olen; off++) buffa.push(stra[off].charCodeAt(0));
		return Buffer.from(buffa);
	}
	module.exports = {
		encode,
		decode
	};
})))(), 1);
var Bcrypt = class {
	#binding;
	#config;
	#phcFormatter = new PhcFormatter();
	constructor(config) {
		this.#config = {
			rounds: 10,
			saltSize: 16,
			version: 98,
			...config
		};
		this.#validateConfig();
	}
	async #importBinding() {
		if (this.#binding) return this.#binding;
		this.#binding = await import("bcrypt");
		return this.#binding;
	}
	#generateBcryptSalt(salt, version, rounds) {
		return `$2${String.fromCharCode(version)}$${rounds > 9 ? `${rounds}` : `0${rounds}`}$${import_bcrypt_base64.encode(salt)}`;
	}
	#validateConfig() {
		RangeValidator.validate("rounds", this.#config.rounds, [4, 31]);
		RangeValidator.validate("saltSize", this.#config.saltSize, [8, 1024]);
		EnumValidator.validate("version", this.#config.version, [97, 98]);
		Object.freeze(this.#config);
	}
	#validatePhcString(phcString) {
		const phcNode = this.#phcFormatter.deserialize(phcString);
		if (!phcNode.version) phcNode.version = 97;
		if (phcNode.id !== "bcrypt") throw new TypeError(`Invalid "id" found in the phc string`);
		if (!phcNode.params) throw new TypeError(`No "params" found in the phc string`);
		if (!phcNode.salt) throw new TypeError(`No "salt" found in the phc string`);
		if (!phcNode.hash) throw new TypeError(`No "hash" found in the phc string`);
		if (!phcNode.hash.byteLength) throw new TypeError(`No "hash" found in the phc string`);
		RangeValidator.validate("salt.byteLength", phcNode.salt.byteLength, [8, 1024]);
		EnumValidator.validate("version", phcNode.version, [97, 98]);
		RangeValidator.validate("r", phcNode.params.r, [4, 31]);
		return {
			id: phcNode.id,
			version: phcNode.version,
			hash: phcNode.hash,
			salt: phcNode.salt,
			params: { r: phcNode.params.r }
		};
	}
	isValidHash(value) {
		try {
			this.#validatePhcString(value);
			return true;
		} catch {
			return false;
		}
	}
	async make(value) {
		const driver = await this.#importBinding();
		const salt = await randomBytesAsync(this.#config.saltSize);
		const bcryptSalt = this.#generateBcryptSalt(salt, this.#config.version, this.#config.rounds);
		const bcryptHash = await driver.hash(value, bcryptSalt);
		const hash = import_bcrypt_base64.decode(bcryptHash.split(bcryptSalt)[1]);
		return this.#phcFormatter.serialize(salt, hash, {
			id: "bcrypt",
			version: this.#config.version,
			params: { r: this.#config.rounds }
		});
	}
	async verify(hashedValue, plainValue) {
		const driver = await this.#importBinding();
		try {
			if (hashedValue.startsWith("$2b") || hashedValue.startsWith("$2a")) return await driver.compare(plainValue, hashedValue);
			const phcNode = this.#validatePhcString(hashedValue);
			const bcryptSalt = this.#generateBcryptSalt(phcNode.salt, phcNode.version, phcNode.params.r);
			const bcryptHash = await driver.hash(plainValue, bcryptSalt);
			return safeEqual(import_bcrypt_base64.decode(bcryptHash.split(bcryptSalt)[1]), phcNode.hash);
		} catch {
			return false;
		}
	}
	needsReHash(value) {
		if (value.startsWith("$2b") || value.startsWith("$2a")) return true;
		const phcNode = this.#phcFormatter.deserialize(value);
		if (phcNode.id !== "bcrypt") return true;
		if (phcNode.version !== this.#config.version) return true;
		if (!phcNode.params) return true;
		if (phcNode.params.r !== this.#config.rounds) return true;
		return false;
	}
};
export { Bcrypt };
