import { PhcFormatter } from "../phc_formatter.js";
import { a as randomBytesAsync, i as RangeValidator, o as scryptAsync, r as MAX_UINT32 } from "../../utils-Cqz2R6j1.js";
import { safeEqual } from "@poppinss/utils";
var Scrypt = class {
	#config;
	#phcFormatter = new PhcFormatter();
	constructor(config) {
		this.#config = {
			cost: 16384,
			blockSize: 8,
			parallelization: 1,
			saltSize: 16,
			keyLength: 64,
			maxMemory: 32 * 1024 * 1024,
			...config
		};
		this.#validateConfig();
	}
	#validateConfig() {
		RangeValidator.validate("blockSize", this.#config.blockSize, [1, MAX_UINT32]);
		RangeValidator.validate("cost", this.#config.cost, [2, MAX_UINT32]);
		RangeValidator.validate("parallelization", this.#config.parallelization, [1, Math.floor((Math.pow(2, 32) - 1) * 32 / (128 * this.#config.blockSize))]);
		RangeValidator.validate("saltSize", this.#config.saltSize, [8, 1024]);
		RangeValidator.validate("keyLength", this.#config.keyLength, [64, 128]);
		RangeValidator.validate("maxMemory", this.#config.maxMemory, [128 * this.#config.cost * this.#config.blockSize + 1, MAX_UINT32]);
		Object.freeze(this.#config);
	}
	#validatePhcString(phcString) {
		const phcNode = this.#phcFormatter.deserialize(phcString);
		if (phcNode.id !== "scrypt") throw new TypeError(`Invalid "id" found in the phc string`);
		if (!phcNode.params) throw new TypeError(`No "params" found in the phc string`);
		if (!phcNode.salt) throw new TypeError(`No "salt" found in the phc string`);
		if (!phcNode.hash) throw new TypeError(`No "hash" found in the phc string`);
		RangeValidator.validate("hash.byteLength", phcNode.hash.byteLength, [64, 128]);
		RangeValidator.validate("salt.byteLength", phcNode.salt.byteLength, [8, 1024]);
		RangeValidator.validate("r", phcNode.params.r, [1, MAX_UINT32]);
		RangeValidator.validate("n", phcNode.params.n, [1, MAX_UINT32]);
		RangeValidator.validate("p", phcNode.params.p, [1, Math.floor((Math.pow(2, 32) - 1) * 32 / (128 * phcNode.params.r))]);
		return {
			id: phcNode.id,
			hash: phcNode.hash,
			salt: phcNode.salt,
			params: {
				r: phcNode.params.r,
				n: phcNode.params.n,
				p: phcNode.params.p
			}
		};
	}
	isValidHash(value) {
		try {
			this.#validatePhcString(value);
			return true;
		} catch {
			return false;
		}
	}
	async make(value) {
		const salt = await randomBytesAsync(this.#config.saltSize);
		const hash = await scryptAsync(value, salt, this.#config.keyLength, {
			cost: this.#config.cost,
			blockSize: this.#config.blockSize,
			parallelization: this.#config.parallelization,
			maxmem: this.#config.maxMemory
		});
		return this.#phcFormatter.serialize(salt, hash, {
			id: "scrypt",
			params: {
				n: this.#config.cost,
				r: this.#config.blockSize,
				p: this.#config.parallelization
			}
		});
	}
	async verify(hashedValue, plainValue) {
		try {
			const phcNode = this.#validatePhcString(hashedValue);
			return safeEqual(await scryptAsync(plainValue, phcNode.salt, phcNode.hash.byteLength, {
				cost: phcNode.params.n,
				blockSize: phcNode.params.r,
				parallelization: phcNode.params.p,
				maxmem: this.#config.maxMemory
			}), phcNode.hash);
		} catch {
			return false;
		}
	}
	needsReHash(value) {
		const phcNode = this.#phcFormatter.deserialize(value);
		if (phcNode.id !== "scrypt") return true;
		if (!phcNode.params) return true;
		if (phcNode.params.n !== this.#config.cost) return true;
		if (phcNode.params.r !== this.#config.blockSize) return true;
		if (phcNode.params.p !== this.#config.parallelization) return true;
		return false;
	}
};
export { Scrypt };
