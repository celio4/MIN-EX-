import type { ScryptConfig, HashDriverContract } from '../types.ts';
/**
 * Hash driver built on top of "scrypt" hash algorigthm. Under the hood
 * we make use of the Node.js crypto module
 *
 * The Scrypt implementation uses the PHC formatting for creating
 * and verifying hashes.
 *
 * ```ts
 * const scrypt = new Scrypt({})
 *
 * await scrypt.make('secret')
 * // $scrypt$n=16384,r=8,p=1$iILKD1gVSx6bqualYqyLBQ$DNzIISdmTQS6sFdQ1tJ3UCZ7Uun4uGHNjj0x8FHOqB0pf2LYsu9Xaj5MFhHg21qBz8l5q/oxpeV+ZkgTAj+OzQ
 * ```
 */
export declare class Scrypt implements HashDriverContract {
    #private;
    /**
     * Create a new Scrypt hash driver instance
     *
     * @param config - Configuration options for the Scrypt hasher
     */
    constructor(config: ScryptConfig);
    /**
     * Check if the value is a valid hash. This method just checks
     * for the formatting of the hash.
     *
     * ```ts
     * scrypt.isValidHash('hello world') // false
     * scrypt.isValidHash('$scrypt$n=16384,r=8,p=1$iILKD1gVSx6bqualYqyLBQ$DNzIISdmTQS6sFdQ1tJ3UCZ7Uun4uGHNjj0x8FHOqB0pf2LYsu9Xaj5MFhHg21qBz8l5q/oxpeV+ZkgTAj+OzQ')
     * ```
     *
     * @param value - The value to check
     * @return True if the value is a valid Scrypt hash format
     */
    isValidHash(value: string): boolean;
    /**
     * Hash a plain text value
     *
     * ```ts
     * const hash = await scrypt.make('password')
     * ```
     *
     * @param value - The plain text value to hash
     * @return Promise resolving to the Scrypt hash
     */
    make(value: string): Promise<string>;
    /**
     * Verify the plain text value against an existing hash
     *
     * ```ts
     * if (await scrypt.verify(hash, plainText)) {
     *
     * }
     * ```
     *
     * @param hashedValue - The hashed value to verify against
     * @param plainValue - The plain text value to verify
     * @return Promise resolving to true if verification succeeds
     */
    verify(hashedValue: string, plainValue: string): Promise<boolean>;
    /**
     * Find if the hash value needs a rehash or not. The rehash is
     * required when.
     *
     * 1. The cost value is changed
     * 2. The blockSize value is changed
     * 3. The parallelization value is changed
     * 4. The provided hash has not been hashed with scrypt
     *
     * ```ts
     * const isValid = await scrypt.verify(hash, plainText)
     *
     * // Plain password is valid and hash needs a rehash
     * if (isValid && await scrypt.needsReHash(hash)) {
     *   const newHash = await scrypt.make(plainText)
     * }
     * ```
     *
     * @param value - The hashed value to check
     * @return True if the hash needs to be rehashed
     */
    needsReHash(value: string): boolean;
}
