import { a as Paginator, i as Collection, n as tracing_channels_exports, t as Item } from "./item-BcB-a9Ef.js";
import { isObject, resolveValues } from "./src/helpers.js";
import { RuntimeException } from "@poppinss/exception";
import { Container } from "@adonisjs/fold";
var Maybe = class {
	constructor(value) {
		this.value = value;
	}
};
var BaseTransformer = class {
	static transform(data, ...rest) {
		const canBeOptional = data instanceof Maybe;
		const unwrappedValue = canBeOptional ? data.value : data;
		if (canBeOptional && unwrappedValue === void 0) return;
		if (Array.isArray(unwrappedValue)) return new Collection([unwrappedValue, rest], this, 1, "toObject", new RuntimeException());
		if (unwrappedValue === null) return null;
		return new Item([unwrappedValue, rest], this, 1, "toObject", new RuntimeException());
	}
	static paginate(data, metaData, ...rest) {
		return new Paginator(new Collection([data, rest], this, 1, "toObject", new RuntimeException()), metaData);
	}
	constructor(resource) {
		this.resource = resource;
	}
	whenLoaded(value) {
		return new Maybe(value);
	}
	omit(data, keys) {
		const result = { ...data };
		for (const key of keys) delete result[key];
		return result;
	}
	pick(data, keys) {
		const result = {};
		for (const key of keys) result[key] = data[key];
		return result;
	}
	when(conditional, resolver, fallback) {
		return conditional ? resolver() : fallback ?? void 0;
	}
};
var BaseSerializer = class {
	#wrap(value, wrapper) {
		if (!wrapper) return value;
		return { [wrapper]: value };
	}
	isLucidPaginatorMetaData(metaData) {
		if (!metaData || typeof metaData !== "object" || Array.isArray(metaData)) return false;
		return [
			"total",
			"perPage",
			"currentPage",
			"lastPage",
			"firstPage",
			"firstPageUrl",
			"lastPageUrl",
			"nextPageUrl",
			"previousPageUrl"
		].every((key) => key in metaData);
	}
	serialize(data, resolver) {
		if (data === null) throw new RuntimeException("Cannot serialize an item with null value");
		const containerResolver = resolver ?? new Container().createResolver();
		if (data instanceof Item) return data.resolve(containerResolver, 0, -1).then((value) => this.#wrap(value, this.wrap));
		if (data instanceof Collection) return data.resolve(containerResolver, 0, -1).then((value) => this.#wrap(value, this.wrap));
		if (data instanceof Paginator) {
			const wrapperKey = this.wrap ?? "data";
			return data.resolve(containerResolver, 0, -1).then((value) => {
				return {
					[wrapperKey]: value.data,
					metadata: this.definePaginationMetaData(value.metadata)
				};
			});
		}
		if (isObject(data)) return resolveValues(containerResolver, data, 0, -1).then((value) => this.#wrap(value, this.wrap));
		return data;
	}
	serializeWithoutWrapping(data, resolver) {
		if (data === null) throw new RuntimeException("Cannot serialize an item with null value");
		const containerResolver = resolver ?? new Container().createResolver();
		if (data instanceof Item) return data.resolve(containerResolver, 0, -1);
		if (data instanceof Collection) return data.resolve(containerResolver, 0, -1);
		if (data instanceof Paginator) return data.resolve(containerResolver, 0, -1).then((value) => {
			return {
				data: value.data,
				metadata: this.definePaginationMetaData(value.metadata)
			};
		});
		if (isObject(data)) return resolveValues(containerResolver, data, 0, -1);
		return data;
	}
};
export { BaseSerializer, BaseTransformer, Collection, Item, Maybe, Paginator, tracing_channels_exports as tracingChannels };
