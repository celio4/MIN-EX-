import type { ContainerResolver } from '@adonisjs/fold';
import { type Collection } from './resource/collection.ts';
import { type UnpackAsTopLevelPaginator, type ExtractTransformerVariants, type Next } from './types.ts';
/**
 * Represents paginated data that combines a collection of transformed items
 * with pagination metadata. This class is typically created using the
 * `BaseTransformer.paginate()` method.
 *
 * @template Transformer - The transformer class used to transform each item
 * @template MaxDepth - The maximum depth for nested resource resolution
 * @template Variant - The variant method name to use for transformation
 *
 * ```typescript
 * class UserTransformer extends BaseTransformer<User> {
 *   toObject() {
 *     return {
 *       id: this.resource.id,
 *       name: this.resource.name
 *     }
 *   }
 * }
 *
 * const paginator = UserTransformer.paginate(
 *   users,
 *   { page: 1, perPage: 10, total: 100 }
 * )
 *
 * const result = await serializer.serialize(paginator)
 * // Result: { data: [...], metadata: { page: 1, perPage: 10, total: 100 } }
 * ```
 */
export declare class Paginator<Transformer extends Record<string, any>, MaxDepth extends Next[number], Variant extends string> {
    collection: Collection<Transformer, MaxDepth, Variant>;
    metaData: any;
    /**
     * Type identifier for the paginator instance, used for runtime type discrimination.
     */
    $type: 'paginator';
    /**
     * Creates a new Paginator instance. This constructor is typically not called directly.
     * Use `BaseTransformer.paginate()` instead.
     *
     * @param collection - The collection of transformed data to paginate
     * @param metaData - Pagination metadata (page, perPage, total, etc.)
     */
    constructor(collection: Collection<Transformer, MaxDepth, Variant>, metaData: any);
    /**
     * Specify the maximum depth of nested relationships to be resolved when
     * serializing the paginated collection.
     *
     * This is useful to prevent infinite recursion or to limit the amount of data
     * fetched for deeply nested relationships. Relationships beyond this depth will
     * be excluded from the serialized output.
     *
     * @param value Maximum depth level for nested transformations (valid values: 1, 2, 3, 4, 5, or 6)
     *
     * @example
     * ```ts
     * const paginatedPosts = PostTransformer.paginate(posts, { page: 1, total: 100 })
     *   .depth(2)
     *
     * // This allows: posts -> comments -> author (2 levels)
     * // But excludes: posts -> comments -> author -> profile (3 levels)
     * ```
     */
    depth<T extends Next[number]>(value: T): Paginator<Transformer, T, Variant>;
    /**
     * Specify which transformer variant method to use for serialization.
     *
     * Transformers can define multiple methods (variants) for different representations
     * of the same data (e.g., toObject, toSummary, toDetailed). This method allows you
     * to choose which variant to use for this paginated collection.
     *
     * @param value Name of the transformer variant method to use (must be a method name that
     *              returns ResourceData or Promise<ResourceData>)
     *
     * @example
     * ```ts
     * // Use default toObject variant
     * const users = UserTransformer.paginate(userData, { page: 1, total: 100 })
     *
     * // Use custom toSummary variant for lighter payload
     * const userSummaries = UserTransformer.paginate(userData, { page: 1, total: 100 })
     *   .useVariant('toSummary')
     *
     * // Use detailed variant for admin view
     * const detailedUsers = UserTransformer.paginate(userData, { page: 1, total: 100 })
     *   .useVariant('toDetailed')
     * ```
     */
    useVariant<V extends ExtractTransformerVariants<Transformer>>(value: V): Paginator<Transformer, MaxDepth, V>;
    /**
     * Resolves the paginated data by combining the serialized collection
     * with pagination metadata. This method is typically called internally by
     * the serializer function.
     *
     * @param container - Container resolver for dependency injection
     * @param depth - Current depth level in the transformation tree
     * @param maxDepth - Optional maximum depth override
     */
    resolve(container: ContainerResolver<any>, depth: number, maxDepth?: number): Promise<UnpackAsTopLevelPaginator<this, 'data', undefined>>;
}
