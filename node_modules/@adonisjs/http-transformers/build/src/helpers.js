import { a as Paginator, i as Collection, o as debug, r as transformerResolver, t as Item } from "../item-BcB-a9Ef.js";
import { RuntimeException } from "@poppinss/exception";
function isObject(value) {
	return value !== null && typeof value === "object" && !Array.isArray(value);
}
async function transformAndResolve(container, transformer, variant, depth, maxDepth) {
	const input = await transformerResolver.tracePromise((t, v) => container.call(t, v), transformerResolver.hasSubscribers ? {
		transformer,
		variant,
		depth,
		maxDepth
	} : void 0, void 0, transformer, variant);
	if (!isObject(input)) throw new RuntimeException(`Invalid value returned by ${transformer.constructor.name}.${variant}. The returned value must be an object`);
	if (debug.enabled) debug("serializing \"%s\" output %O", `${transformer.constructor.name}.${variant}`, input);
	return resolveValues(container, input, depth, maxDepth);
}
async function resolveValues(container, input, depth, maxDepth) {
	const promises = [];
	const output = {};
	for (const [key, value] of Object.entries(input)) if (value instanceof Item || value instanceof Collection || value instanceof Paginator) {
		debug("resolving key \"%s\" with maxDepth=\"%s\" and depth=\"%s\"", key, maxDepth, depth);
		if (maxDepth && maxDepth !== -1 && depth >= maxDepth) continue;
		else promises.push(value.resolve(container, maxDepth === -1 ? depth : depth + 1, maxDepth).then((result) => [key, result]));
	} else output[key] = value;
	const resolvedPromises = await Promise.all(promises);
	for (const [key, value] of resolvedPromises) output[key] = value;
	return output;
}
export { isObject, resolveValues, transformAndResolve };
