import type { ContainerResolver } from '@adonisjs/fold';
import type { JSONDataTypes, ResourceData } from './types.ts';
/**
 * Checks if a value is a plain object, excluding arrays and null values.
 *
 * This type guard is used internally to validate transformer outputs and
 * ensure that only plain objects are processed during serialization.
 *
 * @param value - The value to check for object type
 *
 * ```ts
 * isObject({}) // true
 * isObject({ key: 'value' }) // true
 * isObject([]) // false
 * isObject(null) // false
 * isObject("string") // false
 * isObject(42) // false
 * ```
 */
export declare function isObject<T extends Record<string, any>>(value: unknown): value is T;
/**
 * Transforms data using a transformer instance by calling the specified variant method,
 * then serializes the result recursively. Validates that the transformer returns an object.
 *
 * This function is used internally during the serialization process to execute transformer
 * methods and recursively process their outputs. It ensures the transformer returns a valid
 * object and handles nested relationships up to the specified depth.
 *
 * @param container - AdonisJS container resolver for dependency injection when calling transformer methods
 * @param transformer - The transformer instance containing the variant method to execute
 * @param variant - The transformer method name to call (e.g., 'toObject', 'toSummary')
 * @param depth - Current depth level in the transformation tree (starts at 0)
 * @param maxDepth - Optional maximum depth limit for nested relationships. Use -1 for unlimited depth
 *
 * ```ts
 * const container = app.container.createResolver()
 * const userTransformer = new UserTransformer(userData)
 *
 * // Transform using default toObject method at depth 0, max depth 3
 * const result = await transformAndSerialize(
 *   container,
 *   userTransformer,
 *   'toObject',
 *   0,
 *   3
 * )
 *
 * // Transform using custom variant
 * const summary = await transformAndSerialize(
 *   container,
 *   userTransformer,
 *   'toSummary',
 *   1,
 *   2
 * )
 * ```
 */
export declare function transformAndResolve(container: ContainerResolver<any>, transformer: Record<string, any>, variant: string, depth: number, maxDepth?: number): Promise<{
    [key: string]: JSONDataTypes;
}>;
/**
 * Recursively serializes values from a resource data object by resolving nested
 * Items, Collections, and Paginators up to the specified depth.
 *
 * This function processes a resource data object and:
 * - Resolves nested Item, Collection, and Paginator instances by calling their serialize methods
 * - Respects depth limits to prevent infinite recursion in circular relationships
 * - Processes values in parallel for optimal performance
 * - Passes through primitive values and plain objects unchanged
 *
 * @param container - AdonisJS container resolver for dependency injection
 * @param input - The resource data object containing values to serialize (keys to ResourceDataTypes)
 * @param depth - Current depth level in the transformation tree (starts at 0)
 * @param maxDepth - Optional maximum depth limit to prevent deep recursion. Use -1 for unlimited depth,
 *                    or specify a number (e.g., 3) to limit nesting. When depth reaches maxDepth,
 *                    nested resources are skipped
 *
 * ```ts
 * const container = app.container.createResolver()
 *
 * // Serialize resource data with nested transformers
 * const resourceData = {
 *   id: 1,
 *   name: 'John',
 *   user: UserTransformer.transform(userData),
 *   posts: PostTransformer.transform(postsData)
 * }
 * const result = await serializeValues(container, resourceData, 0, 2)
 * // Result: { id: 1, name: 'John', user: {...}, posts: [...] }
 *
 * // With depth limit reached, nested resources are excluded
 * const limitedResult = await serializeValues(container, resourceData, 3, 3)
 * ```
 */
export declare function resolveValues(container: ContainerResolver<any>, input: ResourceData, depth: number, maxDepth?: number): Promise<{
    [key: string]: JSONDataTypes;
}>;
