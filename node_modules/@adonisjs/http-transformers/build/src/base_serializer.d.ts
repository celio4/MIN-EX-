import { type ContainerResolver } from '@adonisjs/fold';
import { type ItemContract, type PaginatorContract, type ResourceDataTypes, type CollectionContract, type UnpackTopLevelValues, type UnpackAsTopLevelItem, type UnpackAsTopLevelCollection, type UnpackAsTopLevelPaginator } from './types.ts';
/**
 * Base class for implementing custom serializers that control how transformed
 * data is serialized and wrapped for API responses.
 *
 * Serializers provide control over:
 * - How individual items and collections are wrapped (e.g., in a "data" key)
 * - How pagination metadata is structured and transformed
 *
 * @template Wrappers - Configuration object for wrapper keys and metadata transformation
 *
 * ```typescript
 * class ApiSerializer extends BaseSerializer<{
 *   Wrap: 'data'
 *   PaginationMetaData: { page: number; totalPages: number }
 * }> {
 *   wrap = 'data' as const
 *
 *   definePaginationMetaData(metaData: any) {
 *     return {
 *       page: metaData.currentPage,
 *       totalPages: metaData.lastPage
 *     }
 *   }
 * }
 *
 * const serializer = new ApiSerializer()
 * const result = await serializer.serialize(UserTransformer.transform(user))
 * // Result: { data: { id: 1, name: "John" } }
 * ```
 */
export declare abstract class BaseSerializer<Wrappers extends {
    Wrap?: string;
    PaginationMetaData?: Record<string, any>;
} = {}> {
    #private;
    /**
     * The key name to wrap response data under. Set to undefined to disable wrapping.
     */
    abstract wrap: Wrappers['Wrap'];
    /**
     * Transforms raw pagination metadata into the desired format for API responses.
     *
     * @param metaData - The raw pagination metadata from the paginator
     */
    abstract definePaginationMetaData(metaData: unknown): Wrappers['PaginationMetaData'];
    /**
     * Type guard to check if metadata conforms to the Lucid paginator metadata structure.
     *
     * Validates that the metadata object contains all expected pagination fields
     * used by AdonisJS Lucid ORM paginators.
     *
     * @param metaData - The metadata object to check
     *
     * @example
     * ```typescript
     * const metadata = {
     *   total: '100',
     *   perPage: '10',
     *   currentPage: '1',
     *   lastPage: '10',
     *   firstPage: '1',
     *   firstPageUrl: '/users?page=1',
     *   lastPageUrl: '/users?page=10',
     *   nextPageUrl: '/users?page=2',
     *   previousPageUrl: null
     * }
     *
     * if (this.isLucidPaginatorMetaData(metadata)) {
     *   // metadata is typed as Lucid paginator metadata
     *   console.log(metadata.currentPage)
     * }
     * ```
     */
    protected isLucidPaginatorMetaData(metaData: unknown): metaData is {
        total: string;
        perPage: string;
        currentPage: string;
        lastPage: string;
        firstPage: string;
        firstPageUrl: string;
        lastPageUrl: string;
        nextPageUrl: string;
        previousPageUrl: string;
    };
    /**
     * Serializes a record of resource data types into plain JavaScript objects.
     *
     * @param data - The resource data record to serialize
     * @param container - Optional container resolver for dependency injection
     */
    serialize<Data extends Record<string, ResourceDataTypes | PaginatorContract<any, any, any>>>(data: Data, resolver?: ContainerResolver<any>): Promise<Wrappers['Wrap'] extends string ? {
        [K in Wrappers['Wrap']]: UnpackTopLevelValues<Data>;
    } : UnpackTopLevelValues<Data>>;
    /**
     * Serializes an Item resource into its plain JavaScript representation.
     *
     * @param resource - The Item resource to serialize
     * @param container - Optional container resolver for dependency injection
     */
    serialize<ResourceItem extends ItemContract<any, any, any>>(resource: ResourceItem, resolver?: ContainerResolver<any>): Promise<UnpackAsTopLevelItem<ResourceItem, Wrappers['Wrap']>>;
    /**
     * Serializes a Collection resource into an array of plain JavaScript objects.
     *
     * @param collection - The Collection resource to serialize
     * @param container - Optional container resolver for dependency injection
     */
    serialize<ResourceCollection extends CollectionContract<any, any, any>>(collection: ResourceCollection, resolver?: ContainerResolver<any>): Promise<UnpackAsTopLevelCollection<ResourceCollection, Wrappers['Wrap']>>;
    /**
     * Serializes a Paginator resource into paginated data with metadata.
     *
     * @param paginator - The Paginator resource to serialize
     * @param container - Optional container resolver for dependency injection
     */
    serialize<ResourcePaginator extends PaginatorContract<any, any, any>>(paginator: ResourcePaginator, resolver?: ContainerResolver<any>): Promise<UnpackAsTopLevelPaginator<ResourcePaginator, Wrappers['Wrap'] extends string ? Wrappers['Wrap'] : 'data', Wrappers['PaginationMetaData']>>;
    /**
     * Serializes any other value by returning it as-is wrapped in a Promise.
     *
     * @param value - The value to serialize
     * @param container - Optional container resolver for dependency injection
     */
    serialize<Value>(value: Value, resolver?: ContainerResolver<any>): Promise<Value>;
    /**
     * Serializes a record of resource data types without wrapping the output.
     */
    serializeWithoutWrapping<Data extends Record<string, ResourceDataTypes | PaginatorContract<any, any, any>>>(data: Data, resolver?: ContainerResolver<any>): Promise<UnpackTopLevelValues<Data>>;
    /**
     * Serializes an Item resource without wrapping the output.
     */
    serializeWithoutWrapping<ResourceItem extends ItemContract<any, any, any>>(resource: ResourceItem, resolver?: ContainerResolver<any>): Promise<UnpackAsTopLevelItem<ResourceItem, undefined>>;
    /**
     * Serializes a Collection resource without wrapping the output.
     */
    serializeWithoutWrapping<ResourceCollection extends CollectionContract<any, any, any>>(collection: ResourceCollection, resolver?: ContainerResolver<any>): Promise<UnpackAsTopLevelCollection<ResourceCollection, undefined>>;
    /**
     * Serializes a Paginator resource without wrapping the output.
     */
    serializeWithoutWrapping<ResourcePaginator extends PaginatorContract<any, any, any>>(paginator: ResourcePaginator, resolver?: ContainerResolver<any>): Promise<UnpackAsTopLevelPaginator<ResourcePaginator, 'data', Wrappers['PaginationMetaData']>>;
    /**
     * Serializes any other value by returning it as-is wrapped in a Promise.
     */
    serializeWithoutWrapping<Value>(value: Value, resolver?: ContainerResolver<any>): Promise<Value>;
}
