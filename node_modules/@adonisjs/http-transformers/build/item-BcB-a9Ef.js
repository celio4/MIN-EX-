import { transformAndResolve } from "./src/helpers.js";
import "node:module";
import { debuglog } from "node:util";
import diagnostics_channel from "node:diagnostics_channel";
var __defProp = Object.defineProperty;
var __exportAll = (all, no_symbols) => {
	let target = {};
	for (var name in all) __defProp(target, name, {
		get: all[name],
		enumerable: true
	});
	if (!no_symbols) __defProp(target, Symbol.toStringTag, { value: "Module" });
	return target;
};
const debug = debuglog("adonisjs:data");
var Paginator = class Paginator {
	$type = "paginator";
	constructor(collection, metaData) {
		this.collection = collection;
		this.metaData = metaData;
	}
	depth(value) {
		return new Paginator(this.collection.depth(value), this.metaData);
	}
	useVariant(value) {
		return new Paginator(this.collection.useVariant(value), this.metaData);
	}
	async resolve(container, depth, maxDepth) {
		return {
			data: await this.collection.resolve(container, depth, maxDepth),
			metadata: this.metaData
		};
	}
};
var Collection = class Collection {
	#debuggingError;
	$type = "collection";
	constructor(transformerData, transformer, maxDepth, variant, debuggingError) {
		this.transformerData = transformerData;
		this.transformer = transformer;
		this.maxDepth = maxDepth;
		this.variant = variant;
		this.#debuggingError = debuggingError;
	}
	depth(value) {
		return new Collection(this.transformerData, this.transformer, value, this.variant, this.#debuggingError);
	}
	useVariant(value) {
		return new Collection(this.transformerData, this.transformer, this.maxDepth, value, this.#debuggingError);
	}
	resolve(container, depth, maxDepth) {
		const [resources, rest] = this.transformerData;
		return Promise.all(resources.map((row) => transformAndResolve(container, new this.transformer(row, ...rest), this.variant, depth, maxDepth === -1 ? void 0 : maxDepth ?? this.maxDepth)));
	}
};
var tracing_channels_exports = /* @__PURE__ */ __exportAll({ transformerResolver: () => transformerResolver });
const transformerResolver = diagnostics_channel.tracingChannel("adonisjs.transformer.resolver");
var Item = class Item {
	#debuggingError;
	$type = "item";
	constructor(transformerData, transformer, maxDepth, variant, debuggingError) {
		this.transformerData = transformerData;
		this.transformer = transformer;
		this.maxDepth = maxDepth;
		this.variant = variant;
		this.#debuggingError = debuggingError;
	}
	depth(value) {
		return new Item(this.transformerData, this.transformer, value, this.variant, this.#debuggingError);
	}
	useVariant(value) {
		return new Item(this.transformerData, this.transformer, this.maxDepth, value, this.#debuggingError);
	}
	resolve(container, depth, maxDepth) {
		const [resource, rest] = this.transformerData;
		if (resource === void 0) {
			this.#debuggingError.message = "Cannot transform undefined value. Use \"this.whenLoaded(value)\" to allow undefined values";
			throw this.#debuggingError;
		}
		return transformAndResolve(container, new this.transformer(resource, ...rest), this.variant, depth, maxDepth === -1 ? void 0 : maxDepth ?? this.maxDepth);
	}
};
export { Paginator as a, Collection as i, tracing_channels_exports as n, debug as o, transformerResolver as r, Item as t };
