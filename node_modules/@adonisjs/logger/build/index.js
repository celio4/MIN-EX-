import { a as stdTimeFunctions, i as stdSerializers, n as destination, o as transport, r as multistream, t as Logger } from "./logger-Btq_FVdY.js";
import { RuntimeException } from "@poppinss/utils/exception";
import { debuglog } from "node:util";
function file(options, level) {
	return {
		target: "pino/file",
		level,
		options: options || {}
	};
}
var Targets = class {
	#collection = [];
	push(value) {
		this.#collection.push(value);
		return this;
	}
	pushIf(conditional, value) {
		if (conditional) this.#collection.push(typeof value === "function" ? value() : value);
		return this;
	}
	pushUnless(conditional, value) {
		if (!conditional) this.#collection.push(typeof value === "function" ? value() : value);
		return this;
	}
	toArray() {
		return this.#collection;
	}
};
function pretty(options, level) {
	return {
		target: "pino-pretty",
		level,
		options: options || {}
	};
}
function targets() {
	return new Targets();
}
targets.file = file;
targets.pretty = pretty;
const destinations = { async pretty(options) {
	const { default: pinoPretty } = await import("pino-pretty");
	return pinoPretty(options);
} };
var debug_default = debuglog("adonisjs:logger");
function defineConfig(config) {
	if (!config.loggers) throw new RuntimeException("Missing \"loggers\" property in logger config file");
	if (!config.default) throw new RuntimeException("Missing \"default\" property in logger config. Specify a default logger");
	if (!config.loggers[config.default]) throw new RuntimeException(`Missing "loggers.${String(config.default)}". It is referenced by the "default" logger`);
	Object.keys(config.loggers).forEach((loggerName) => {
		const logger = config.loggers[loggerName];
		if (logger.transport && "targets" in logger.transport) logger.transport.targets.forEach((target) => {
			if (!target.level) {
				if ("target" in target) debug_default("inherting \"%s\" target level from \"%s\" logger", target.target, loggerName);
				else debug_default("inherting %O target level from \"%s\" logger", target, loggerName);
				target.level = logger.level;
			}
		});
	});
	return config;
}
var LoggerManager = class extends Logger {
	#config;
	#loggers = /* @__PURE__ */ new Map();
	constructor(config) {
		super(config.loggers[config.default]);
		this.#config = config;
		debug_default("creating logger manager. config: %O", this.#config);
	}
	createLogger(logger, config) {
		if (!config.name && typeof logger === "string") config.name = logger;
		return new Logger(config);
	}
	use(logger) {
		let loggerToUse = logger || this.#config.default;
		if (this.#loggers.has(loggerToUse)) {
			debug_default("using logger from cache. name: \"%s\"", logger);
			return this.#loggers.get(loggerToUse);
		}
		const config = this.#config.loggers[loggerToUse];
		debug_default("creating logger. name: \"%s\", config: %O", loggerToUse, config);
		const loggerInstance = this.createLogger(loggerToUse, config);
		this.#loggers.set(loggerToUse, loggerInstance);
		return loggerInstance;
	}
	create(config, pino) {
		return new Logger(config, pino);
	}
};
export { Logger, LoggerManager, defineConfig, destination, destinations, multistream, stdSerializers, stdTimeFunctions, targets, transport };
