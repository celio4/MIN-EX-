import type { Application } from '@adonisjs/application';
import { type UnsubscribeFunction } from 'emittery';
import { type LazyImport, type Constructor } from '@poppinss/utils/types';
import { EventsBuffer } from './events_buffer.ts';
import type { Listener, EmitterLike, ListenerMethod, AllowedEventTypes, ListenerClassWithHandleMethod } from './types.ts';
/**
 * Event emitter is built on top of emittery with support class based
 * events and listeners
 */
export declare class Emitter<EventsList extends Record<string | symbol | number, any>> implements EmitterLike<EventsList> {
    #private;
    /**
     * Returns a map of events and their registered listeners. The
     * map key is the event name and the value is another map
     * of listeners.
     *
     * The listeners map key is the original binding listener
     * and the value is a callback function.
     *
     * @returns The events listeners map
     */
    get eventsListeners(): Map<AllowedEventTypes, Map<Listener<any, Constructor<any>>, ListenerMethod<any>>>;
    /**
     * Creates a new Emitter instance
     *
     * @param app - The AdonisJS application instance
     */
    constructor(app: Application<any>);
    /**
     * Register a global error handler
     *
     * @param callback - The error handler callback
     * @returns The emitter instance for method chaining
     */
    onError(callback: (event: keyof EventsList | Constructor<any>, error: any, data: any) => void): this;
    /**
     * Bind multiple listeners to listen for a single event. The listen
     * method is a convenience helper to be used with class based
     * events and listeners.
     *
     * @param event - The event class to listen for
     * @param listeners - Array of listener classes with handle methods
     */
    listen<Event extends Constructor<any>>(event: Event, listeners: (ListenerClassWithHandleMethod<InstanceType<Event>> | LazyImport<ListenerClassWithHandleMethod<InstanceType<Event>>>)[]): void;
    /**
     * Listen for an event. The method returns the unsubscribe function.
     *
     * @param event - The event to listen for
     * @param listener - The listener to register
     * @returns The unsubscribe function
     */
    on<Event extends Constructor<any>, ListenerClass extends Constructor<any>>(event: Event, listener: Listener<InstanceType<Event>, ListenerClass>): UnsubscribeFunction;
    on<Name extends keyof EventsList, ListenerClass extends Constructor<any>>(event: Name, listener: Listener<EventsList[Name], ListenerClass>): UnsubscribeFunction;
    /**
     * Listen for an event depending on a condition
     *
     * @param condition - The condition to check before listening
     * @param event - The event to listen for
     * @param listener - The listener to register
     * @returns The unsubscribe function
     */
    listenIf<Event extends Constructor<any>, ListenerClass extends Constructor<any>>(condition: boolean | (() => boolean), event: Event, listener: Listener<InstanceType<Event>, ListenerClass>): UnsubscribeFunction;
    listenIf<Name extends keyof EventsList, ListenerClass extends Constructor<any>>(condition: boolean | (() => boolean), event: Name, listener: Listener<EventsList[Name], ListenerClass>): UnsubscribeFunction;
    /**
     * Listen for an event only once
     *
     * @param event - The event to listen for
     * @param listener - The listener to register
     */
    once<Event extends Constructor<any>, ListenerClass extends Constructor<any>>(event: Event, listener: Listener<InstanceType<Event>, ListenerClass>): void;
    once<Name extends keyof EventsList, ListenerClass extends Constructor<any>>(event: Name, listener: Listener<EventsList[Name], ListenerClass>): void;
    /**
     * Attach a listener to listen for all the events. Wildcard listeners
     * can only be defined as inline callbacks.
     *
     * @param listener - The wildcard listener callback
     * @returns The unsubscribe function
     */
    onAny(listener: (event: AllowedEventTypes, data: any) => any | Promise<any>): UnsubscribeFunction;
    /**
     * Emit event. The event listeners will be called asynchronously
     * in parallel.
     *
     * You can await this method to wait for events listeners to finish
     *
     * @param event - The event to emit
     * @param data - The data to pass to listeners
     */
    emit<Event extends Constructor<any>>(event: Event, data: InstanceType<Event>): Promise<void>;
    emit<Name extends keyof EventsList>(event: Name, data: EventsList[Name]): Promise<void>;
    /**
     * Emit events serially. The event listeners will be called asynchronously
     * in the same sequence as they are registered.
     *
     * You can await this method to wait for events listeners to finish
     *
     * @param event - The event to emit
     * @param data - The data to pass to listeners
     */
    emitSerial<Event extends Constructor<any>>(event: Event, data: InstanceType<Event>): Promise<void>;
    emitSerial<Name extends keyof EventsList>(event: Name, data: EventsList[Name]): Promise<void>;
    /**
     * Remove a specific listener for an event
     *
     * @param event - The event to remove listener from
     * @param listener - The listener to remove
     */
    off(event: keyof EventsList | Constructor<any>, listener: Listener<any, Constructor<any>>): void;
    /**
     * Remove a specific listener listening for all the events
     *
     * @param listener - The wildcard listener to remove
     * @returns The emitter instance for method chaining
     */
    offAny(listener: (event: keyof EventsList | Constructor<any>, data: any) => any | Promise<any>): this;
    /**
     * Remove a specific listener for an event
     *
     * @param event - The event to remove listener from
     * @param listener - The listener to remove
     */
    clearListener(event: keyof EventsList | Constructor<any>, listener: Listener<any, Constructor<any>>): void;
    /**
     * Clear all listeners for a specific event
     *
     * @param event - The event to clear listeners for
     */
    clearListeners(event: keyof EventsList | Constructor<any>): void;
    /**
     * Clear all listeners for all the events
     */
    clearAllListeners(): void;
    /**
     * Get count of listeners for a given event or all the events
     *
     * @param event - The event to count listeners for (optional)
     * @returns The number of listeners
     */
    listenerCount(event?: keyof EventsList | Constructor<any>): number;
    /**
     * Find if an event has one or more listeners
     *
     * @param event - The event to check listeners for (optional)
     * @returns True if the event has listeners
     */
    hasListeners(event?: keyof EventsList | Constructor<any>): boolean;
    /**
     * Fake one or more events. The listeners for faked events will
     * not be invoked.
     *
     * The return value is an events buffer that collects all the
     * events within memory.
     *
     * Calling this method one than once drops the existing fakes and
     * creates new one.
     *
     * @param events - Array of events to fake (optional, defaults to all events)
     * @returns The events buffer for assertions
     */
    fake(events?: (keyof EventsList | Constructor<any>)[]): EventsBuffer<EventsList>;
    /**
     * Restore fakes
     */
    restore(): void;
}
