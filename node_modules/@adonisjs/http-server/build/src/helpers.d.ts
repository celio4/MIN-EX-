import { type Encryption } from '@boringnode/encryption';
import { type Qs } from './qs.ts';
import { createURL } from './client/helpers.ts';
import { type CookieOptions } from './types/response.ts';
import { type SignedURLOptions } from './types/url_builder.ts';
import type { RouteMatchers, RouteJSON, MatchItRouteToken } from './types/route.ts';
import { type MiddlewareFn, type RouteHandlerInfo, type MiddlewareHandlerInfo, type ParsedGlobalMiddleware, type ParsedNamedMiddleware } from './types/middleware.ts';
export { createURL };
/**
 * This function is similar to the intrinsic function encodeURI. However, it will not encode:
 *  - The \, ^, or | characters
 *  - The % character when it's part of a valid sequence
 *  - [ and ] (for IPv6 hostnames)
 *  - Replaces raw, unpaired surrogate pairs with the Unicode replacement character
 *
 * Some tests
 * encodeURI('http://localhost/%20snow.html') // http://localhost/%2520snow.html
 * encodeUrl('http://localhost/%20snow.html') // http://localhost/%20snow.html
 *
 * encodeURI('http://[::1]:8080/foo/bar') // http://%5B::1%5D:8080/foo/bar
 * encodeUrl('http://[::1]:8080/foo/bar') // http://[::1]:8080/foo/bar
 */
export { default as encodeUrl } from 'encodeurl';
/**
 * Re-exports the "https://www.npmjs.com/package/mime-types" package
 */
export { default as mime } from 'mime-types';
/**
 * Parse a route pattern into an array of tokens. These tokes can be used
 * to match routes, or print them with semantic information.
 *
 * Token types
 *
 * - 0: (static) segment
 * - 1: (parameter) segment
 * - 2: (wildcard) segment
 * - 3: (optional parameter) segment
 *
 * Value (val) refers to the segment value
 *
 * end refers to be the suffix or the segment (if any)
 *
 * @param pattern - The route pattern to parse
 * @param matchers - Optional route matchers
 * @returns {MatchItRouteToken[]} Array of parsed route tokens
 */
export declare function parseRoute(pattern: string, matchers?: RouteMatchers): MatchItRouteToken[];
/**
 * Makes signed URL for a given route pattern using its parsed tokens. The
 * tokens could be generated using the "parseRoute" method.
 *
 * @param identifier - Route identifier
 * @param tokens - Array of parsed route tokens
 * @param searchParamsStringifier - Function to stringify query parameters
 * @param encryption - Encryption instance for signing
 * @param params - Route parameters as array or object
 * @param options - Signed URL options
 * @returns {string} The generated signed URL
 */
export declare function createSignedURL(identifier: string, tokens: MatchItRouteToken[], searchParamsStringifier: (qs: Record<string, any>) => string, encryption: Encryption, params?: any[] | {
    [param: string]: any;
}, options?: SignedURLOptions): string;
/**
 * Match a given URI with an array of patterns and extract the params
 * from the URL. Null value is returned in case of no match
 *
 * @param url - The URL to match
 * @param patterns - Array of route patterns to match against
 * @returns {null | Record<string, string>} Extracted parameters or null if no match
 */
export declare function matchRoute(url: string, patterns: string[]): null | Record<string, string>;
/**
 * Serialize the value of a cookie to a string you can send via
 * set-cookie response header.
 *
 * @param key - Cookie name
 * @param value - Cookie value
 * @param options - Cookie options
 * @returns {string} Serialized cookie string
 */
export declare function serializeCookie(key: string, value: string, options?: Partial<CookieOptions>): string;
/**
 * Returns the info about a middleware handler. In case of lazy imports, the method
 * will return the import path
 *
 * @param middleware - The middleware function or parsed middleware
 * @returns {Promise<MiddlewareHandlerInfo>} Promise resolving to middleware handler information
 */
export declare function middlewareInfo(middleware: MiddlewareFn | ParsedGlobalMiddleware | ParsedNamedMiddleware): Promise<MiddlewareHandlerInfo>;
/**
 * Returns the info about a route handler. In case of lazy imports, the method
 * will return the import path.
 *
 * @param route - The route JSON object
 * @returns {Promise<RouteHandlerInfo>} Promise resolving to route handler information
 */
export declare function routeInfo(route: RouteJSON): Promise<RouteHandlerInfo>;
/**
 * Appends query string parameters to a URI. Existing query parameters
 * in the URI are merged with the new ones.
 *
 * @param uri - The base URI to append query string to
 * @param queryString - Object containing query parameters to append
 * @param qsParser - Query string parser instance for stringify/parse operations
 *
 * @example
 * ```ts
 * const result = appendQueryString('/users', { page: 1, limit: 10 }, qsParser)
 * // Returns: '/users?page=1&limit=10'
 *
 * const result2 = appendQueryString('/users?sort=name', { page: 1 }, qsParser)
 * // Returns: '/users?sort=name&page=1'
 * ```
 */
export declare function appendQueryString(uri: string, queryString: Record<string, any>, qsParser: Qs): string;
