import type { Encryption } from '@boringnode/encryption';
import type { Application } from '@adonisjs/application';
import type { Constructor, LazyImport } from '@poppinss/utils/types';
import type { Qs } from '../qs.ts';
import { Route } from './route.ts';
import { RouteGroup } from './group.ts';
import { BriskRoute } from './brisk.ts';
import { RouteResource } from './resource.ts';
import { UrlBuilder } from './legacy/url_builder.ts';
import { RouteMatchers as Matchers } from './matchers.ts';
import type { MiddlewareAsClass, ParsedGlobalMiddleware } from '../types/middleware.ts';
import type { RouteFn, RouteJSON, MatchedRoute, RouteMatcher, RouteMatchers, MakeUrlOptions, MakeSignedUrlOptions, GetControllerHandlers } from '../types/route.ts';
import { type UrlFor, type LookupList, type RoutesList, type SignedURLOptions } from '../types/url_builder.ts';
/**
 * Router class exposes a unified API to register new routes, group them or
 * create route resources.
 *
 * ```ts
 * const router = new Router()
 *
 * router.get('/', async function () {
 *   // handle request
 * })
 * ```
 */
export declare class Router {
    #private;
    /**
     * A flag to know if routes for explicit domains have been registered.
     * The boolean is computed after calling the "commit" method.
     */
    usingDomains: boolean;
    /**
     * Shortcut methods for commonly used route matchers
     */
    matchers: Matchers;
    /**
     * Check if routes have been committed to the store. Once
     * routes are committed, defining new set of routes will
     * have no impact
     */
    get commited(): boolean;
    /**
     * Query string parser for making URLs
     */
    qs: Qs;
    /**
     * The URLBuilder offers a type-safe API for creating URL for pre-registered
     * routes or the route patterns.
     *
     * We recommend using the URLBuilder over the "makeUrl" and "makeSignedUrl"
     * methods.
     */
    urlBuilder: {
        urlFor: UrlFor<RoutesList extends LookupList ? RoutesList : never>;
        signedUrlFor: UrlFor<RoutesList extends LookupList ? RoutesList : never, SignedURLOptions>;
    };
    /**
     * List of route references kept for lookup.
     */
    protected routes: {
        [domain: string]: RouteJSON[];
    };
    /**
     * Creates a new Router instance
     * @param app - The AdonisJS application instance
     * @param encryption - Encryption service for signed URLs
     * @param qsParser - Query string parser for URL generation
     */
    constructor(app: Application<any>, encryption: Encryption, qsParser: Qs);
    /**
     * Register route JSON payload
     */
    protected register(route: RouteJSON): void;
    /**
     * Parses the route pattern
     * @param pattern - The route pattern to parse
     * @param matchers - Optional route matchers
     */
    parsePattern(pattern: string, matchers?: RouteMatchers): import("../types/route.ts").MatchItRouteToken[];
    /**
     * Define an array of middleware to use on all the routes.
     * Calling this method multiple times pushes to the
     * existing list of middleware
     * @param middleware - Array of middleware classes to apply globally
     * @returns Current Router instance for method chaining
     */
    use(middleware: LazyImport<MiddlewareAsClass>[]): this;
    /**
     * Define a collection of named middleware. The defined collection is
     * not registered anywhere, but instead converted in a new collection
     * of functions you can apply on the routes, or router groups.
     * @param collection - Object mapping middleware names to middleware classes
     * @returns Named middleware functions
     */
    named<NamedMiddleware extends Record<string, LazyImport<MiddlewareAsClass>>>(collection: NamedMiddleware): { [K in keyof NamedMiddleware]: <Args extends import("../types/middleware.ts").GetMiddlewareArgs<import("@poppinss/utils/types").UnWrapLazyImport<NamedMiddleware[K]>>>(...args: Args) => {
        name: K;
        reference: LazyImport<MiddlewareAsClass> | MiddlewareAsClass;
        args: Args[0];
        handle: ParsedGlobalMiddleware["handle"];
    }; };
    /**
     * Add route for a given pattern and methods
     * @param pattern - The route pattern
     * @param methods - Array of HTTP methods
     * @param handler - Route handler (function, string, or controller tuple)
     * @returns The created route instance
     */
    route<T extends Constructor<any>>(pattern: string, methods: string[], handler: string | RouteFn | [LazyImport<T> | T, GetControllerHandlers<T>?]): Route<T>;
    /**
     * Define a route that handles all common HTTP methods
     * @param pattern - The route pattern
     * @param handler - Route handler (function, string, or controller tuple)
     * @returns The created route instance
     */
    any<T extends Constructor<any>>(pattern: string, handler: string | RouteFn | [LazyImport<T> | T, GetControllerHandlers<T>?]): Route<T>;
    /**
     * Define `GET` route
     * @param pattern - The route pattern
     * @param handler - Route handler (function, string, or controller tuple)
     * @returns The created route instance
     */
    get<T extends Constructor<any>>(pattern: string, handler: string | RouteFn | [LazyImport<T> | T, GetControllerHandlers<T>?]): Route<T>;
    /**
     * Define `POST` route
     * @param pattern - The route pattern
     * @param handler - Route handler (function, string, or controller tuple)
     * @returns The created route instance
     */
    post<T extends Constructor<any>>(pattern: string, handler: string | RouteFn | [LazyImport<T> | T, GetControllerHandlers<T>?]): Route<T>;
    /**
     * Define `PUT` route
     * @param pattern - The route pattern
     * @param handler - Route handler (function, string, or controller tuple)
     * @returns The created route instance
     */
    put<T extends Constructor<any>>(pattern: string, handler: string | RouteFn | [LazyImport<T> | T, GetControllerHandlers<T>?]): Route<T>;
    /**
     * Define `PATCH` route
     * @param pattern - The route pattern
     * @param handler - Route handler (function, string, or controller tuple)
     * @returns The created route instance
     */
    patch<T extends Constructor<any>>(pattern: string, handler: string | RouteFn | [LazyImport<T> | T, GetControllerHandlers<T>?]): Route<T>;
    /**
     * Define `DELETE` route
     * @param pattern - The route pattern
     * @param handler - Route handler (function, string, or controller tuple)
     * @returns The created route instance
     */
    delete<T extends Constructor<any>>(pattern: string, handler: string | RouteFn | [LazyImport<T> | T, GetControllerHandlers<T>?]): Route<T>;
    /**
     * Creates a group of routes. A route group can apply transforms
     * to routes in bulk
     * @param callback - Function that defines routes within the group
     * @returns The created route group instance
     */
    group(callback: () => void): RouteGroup;
    /**
     * Registers a route resource with conventional set of routes
     * @param resource - The resource name
     * @param controller - Controller to handle the resource
     * @returns The created route resource instance
     */
    resource(resource: string, controller: string | LazyImport<Constructor<any>> | Constructor<any>): RouteResource<import("../types/route.ts").ResourceActionNames>;
    /**
     * Register a route resource with shallow nested routes.
     * @param resource - The resource name
     * @param controller - Controller to handle the resource
     * @returns The created route resource instance
     */
    shallowResource(resource: string, controller: string | LazyImport<Constructor<any>> | Constructor<any>): RouteResource<import("../types/route.ts").ResourceActionNames>;
    /**
     * Returns a brisk route instance for a given URL pattern
     * @param pattern - The route pattern
     * @returns The created brisk route instance
     */
    on(pattern: string): BriskRoute;
    /**
     * Define matcher for a given param. The global params are applied
     * on all the routes (unless overridden at the route level).
     * @param param - The parameter name to match
     * @param matcher - The matcher pattern (RegExp, string, or RouteMatcher)
     * @returns Current Router instance for method chaining
     */
    where(param: string, matcher: RouteMatcher | string | RegExp): this;
    /**
     * Commit routes to the store. The router is freezed after the
     * commit method is called.
     */
    commit(): void;
    /**
     * Finds a route by its identifier. The identifier can be the
     * route name, controller.method name or the route pattern
     * itself.
     *
     * When "disableLegacyLookup" is set, the lookup will be performed
     * only using the route name
     * @param routeIdentifier - Route name, pattern, or controller reference
     * @param domain - Optional domain to search within
     * @param method - Optional HTTP method to filter by
     * @param disableLegacyLookup - Whether to disable legacy lookup strategies
     * @returns Found route or null if not found
     */
    find(routeIdentifier: string, domain?: string, method?: string, disableLegacyLookup?: boolean): RouteJSON | null;
    /**
     * Finds a route by its identifier. The identifier can be the
     * route name, controller.method name or the route pattern
     * itself.
     *
     * An error is raised when unable to find the route.
     *
     * When "disableLegacyLookup" is set, the lookup will be performed
     * only using the route name
     * @param routeIdentifier - Route name, pattern, or controller reference
     * @param domain - Optional domain to search within
     * @param method - Optional HTTP method to filter by
     * @param disableLegacyLookup - Whether to disable legacy lookup strategies
     * @returns Found route
     * @throws Error when route is not found
     */
    findOrFail(routeIdentifier: string, domain?: string, method?: string, disableLegacyLookup?: boolean): RouteJSON;
    /**
     * Check if a route exists. The identifier can be the
     * route name, controller.method name or the route pattern
     * itself.
     *
     * When "followLookupStrategy" is enabled, the lookup will be performed
     * on the basis of the lookup strategy enabled via the "lookupStrategies"
     * method. The default lookupStrategy is "name" and "pattern".
     * @param routeIdentifier - Route name, pattern, or controller reference
     * @param domain - Optional domain to search within
     * @param method - Optional HTTP method to filter by
     * @param followLookupStrategy - Whether to follow the configured lookup strategy
     * @returns True if route exists, false otherwise
     */
    has(routeIdentifier: string, domain?: string, method?: string, followLookupStrategy?: boolean): boolean;
    /**
     * Returns a list of routes grouped by their domain names
     * @returns Object mapping domain names to route arrays
     */
    toJSON(): {
        [domain: string]: RouteJSON[];
    };
    /**
     * Generates types for the URL builder. These types must
     * be written inside a file for the URL builder to
     * pick them up.
     * @param indentation - Indentation level for generated types
     * @returns Generated TypeScript types as string
     */
    generateTypes(indentation?: number): {
        imports: never[];
        types: string[];
        routes: string;
    };
    /**
     * Find route for a given URL, method and optionally domain
     * @param uri - The URI to match
     * @param method - HTTP method
     * @param shouldDecodeParam - Whether to decode parameters
     * @param hostname - Optional hostname for domain matching
     * @returns Matched route or null if no match found
     */
    match(uri: string, method: string, shouldDecodeParam: boolean, hostname?: string | null): null | MatchedRoute;
    /**
     * Create URL builder instance.
     * @deprecated Instead use "@adonisjs/core/services/url_builder" instead
     */
    builder(): UrlBuilder;
    /**
     * Create URL builder instance for a given domain.
     * @deprecated
     *
     * Instead use "@adonisjs/core/services/url_builder"
     */
    builderForDomain(domain: string): UrlBuilder;
    /**
     * Make URL to a pre-registered route
     *
     * @deprecated
     * Instead use "@adonisjs/core/services/url_builder"
     */
    makeUrl(routeIdentifier: string, params?: any[] | Record<string, any>, options?: MakeUrlOptions): string;
    /**
     * Makes a signed URL to a pre-registered route.
     *
     * @deprecated
     * Instead use "@adonisjs/core/services/url_builder"
     */
    makeSignedUrl(routeIdentifier: string, params?: any[] | Record<string, any>, options?: MakeSignedUrlOptions): string;
}
