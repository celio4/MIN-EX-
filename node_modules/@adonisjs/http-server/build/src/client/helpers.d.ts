import { type ClientRouteMatchItTokens, type ClientRouteJSON, type URLOptions } from './types.ts';
/**
 * Finds a route by its identifier across domains.
 *
 * Searches for routes by name, pattern, or controller reference. When no domain
 * is specified, searches across all domains. Supports legacy lookup strategies
 * for backwards compatibility.
 *
 * @param domainsRoutes - Object mapping domain names to route arrays
 * @param routeIdentifier - Route name, pattern, or controller reference to find
 * @param domain - Optional domain to limit search scope
 * @param method - Optional HTTP method to filter routes
 * @param disableLegacyLookup - Whether to disable pattern and controller lookup
 *
 * @example
 * ```ts
 * const route = findRoute(routes, 'users.show', 'api', 'GET')
 * const route2 = findRoute(routes, '/users/:id', undefined, 'GET')
 * ```
 */
export declare function findRoute<Route extends ClientRouteJSON>(domainsRoutes: {
    [domain: string]: Route[];
}, routeIdentifier: string, domain?: string, method?: string, disableLegacyLookup?: boolean): null | Route;
/**
 * Makes URL for a given route pattern using its parsed tokens. The
 * tokens could be generated using the "parseRoute" method.
 *
 * @param pattern - The route pattern
 * @param tokens - Array of parsed route tokens
 * @param searchParamsStringifier - Function to stringify query parameters
 * @param params - Route parameters as array or object
 * @param options - URL options
 * @returns {string} The generated URL
 */
export declare function createURL(pattern: string, tokens: Pick<ClientRouteMatchItTokens, 'val' | 'type' | 'end'>[], searchParamsStringifier: (qs: Record<string, any>) => string, params?: any[] | {
    [param: string]: any;
}, options?: URLOptions): string;
