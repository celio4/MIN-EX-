import Macroable from '@poppinss/macroable';
import type { Encryption } from '@boringnode/encryption';
import { type ServerResponse, type IncomingMessage } from 'node:http';
import type { Qs } from './qs.ts';
import { Redirect } from './redirect.ts';
import type { Router } from './router/main.ts';
import type { HttpContext } from './http_context/main.ts';
import type { CastableHeader, CookieOptions, ResponseConfig, ResponseStream } from './types/response.ts';
/**
 * The Response class provides a fluent API for constructing HTTP responses.
 *
 * It wraps Node.js ServerResponse and streamlines the process of writing
 * response body, setting headers, handling cookies, redirects, and streaming.
 *
 * @example
 * ```ts
 * response.status(200).json({ message: 'Hello World' })
 * response.redirect('/dashboard')
 * response.download('/path/to/file.pdf')
 * ```
 */
export declare class HttpResponse extends Macroable {
    #private;
    request: IncomingMessage;
    response: ServerResponse;
    /**
     * Indicates whether the response has any content (body, stream, or file) ready to be sent
     */
    get hasLazyBody(): boolean;
    /**
     * Indicates whether the response has non-stream content set
     */
    get hasContent(): boolean;
    /**
     * Indicates whether the response body is set as a readable stream
     */
    get hasStream(): boolean;
    /**
     * Indicates whether the response is configured to stream a file
     */
    get hasFileToStream(): boolean;
    /**
     * The response content data
     */
    get content(): [any, boolean, (string | undefined)?] | undefined;
    /**
     * The readable stream instance configured for the response
     */
    get outgoingStream(): ResponseStream | undefined;
    /**
     * Configuration for file streaming including path and etag generation flag
     */
    get fileToStream(): {
        path: string;
        generateEtag: boolean;
    } | undefined;
    /**
     * Lazy body container that holds response content until ready to send.
     * Contains different types of response data: content, stream, or fileToStream.
     */
    lazyBody: Partial<{
        content: [any, boolean, string?];
        stream: [ResponseStream, ((error: NodeJS.ErrnoException) => [string, number?])?];
        fileToStream: [string, boolean, ((error: NodeJS.ErrnoException) => [string, number?])?];
    }>;
    /**
     * HTTP context reference (creates circular dependency with HttpContext)
     */
    ctx?: HttpContext;
    /**
     * Creates a new Response instance
     *
     * @param request - Node.js IncomingMessage instance
     * @param response - Node.js ServerResponse instance
     * @param encryption - Encryption service for cookie handling
     * @param config - Response configuration settings
     * @param router - Router instance for URL generation
     * @param qs - Query string parser
     */
    constructor(request: IncomingMessage, response: ServerResponse, encryption: Encryption, config: ResponseConfig, router: Router, qs: Qs);
    /**
     * Indicates whether the response has been completely sent
     */
    get finished(): boolean;
    /**
     * Indicates whether response headers have been sent to the client
     */
    get headersSent(): boolean;
    /**
     * Indicates whether the response is still pending (headers and body can still be modified)
     */
    get isPending(): boolean;
    /**
     * Writes the response body with appropriate headers and content type detection
     *
     * Automatically sets:
     * - Content-Type based on content analysis
     * - Content-Length header
     * - ETag header (if enabled)
     * - Status code 204 for empty bodies
     *
     * @param content - The response content
     * @param generateEtag - Whether to generate ETag header
     * @param jsonpCallbackName - Optional JSONP callback name
     */
    protected writeBody(content: any, generateEtag: boolean, jsonpCallbackName?: string): void;
    /**
     * Streams the response body and handles error cleanup
     *
     * Manages stream lifecycle including:
     * - Error handling with custom callbacks
     * - Proper stream cleanup to prevent memory leaks
     * - Response finalization
     *
     * @param body - The readable stream to pipe
     * @param errorCallback - Optional custom error handler
     * @returns Promise that resolves when streaming is complete
     */
    protected streamBody(body: ResponseStream, errorCallback?: (error: NodeJS.ErrnoException) => [string, number?]): Promise<void>;
    /**
     * Streams a file for download with proper headers and caching support
     *
     * Sets appropriate headers:
     * - Last-Modified based on file stats
     * - Content-Type based on file extension
     * - Content-Length from file size
     * - ETag (if enabled)
     *
     * Handles HEAD requests and cache validation (304 responses).
     *
     * @param filePath - Path to the file to stream
     * @param generateEtag - Whether to generate ETag header
     * @param errorCallback - Optional custom error handler
     */
    protected streamFileForDownload(filePath: string, generateEtag: boolean, errorCallback?: (error: NodeJS.ErrnoException) => [string, number?]): Promise<void>;
    /**
     * Registers a callback to be called when the response is finished
     *
     * The callback is executed when the response has been completely sent.
     * Uses the "on-finished" package internally.
     *
     * @param callback - Function to call when response is finished
     */
    onFinish(callback: (err: Error | null, response: ServerResponse) => void): void;
    /**
     * Transfers all buffered headers to the underlying Node.js response object
     */
    relayHeaders(): void;
    /**
     * Writes the response status code and headers
     *
     * @param statusCode - Optional status code to set
     * @returns The Response instance for chaining
     */
    writeHead(statusCode?: number): this;
    /**
     * Gets the value of a response header
     *
     * @param key - Header name
     * @returns The header value
     */
    getHeader(key: string): import("node:http").OutgoingHttpHeader | undefined;
    /**
     * Gets all response headers as an object
     *
     * @returns Object containing all headers
     */
    getHeaders(): {
        [x: string]: import("node:http").OutgoingHttpHeader | undefined;
        accept?: string | string[] | undefined;
        "accept-charset"?: string | string[] | undefined;
        "accept-encoding"?: string | string[] | undefined;
        "accept-language"?: string | string[] | undefined;
        "accept-ranges"?: string | undefined;
        "access-control-allow-credentials"?: string | undefined;
        "access-control-allow-headers"?: string | undefined;
        "access-control-allow-methods"?: string | undefined;
        "access-control-allow-origin"?: string | undefined;
        "access-control-expose-headers"?: string | undefined;
        "access-control-max-age"?: string | undefined;
        "access-control-request-headers"?: string | undefined;
        "access-control-request-method"?: string | undefined;
        age?: string | undefined;
        allow?: string | undefined;
        authorization?: string | undefined;
        "cache-control"?: string | undefined;
        "cdn-cache-control"?: string | undefined;
        connection?: string | string[] | undefined;
        "content-disposition"?: string | undefined;
        "content-encoding"?: string | undefined;
        "content-language"?: string | undefined;
        "content-length"?: string | number | undefined;
        "content-location"?: string | undefined;
        "content-range"?: string | undefined;
        "content-security-policy"?: string | undefined;
        "content-security-policy-report-only"?: string | undefined;
        "content-type"?: string | undefined;
        cookie?: string | string[] | undefined;
        dav?: string | string[] | undefined;
        dnt?: string | undefined;
        date?: string | undefined;
        etag?: string | undefined;
        expect?: string | undefined;
        expires?: string | undefined;
        forwarded?: string | undefined;
        from?: string | undefined;
        host?: string | undefined;
        "if-match"?: string | undefined;
        "if-modified-since"?: string | undefined;
        "if-none-match"?: string | undefined;
        "if-range"?: string | undefined;
        "if-unmodified-since"?: string | undefined;
        "last-modified"?: string | undefined;
        link?: string | string[] | undefined;
        location?: string | undefined;
        "max-forwards"?: string | undefined;
        origin?: string | undefined;
        pragma?: string | string[] | undefined;
        "proxy-authenticate"?: string | string[] | undefined;
        "proxy-authorization"?: string | undefined;
        "public-key-pins"?: string | undefined;
        "public-key-pins-report-only"?: string | undefined;
        range?: string | undefined;
        referer?: string | undefined;
        "referrer-policy"?: string | undefined;
        refresh?: string | undefined;
        "retry-after"?: string | undefined;
        "sec-websocket-accept"?: string | undefined;
        "sec-websocket-extensions"?: string | string[] | undefined;
        "sec-websocket-key"?: string | undefined;
        "sec-websocket-protocol"?: string | string[] | undefined;
        "sec-websocket-version"?: string | undefined;
        server?: string | undefined;
        "set-cookie"?: string | string[] | undefined;
        "strict-transport-security"?: string | undefined;
        te?: string | undefined;
        trailer?: string | undefined;
        "transfer-encoding"?: string | undefined;
        "user-agent"?: string | undefined;
        upgrade?: string | undefined;
        "upgrade-insecure-requests"?: string | undefined;
        vary?: string | undefined;
        via?: string | string[] | undefined;
        warning?: string | undefined;
        "www-authenticate"?: string | string[] | undefined;
        "x-content-type-options"?: string | undefined;
        "x-dns-prefetch-control"?: string | undefined;
        "x-frame-options"?: string | undefined;
        "x-xss-protection"?: string | undefined;
    };
    /**
     * Sets a response header (replaces existing value)
     *
     * @param key - Header name
     * @param value - Header value (ignored if null/undefined)
     * @returns The Response instance for chaining
     *
     * @example
     * ```ts
     * response.header('Content-Type', 'application/json')
     * ```
     */
    header(key: string, value: CastableHeader): this;
    /**
     * Appends a value to an existing response header
     *
     * @param key - Header name
     * @param value - Header value to append (ignored if null/undefined)
     * @returns The Response instance for chaining
     *
     * @example
     * ```ts
     * response.append('Set-Cookie', 'session=abc123')
     * ```
     */
    append(key: string, value: CastableHeader): this;
    /**
     * Sets a header only if it doesn't already exist
     *
     * @param key - Header name
     * @param value - Header value
     * @returns The Response instance for chaining
     */
    safeHeader(key: string, value: CastableHeader): this;
    /**
     * Removes a response header
     *
     * @param key - Header name to remove
     * @returns The Response instance for chaining
     */
    removeHeader(key: string): this;
    /**
     * Gets the current response status code
     *
     * @returns The HTTP status code
     */
    getStatus(): number;
    /**
     * Sets the response status code
     *
     * @param code - HTTP status code
     * @returns The Response instance for chaining
     */
    status(code: number): this;
    /**
     * Sets the status code only if not explicitly set already
     *
     * @param code - HTTP status code
     * @returns The Response instance for chaining
     */
    safeStatus(code: number): this;
    /**
     * Sets the Content-Type header based on mime type lookup
     *
     * @param type - File extension or mime type
     * @param charset - Optional character encoding
     * @returns The Response instance for chaining
     *
     * @example
     * ```ts
     * response.type('.json') // Content-Type: application/json
     * response.type('html', 'utf-8') // Content-Type: text/html; charset=utf-8
     * ```
     */
    type(type: string, charset?: string): this;
    /**
     * Sets the Vary HTTP header for cache control
     *
     * @param field - Header field name(s) to vary on
     * @returns The Response instance for chaining
     */
    vary(field: string | string[]): this;
    /**
     * Sets the ETag header by computing a hash from the response body
     *
     * @param body - The response body to hash
     * @param weak - Whether to generate a weak ETag
     * @returns The Response instance for chaining
     */
    setEtag(body: any, weak?: boolean): this;
    /**
     * Sets the X-Request-Id header by copying from the incoming request
     *
     * @returns The Response instance for chaining
     */
    setRequestId(): this;
    /**
     * Checks if the response is fresh (client cache is valid)
     *
     * Compares ETags and modified dates between request and response
     * to determine if a 304 Not Modified response should be sent.
     *
     * @returns True if client cache is fresh, false otherwise
     *
     * @example
     * ```ts
     * response.setEtag(content)
     * if (response.fresh()) {
     *   response.status(304).send(null)
     * } else {
     *   response.send(content)
     * }
     * ```
     */
    fresh(): boolean;
    /**
     * Gets the response body content
     *
     * @returns The response body or null if not set or is a stream
     */
    getBody(): any;
    /**
     * Sends the response body with optional ETag generation
     *
     * @param body - The response body
     * @param generateEtag - Whether to generate ETag header (defaults to config)
     */
    send(body: any, generateEtag?: boolean): void;
    /**
     * Sends a JSON response (alias for send)
     *
     * @param body - The response body to serialize as JSON
     * @param generateEtag - Whether to generate ETag header
     */
    json(body: any, generateEtag?: boolean): void;
    /**
     * Sends a JSONP response with callback wrapping
     *
     * Callback name resolution priority:
     * 1. Explicit callbackName parameter
     * 2. Query string parameter
     * 3. Config value
     * 4. Default "callback"
     *
     * @param body - The response body
     * @param callbackName - JSONP callback function name
     * @param generateEtag - Whether to generate ETag header
     */
    jsonp(body: any, callbackName?: string, generateEtag?: boolean): void;
    /**
     * Pipes a readable stream to the response with graceful error handling
     *
     * @param body - The readable stream to pipe
     * @param errorCallback - Optional custom error handler
     *
     * @example
     * ```ts
     * // Auto error handling
     * response.stream(fs.createReadStream('file.txt'))
     *
     * // Custom error handling
     * response.stream(stream, (error) => {
     *   return error.code === 'ENOENT' ? ['Not found', 404] : ['Error', 500]
     * })
     * ```
     */
    stream(body: ResponseStream, errorCallback?: (error: NodeJS.ErrnoException) => [string, number?]): void;
    /**
     * Downloads a file by streaming it with appropriate headers
     *
     * Automatically sets:
     * - Content-Type from file extension
     * - Content-Length from file size
     * - Last-Modified from file stats
     * - ETag (if enabled)
     *
     * @param filePath - Path to the file to download
     * @param generateEtag - Whether to generate ETag header
     * @param errorCallback - Optional custom error handler
     *
     * @example
     * ```ts
     * response.download('/path/to/file.pdf')
     * response.download('/images/photo.jpg', true, (err) => ['Custom error', 500])
     * ```
     */
    download(filePath: string, generateEtag?: boolean, errorCallback?: (error: NodeJS.ErrnoException) => [string, number?]): void;
    /**
     * Forces file download by setting Content-Disposition header
     *
     * @param filePath - Path to the file to download
     * @param name - Optional filename for download (defaults to original filename)
     * @param disposition - Content-Disposition type (defaults to 'attachment')
     * @param generateEtag - Whether to generate ETag header
     * @param errorCallback - Optional custom error handler
     */
    attachment(filePath: string, name?: string, disposition?: string, generateEtag?: boolean, errorCallback?: (error: NodeJS.ErrnoException) => [string, number?]): void;
    /**
     * Sets the Location header for redirects
     *
     * @param url - The URL to redirect to
     * @returns The Response instance for chaining
     *
     * @example
     * ```ts
     * response.location('/dashboard')
     * ```
     */
    location(url: string): this;
    /**
     * Returns a Redirect instance for fluent API usage
     *
     * Use this overload when you want to use methods like `.toRoute()`, `.back()`,
     * `.withQs()`, or other redirect builder methods.
     *
     * @returns Redirect instance for chaining redirect methods
     *
     * @example
     * ```ts
     * response.redirect().toRoute('users.show', { id: 1 })
     * response.redirect().back()
     * response.redirect().withQs().toPath('/dashboard')
     * ```
     */
    redirect(): Redirect;
    /**
     * Performs an immediate redirect to the specified path
     *
     * This overload directly redirects the request with the provided parameters.
     * Use this when you have a simple redirect without needing the fluent API.
     *
     * @param path - The path or URL to redirect to (use 'back' for referrer redirect)
     * @param forwardQueryString - Whether to forward current query string parameters
     * @param statusCode - HTTP status code for redirect (defaults to 302 Found)
     *
     * @example
     * ```ts
     * response.redirect('/dashboard')
     * response.redirect('/users', true, 301) // with query forwarding and 301 status
     * response.redirect('back') // redirect to referrer
     * ```
     */
    redirect(path: string, forwardQueryString?: boolean, statusCode?: number): void;
    /**
     * Aborts the request with a custom response body and status code
     *
     * @param body - Response body for the aborted request
     * @param status - HTTP status code (defaults to 400)
     * @throws Always throws an HTTP exception
     */
    abort(body: any, status?: number): never;
    /**
     * Conditionally aborts the request if the condition is truthy
     *
     * @param condition - Condition to evaluate
     * @param body - Response body for the aborted request
     * @param status - HTTP status code (defaults to 400)
     */
    abortIf(condition: unknown, body: any, status?: number): asserts condition is undefined | null | false;
    /**
     * Conditionally aborts the request if the condition is falsy
     *
     * @param condition - Condition to evaluate
     * @param body - Response body for the aborted request
     * @param status - HTTP status code (defaults to 400)
     */
    abortUnless<T>(condition: T, body: any, status?: number): asserts condition is Exclude<T, undefined | null | false>;
    /**
     * Sets a signed cookie in the response
     *
     * @param key - Cookie name
     * @param value - Cookie value
     * @param options - Cookie options (overrides config defaults)
     * @returns The Response instance for chaining
     */
    cookie(key: string, value: any, options?: Partial<CookieOptions>): this;
    /**
     * Sets an encrypted cookie in the response
     *
     * @param key - Cookie name
     * @param value - Cookie value
     * @param options - Cookie options (overrides config defaults)
     * @returns The Response instance for chaining
     */
    encryptedCookie(key: string, value: any, options?: Partial<CookieOptions>): this;
    /**
     * Sets a plain (unsigned/unencrypted) cookie in the response
     *
     * @param key - Cookie name
     * @param value - Cookie value
     * @param options - Cookie options including encode flag
     * @returns The Response instance for chaining
     */
    plainCookie(key: string, value: any, options?: Partial<CookieOptions & {
        encode: boolean;
    }>): this;
    /**
     * Clears an existing cookie by setting it to expire
     *
     * @param key - Cookie name to clear
     * @param options - Cookie options (should match original cookie options)
     * @returns The Response instance for chaining
     */
    clearCookie(key: string, options?: Partial<CookieOptions>): this;
    /**
     * Finalizes and sends the response
     *
     * Writes the buffered body (content, stream, or file) to the client.
     * This method is idempotent - calling it multiple times has no effect.
     */
    finish(): void;
    /**
     * Sends a 100 Continue response
     */
    continue(): void;
    /**
     * Sends a 101 Switching Protocols response
     */
    switchingProtocols(): void;
    /**
     * Sends a 200 OK response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    ok(body: any, generateEtag?: boolean): void;
    /**
     * Sends a 201 Created response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    created(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 202 Accepted response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    accepted(body: any, generateEtag?: boolean): void;
    /**
     * Sends a 203 Non-Authoritative Information response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    nonAuthoritativeInformation(body: any, generateEtag?: boolean): void;
    /**
     * Sends a 204 No Content response
     */
    noContent(): void;
    /**
     * Sends a 205 Reset Content response
     */
    resetContent(): void;
    /**
     * Sends a 206 Partial Content response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    partialContent(body: any, generateEtag?: boolean): void;
    /**
     * Sends a 300 Multiple Choices response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    multipleChoices(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 301 Moved Permanently response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    movedPermanently(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 302 Found (Moved Temporarily) response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    movedTemporarily(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 303 See Other response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    seeOther(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 304 Not Modified response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    notModified(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 305 Use Proxy response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    useProxy(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 307 Temporary Redirect response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    temporaryRedirect(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 400 Bad Request response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    badRequest(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 401 Unauthorized response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    unauthorized(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 402 Payment Required response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    paymentRequired(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 403 Forbidden response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    forbidden(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 404 Not Found response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    notFound(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 405 Method Not Allowed response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    methodNotAllowed(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 406 Not Acceptable response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    notAcceptable(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 407 Proxy Authentication Required response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    proxyAuthenticationRequired(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 408 Request Timeout response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    requestTimeout(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 409 Conflict response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    conflict(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 410 Gone response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    gone(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 411 Length Required response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    lengthRequired(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 412 Precondition Failed response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    preconditionFailed(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 413 Payload Too Large response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    requestEntityTooLarge(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 414 URI Too Long response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    requestUriTooLong(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 415 Unsupported Media Type response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    unsupportedMediaType(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 416 Range Not Satisfiable response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    requestedRangeNotSatisfiable(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 417 Expectation Failed response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    expectationFailed(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 422 Unprocessable Entity response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    unprocessableEntity(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 429 Too Many Requests response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    tooManyRequests(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 500 Internal Server Error response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    internalServerError(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 501 Not Implemented response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    notImplemented(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 502 Bad Gateway response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    badGateway(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 503 Service Unavailable response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    serviceUnavailable(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 504 Gateway Timeout response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    gatewayTimeout(body?: any, generateEtag?: boolean): void;
    /**
     * Sends a 505 HTTP Version Not Supported response
     *
     * @param body - Response body
     * @param generateEtag - Whether to generate ETag header
     */
    httpVersionNotSupported(body?: any, generateEtag?: boolean): void;
}
