import { n as safeDecodeURI } from "../utils-BjSHKI3s.js";
import { t as createURL } from "../helpers-C_2HouOe.js";
import { serialize } from "cookie-es";
import matchit from "@poppinss/matchit";
import string from "@poppinss/utils/string";
import { parseBindingReference } from "@adonisjs/fold";
import encodeUrl from "encodeurl";
import mime from "mime-types";
function parseRoute(pattern, matchers) {
	return matchit.parse(pattern, matchers);
}
function createSignedURL(identifier, tokens, searchParamsStringifier, encryption, params, options) {
	const signature = encryption.getMessageVerifier().sign(createURL(identifier, tokens, searchParamsStringifier, params, {
		...options,
		prefixUrl: void 0
	}), options?.expiresIn, options?.purpose);
	return createURL(identifier, tokens, searchParamsStringifier, params, {
		...options,
		qs: {
			...options?.qs,
			signature
		}
	});
}
function matchRoute(url, patterns) {
	const tokensBucket = patterns.map((pattern) => parseRoute(pattern));
	const match = matchit.match(url, tokensBucket);
	if (!match.length) return null;
	return matchit.exec(url, match);
}
function serializeCookie(key, value, options) {
	let expires;
	let maxAge;
	if (options) {
		expires = typeof options.expires === "function" ? options.expires() : options.expires;
		maxAge = options.maxAge ? string.seconds.parse(options.maxAge) : void 0;
	}
	return serialize(key, value, {
		...options,
		maxAge,
		expires
	});
}
async function middlewareInfo(middleware) {
	if (typeof middleware === "function") return {
		type: "closure",
		name: middleware.name || "closure"
	};
	if ("args" in middleware) return {
		type: "named",
		name: middleware.name,
		args: middleware.args,
		...await parseBindingReference([middleware.reference])
	};
	return {
		type: "global",
		name: middleware.name,
		...await parseBindingReference([middleware.reference])
	};
}
async function routeInfo(route) {
	return "reference" in route.handler ? {
		type: "controller",
		...await parseBindingReference(route.handler.reference)
	} : {
		type: "closure",
		name: route.handler.name || "closure",
		args: "listArgs" in route.handler ? String(route.handler.listArgs) : void 0
	};
}
function appendQueryString(uri, queryString, qsParser) {
	const { query, pathname } = safeDecodeURI(uri, false);
	const mergedQueryString = qsParser.stringify(Object.assign(qsParser.parse(query), queryString));
	return mergedQueryString ? `${pathname}?${mergedQueryString}` : pathname;
}
export { appendQueryString, createSignedURL, createURL, encodeUrl, matchRoute, middlewareInfo, mime, parseRoute, routeInfo, serializeCookie };
