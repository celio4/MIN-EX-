import { a as RouteGroup, c as Route, m as canWriteResponseBody, o as RouteResource, p as tracing_channels_exports, s as BriskRoute, t as parseRange } from "./utils-BjSHKI3s.js";
import { _ as Qs, a as CookieSerializer, c as HttpRequest, d as Redirect, f as E_CANNOT_LOOKUP_ROUTE, g as errors_exports, h as E_ROUTE_NOT_FOUND, i as HttpResponse, l as CookieParser, m as E_HTTP_REQUEST_ABORTED, n as Server, o as ResponseStatus, p as E_HTTP_EXCEPTION, r as HttpContext, s as Router, t as defineConfig, u as CookieClient } from "./define_config-D-kQXU0e.js";
import "./helpers-C_2HouOe.js";
import "./types-AUwURgIL.js";
import Macroable from "@poppinss/macroable";
import is from "@sindresorhus/is";
var ExceptionHandler = class extends Macroable {
	#expandedStatusPages;
	debug = process.env.NODE_ENV !== "production";
	renderStatusPages = process.env.NODE_ENV === "production";
	statusPages = {};
	reportErrors = true;
	ignoreExceptions = [
		E_HTTP_EXCEPTION,
		E_ROUTE_NOT_FOUND,
		E_CANNOT_LOOKUP_ROUTE,
		E_HTTP_REQUEST_ABORTED
	];
	ignoreStatuses = [
		400,
		422,
		401
	];
	ignoreCodes = [];
	#expandStatusPages() {
		if (!this.#expandedStatusPages) this.#expandedStatusPages = Object.keys(this.statusPages).reduce((result, range) => {
			const renderer = this.statusPages[range];
			result = Object.assign(result, parseRange(range, renderer));
			return result;
		}, {});
		return this.#expandedStatusPages;
	}
	toHttpError(error) {
		const httpError = is.object(error) ? error : new Error(String(error));
		if (!httpError.message) httpError.message = "Internal server error";
		if (!httpError.status) httpError.status = 500;
		return httpError;
	}
	context(ctx) {
		const requestId = ctx.request.id();
		return requestId ? { "x-request-id": requestId } : {};
	}
	getErrorLogLevel(error) {
		if (error.status >= 500) return "error";
		if (error.status >= 400) return "warn";
		return "info";
	}
	isDebuggingEnabled(_) {
		return this.debug;
	}
	shouldReport(error) {
		if (this.reportErrors === false) return false;
		if (this.ignoreStatuses.includes(error.status)) return false;
		if (error.code && this.ignoreCodes.includes(error.code)) return false;
		if (this.ignoreExceptions.find((exception) => error instanceof exception)) return false;
		return true;
	}
	async renderErrorAsJSON(error, ctx) {
		if (this.isDebuggingEnabled(ctx)) {
			const { Youch } = await import("youch");
			const json = await new Youch().toJSON(error);
			ctx.response.status(error.status).send(json);
			return;
		}
		ctx.response.status(error.status).send({ message: error.message });
	}
	async renderErrorAsJSONAPI(error, ctx) {
		if (this.isDebuggingEnabled(ctx)) {
			const { Youch } = await import("youch");
			const json = await new Youch().toJSON(error);
			ctx.response.status(error.status).send(json);
			return;
		}
		ctx.response.status(error.status).send({ errors: [{
			title: error.message,
			code: error.code,
			status: error.status
		}] });
	}
	async renderErrorAsHTML(error, ctx) {
		const statusPages = this.#expandStatusPages();
		if (this.renderStatusPages && statusPages[error.status]) {
			const statusPageResponse = await statusPages[error.status](error, ctx);
			if (canWriteResponseBody(statusPageResponse, ctx)) return ctx.response.safeStatus(error.status).send(statusPageResponse);
			return statusPageResponse;
		}
		if (this.isDebuggingEnabled(ctx)) {
			const { Youch } = await import("youch");
			const html = await new Youch().toHTML(error, {
				request: ctx.request.request,
				cspNonce: "nonce" in ctx.response ? ctx.response.nonce : void 0
			});
			ctx.response.status(error.status).send(html);
			return;
		}
		ctx.response.status(error.status).send(`<p> ${error.message} </p>`);
	}
	async renderValidationErrorAsJSON(error, ctx) {
		ctx.response.status(error.status).send({ errors: error.messages });
	}
	async renderValidationErrorAsJSONAPI(error, ctx) {
		ctx.response.status(error.status).send({ errors: error.messages.map((message) => {
			return {
				title: message.message,
				code: message.rule,
				source: { pointer: message.field },
				meta: message.meta
			};
		}) });
	}
	async renderValidationErrorAsHTML(error, ctx) {
		ctx.response.status(error.status).type("html").send(error.messages.map((message) => {
			return `${message.field} - ${message.message}`;
		}).join("<br />"));
	}
	renderError(error, ctx) {
		switch (ctx.request.accepts([
			"html",
			"application/vnd.api+json",
			"json"
		])) {
			case "application/vnd.api+json": return this.renderErrorAsJSONAPI(error, ctx);
			case "json": return this.renderErrorAsJSON(error, ctx);
			default: return this.renderErrorAsHTML(error, ctx);
		}
	}
	renderValidationError(error, ctx) {
		switch (ctx.request.accepts([
			"html",
			"application/vnd.api+json",
			"json"
		])) {
			case "application/vnd.api+json": return this.renderValidationErrorAsJSONAPI(error, ctx);
			case "json": return this.renderValidationErrorAsJSON(error, ctx);
			default: return this.renderValidationErrorAsHTML(error, ctx);
		}
	}
	async report(error, ctx) {
		const httpError = this.toHttpError(error);
		if (!this.shouldReport(httpError)) return;
		if (typeof httpError.report === "function") {
			httpError.report(httpError, ctx);
			return;
		}
		const level = this.getErrorLogLevel(httpError);
		ctx.logger.log(level, {
			...level === "error" || level === "fatal" ? { err: httpError } : {},
			...this.context(ctx)
		}, httpError.message);
	}
	async handle(error, ctx) {
		const httpError = this.toHttpError(error);
		if (typeof httpError.handle === "function") return httpError.handle(httpError, ctx);
		if (httpError.code === "E_VALIDATION_ERROR" && "messages" in httpError) return this.renderValidationError(httpError, ctx);
		return this.renderError(httpError, ctx);
	}
};
export { BriskRoute, CookieClient, CookieParser, CookieSerializer, ExceptionHandler, HttpContext, HttpRequest, HttpResponse, Qs, Redirect, ResponseStatus, Route, RouteGroup, RouteResource, Router, Server, defineConfig, errors_exports as errors, tracing_channels_exports as tracingChannels };
