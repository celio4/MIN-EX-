import { _ as __exportAll, a as RouteGroup, c as Route, d as httpRequest, f as httpResponseSerializer, g as __commonJSMin, h as debug_default, i as trustProxy, l as httpExceptionHandler, n as safeDecodeURI, o as RouteResource, r as toRoutesJSON, s as BriskRoute, u as httpMiddleware, v as __require, y as __toESM } from "./utils-BjSHKI3s.js";
import { n as findRoute, t as createURL } from "./helpers-C_2HouOe.js";
import { createSignedURL, encodeUrl, mime as mime$1, parseRoute, serializeCookie } from "./src/helpers.js";
import { createUrlBuilder } from "./src/client/url_builder.js";
import { parse, stringify } from "@poppinss/qs";
import { Exception, RuntimeException, createError } from "@poppinss/utils/exception";
import { inspect } from "node:util";
import { parse as parse$1 } from "cookie-es";
import matchit from "@poppinss/matchit";
import string from "@poppinss/utils/string";
import { moduleCaller, moduleImporter } from "@adonisjs/fold";
import Macroable from "@poppinss/macroable";
import is from "@sindresorhus/is";
import Middleware from "@poppinss/middleware";
import onFinished from "on-finished";
import fresh from "fresh";
import typeIs from "type-is";
import { isIP } from "node:net";
import proxyAddr from "proxy-addr";
import { MessageBuilder, safeEqual } from "@poppinss/utils";
import lodash from "@poppinss/utils/lodash";
import base64 from "@poppinss/utils/base64";
import etag from "etag";
import vary from "vary";
import destroy from "destroy";
import { extname } from "node:path";
import { Buffer } from "node:buffer";
import { stat } from "node:fs/promises";
import { createReadStream } from "node:fs";
import contentDisposition from "content-disposition";
import { Readable } from "node:stream";
import { AsyncLocalStorage } from "node:async_hooks";
import { safeStringify } from "@poppinss/utils/json";
var Qs = class {
	#config;
	constructor(config) {
		this.#config = config;
	}
	parse = (value) => {
		return parse(value, this.#config.parse);
	};
	stringify = (value) => {
		return stringify(value, this.#config.stringify);
	};
};
var errors_exports = /* @__PURE__ */ __exportAll({
	E_CANNOT_LOOKUP_ROUTE: () => E_CANNOT_LOOKUP_ROUTE,
	E_HTTP_EXCEPTION: () => E_HTTP_EXCEPTION,
	E_HTTP_REQUEST_ABORTED: () => E_HTTP_REQUEST_ABORTED,
	E_ROUTE_NOT_FOUND: () => E_ROUTE_NOT_FOUND
});
const E_ROUTE_NOT_FOUND = createError("Cannot %s:%s", "E_ROUTE_NOT_FOUND", 404);
const E_CANNOT_LOOKUP_ROUTE = createError("Cannot lookup route \"%s\"", "E_CANNOT_LOOKUP_ROUTE", 500);
const E_HTTP_EXCEPTION = class HttpException extends Exception {
	body;
	static code = "E_HTTP_EXCEPTION";
	static invoke(body, status, code = "E_HTTP_EXCEPTION") {
		if (body === null || body === void 0) {
			const error = new this("HTTP Exception", {
				status,
				code
			});
			error.body = "Internal server error";
			return error;
		}
		if (typeof body === "object") {
			const error = new this(body.message || "HTTP Exception", {
				status,
				code
			});
			error.body = body;
			return error;
		}
		const error = new this(body, {
			status,
			code
		});
		error.body = body;
		return error;
	}
};
const E_HTTP_REQUEST_ABORTED = class AbortException extends E_HTTP_EXCEPTION {
	handle(error, ctx) {
		ctx.response.status(error.status).send(error.body);
	}
};
var Redirect = class {
	#forwardQueryString = false;
	#statusCode = 302;
	#queryString = {};
	#request;
	#response;
	#router;
	#qs;
	constructor(request, response, router, qs) {
		this.#request = request;
		this.#response = response;
		this.#router = router;
		this.#qs = qs;
	}
	#sendResponse(url, query) {
		const stringified = this.#qs.stringify(query);
		url = stringified ? `${url}?${stringified}` : url;
		debug_default("redirecting to url \"%s\"", url);
		this.#response.location(encodeUrl(url));
		this.#response.safeStatus(this.#statusCode);
		this.#response.type("text/plain; charset=utf-8");
		this.#response.send(`Redirecting to ${url}`);
	}
	#getReferrerUrl() {
		let url = this.#request.headers["referer"] || this.#request.headers["referrer"] || "/";
		return Array.isArray(url) ? url[0] : url;
	}
	status(statusCode) {
		this.#statusCode = statusCode;
		return this;
	}
	clearQs() {
		this.#forwardQueryString = false;
		this.#queryString = {};
		return this;
	}
	withQs(name, value) {
		if (typeof name === "undefined") {
			this.#forwardQueryString = true;
			return this;
		}
		if (typeof name === "string") {
			this.#queryString[name] = value;
			return this;
		}
		Object.assign(this.#queryString, name);
		return this;
	}
	back() {
		let query = {};
		const referrerUrl = this.#getReferrerUrl();
		const url = safeDecodeURI(referrerUrl, false);
		debug_default("referrer url \"%s\"", referrerUrl);
		debug_default("referrer base url \"%s\"", url.pathname);
		if (this.#forwardQueryString) query = this.#qs.parse(url.query || "");
		Object.assign(query, this.#queryString);
		this.#sendResponse(url.pathname || "", query);
	}
	toRoute(...args) {
		const [identifier, params, options] = args;
		if (options && options.qs) {
			this.withQs(options.qs);
			options.qs = void 0;
		}
		const url = this.#router.urlBuilder.urlFor(identifier, params, options);
		return this.toPath(url);
	}
	toPath(url) {
		let query = {};
		if (this.#forwardQueryString) query = this.#qs.parse(safeDecodeURI(this.#request.url, false).query || "");
		Object.assign(query, this.#queryString);
		this.#sendResponse(url, query);
	}
};
var require_charset = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = preferredCharsets;
	module.exports.preferredCharsets = preferredCharsets;
	var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
	function parseAcceptCharset(accept) {
		var accepts = accept.split(",");
		for (var i = 0, j = 0; i < accepts.length; i++) {
			var charset = parseCharset(accepts[i].trim(), i);
			if (charset) accepts[j++] = charset;
		}
		accepts.length = j;
		return accepts;
	}
	function parseCharset(str, i) {
		var match = simpleCharsetRegExp.exec(str);
		if (!match) return null;
		var charset = match[1];
		var q = 1;
		if (match[2]) {
			var params = match[2].split(";");
			for (var j = 0; j < params.length; j++) {
				var p = params[j].trim().split("=");
				if (p[0] === "q") {
					q = parseFloat(p[1]);
					break;
				}
			}
		}
		return {
			charset,
			q,
			i
		};
	}
	function getCharsetPriority(charset, accepted, index) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i = 0; i < accepted.length; i++) {
			var spec = specify(charset, accepted[i], index);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	function specify(charset, spec, index) {
		var s = 0;
		if (spec.charset.toLowerCase() === charset.toLowerCase()) s |= 1;
		else if (spec.charset !== "*") return null;
		return {
			i: index,
			o: spec.i,
			q: spec.q,
			s
		};
	}
	function preferredCharsets(accept, provided) {
		var accepts = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
		if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
		var priorities = provided.map(function getPriority(type, index) {
			return getCharsetPriority(type, accepts, index);
		});
		return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	function getFullCharset(spec) {
		return spec.charset;
	}
	function isQuality(spec) {
		return spec.q > 0;
	}
}));
var require_encoding = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = preferredEncodings;
	module.exports.preferredEncodings = preferredEncodings;
	var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
	function parseAcceptEncoding(accept) {
		var accepts = accept.split(",");
		var hasIdentity = false;
		var minQuality = 1;
		for (var i = 0, j = 0; i < accepts.length; i++) {
			var encoding = parseEncoding(accepts[i].trim(), i);
			if (encoding) {
				accepts[j++] = encoding;
				hasIdentity = hasIdentity || specify("identity", encoding);
				minQuality = Math.min(minQuality, encoding.q || 1);
			}
		}
		if (!hasIdentity) accepts[j++] = {
			encoding: "identity",
			q: minQuality,
			i
		};
		accepts.length = j;
		return accepts;
	}
	function parseEncoding(str, i) {
		var match = simpleEncodingRegExp.exec(str);
		if (!match) return null;
		var encoding = match[1];
		var q = 1;
		if (match[2]) {
			var params = match[2].split(";");
			for (var j = 0; j < params.length; j++) {
				var p = params[j].trim().split("=");
				if (p[0] === "q") {
					q = parseFloat(p[1]);
					break;
				}
			}
		}
		return {
			encoding,
			q,
			i
		};
	}
	function getEncodingPriority(encoding, accepted, index) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i = 0; i < accepted.length; i++) {
			var spec = specify(encoding, accepted[i], index);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	function specify(encoding, spec, index) {
		var s = 0;
		if (spec.encoding.toLowerCase() === encoding.toLowerCase()) s |= 1;
		else if (spec.encoding !== "*") return null;
		return {
			i: index,
			o: spec.i,
			q: spec.q,
			s
		};
	}
	function preferredEncodings(accept, provided) {
		var accepts = parseAcceptEncoding(accept || "");
		if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
		var priorities = provided.map(function getPriority(type, index) {
			return getEncodingPriority(type, accepts, index);
		});
		return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	function getFullEncoding(spec) {
		return spec.encoding;
	}
	function isQuality(spec) {
		return spec.q > 0;
	}
}));
var require_language = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = preferredLanguages;
	module.exports.preferredLanguages = preferredLanguages;
	var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
	function parseAcceptLanguage(accept) {
		var accepts = accept.split(",");
		for (var i = 0, j = 0; i < accepts.length; i++) {
			var language = parseLanguage(accepts[i].trim(), i);
			if (language) accepts[j++] = language;
		}
		accepts.length = j;
		return accepts;
	}
	function parseLanguage(str, i) {
		var match = simpleLanguageRegExp.exec(str);
		if (!match) return null;
		var prefix = match[1];
		var suffix = match[2];
		var full = prefix;
		if (suffix) full += "-" + suffix;
		var q = 1;
		if (match[3]) {
			var params = match[3].split(";");
			for (var j = 0; j < params.length; j++) {
				var p = params[j].split("=");
				if (p[0] === "q") q = parseFloat(p[1]);
			}
		}
		return {
			prefix,
			suffix,
			q,
			i,
			full
		};
	}
	function getLanguagePriority(language, accepted, index) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i = 0; i < accepted.length; i++) {
			var spec = specify(language, accepted[i], index);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	function specify(language, spec, index) {
		var p = parseLanguage(language);
		if (!p) return null;
		var s = 0;
		if (spec.full.toLowerCase() === p.full.toLowerCase()) s |= 4;
		else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) s |= 2;
		else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) s |= 1;
		else if (spec.full !== "*") return null;
		return {
			i: index,
			o: spec.i,
			q: spec.q,
			s
		};
	}
	function preferredLanguages(accept, provided) {
		var accepts = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
		if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
		var priorities = provided.map(function getPriority(type, index) {
			return getLanguagePriority(type, accepts, index);
		});
		return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	function getFullLanguage(spec) {
		return spec.full;
	}
	function isQuality(spec) {
		return spec.q > 0;
	}
}));
var require_mediaType = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = preferredMediaTypes;
	module.exports.preferredMediaTypes = preferredMediaTypes;
	var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
	function parseAccept(accept) {
		var accepts = splitMediaTypes(accept);
		for (var i = 0, j = 0; i < accepts.length; i++) {
			var mediaType = parseMediaType(accepts[i].trim(), i);
			if (mediaType) accepts[j++] = mediaType;
		}
		accepts.length = j;
		return accepts;
	}
	function parseMediaType(str, i) {
		var match = simpleMediaTypeRegExp.exec(str);
		if (!match) return null;
		var params = Object.create(null);
		var q = 1;
		var subtype = match[2];
		var type = match[1];
		if (match[3]) {
			var kvps = splitParameters(match[3]).map(splitKeyValuePair);
			for (var j = 0; j < kvps.length; j++) {
				var pair = kvps[j];
				var key = pair[0].toLowerCase();
				var val = pair[1];
				var value = val && val[0] === "\"" && val[val.length - 1] === "\"" ? val.substr(1, val.length - 2) : val;
				if (key === "q") {
					q = parseFloat(value);
					break;
				}
				params[key] = value;
			}
		}
		return {
			type,
			subtype,
			params,
			q,
			i
		};
	}
	function getMediaTypePriority(type, accepted, index) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i = 0; i < accepted.length; i++) {
			var spec = specify(type, accepted[i], index);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	function specify(type, spec, index) {
		var p = parseMediaType(type);
		var s = 0;
		if (!p) return null;
		if (spec.type.toLowerCase() == p.type.toLowerCase()) s |= 4;
		else if (spec.type != "*") return null;
		if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) s |= 2;
		else if (spec.subtype != "*") return null;
		var keys = Object.keys(spec.params);
		if (keys.length > 0) if (keys.every(function(k) {
			return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
		})) s |= 1;
		else return null;
		return {
			i: index,
			o: spec.i,
			q: spec.q,
			s
		};
	}
	function preferredMediaTypes(accept, provided) {
		var accepts = parseAccept(accept === void 0 ? "*/*" : accept || "");
		if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
		var priorities = provided.map(function getPriority(type, index) {
			return getMediaTypePriority(type, accepts, index);
		});
		return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	function getFullType(spec) {
		return spec.type + "/" + spec.subtype;
	}
	function isQuality(spec) {
		return spec.q > 0;
	}
	function quoteCount(string) {
		var count = 0;
		var index = 0;
		while ((index = string.indexOf("\"", index)) !== -1) {
			count++;
			index++;
		}
		return count;
	}
	function splitKeyValuePair(str) {
		var index = str.indexOf("=");
		var key;
		var val;
		if (index === -1) key = str;
		else {
			key = str.substr(0, index);
			val = str.substr(index + 1);
		}
		return [key, val];
	}
	function splitMediaTypes(accept) {
		var accepts = accept.split(",");
		for (var i = 1, j = 0; i < accepts.length; i++) if (quoteCount(accepts[j]) % 2 == 0) accepts[++j] = accepts[i];
		else accepts[j] += "," + accepts[i];
		accepts.length = j + 1;
		return accepts;
	}
	function splitParameters(str) {
		var parameters = str.split(";");
		for (var i = 1, j = 0; i < parameters.length; i++) if (quoteCount(parameters[j]) % 2 == 0) parameters[++j] = parameters[i];
		else parameters[j] += ";" + parameters[i];
		parameters.length = j + 1;
		for (var i = 0; i < parameters.length; i++) parameters[i] = parameters[i].trim();
		return parameters;
	}
}));
/*!
* negotiator
* Copyright(c) 2012 Federico Romero
* Copyright(c) 2012-2014 Isaac Z. Schlueter
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_negotiator = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var preferredCharsets = require_charset();
	var preferredEncodings = require_encoding();
	var preferredLanguages = require_language();
	var preferredMediaTypes = require_mediaType();
	module.exports = Negotiator;
	module.exports.Negotiator = Negotiator;
	function Negotiator(request) {
		if (!(this instanceof Negotiator)) return new Negotiator(request);
		this.request = request;
	}
	Negotiator.prototype.charset = function charset(available) {
		var set = this.charsets(available);
		return set && set[0];
	};
	Negotiator.prototype.charsets = function charsets(available) {
		return preferredCharsets(this.request.headers["accept-charset"], available);
	};
	Negotiator.prototype.encoding = function encoding(available) {
		var set = this.encodings(available);
		return set && set[0];
	};
	Negotiator.prototype.encodings = function encodings(available) {
		return preferredEncodings(this.request.headers["accept-encoding"], available);
	};
	Negotiator.prototype.language = function language(available) {
		var set = this.languages(available);
		return set && set[0];
	};
	Negotiator.prototype.languages = function languages(available) {
		return preferredLanguages(this.request.headers["accept-language"], available);
	};
	Negotiator.prototype.mediaType = function mediaType(available) {
		var set = this.mediaTypes(available);
		return set && set[0];
	};
	Negotiator.prototype.mediaTypes = function mediaTypes(available) {
		return preferredMediaTypes(this.request.headers.accept, available);
	};
	Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
	Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
	Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
	Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
	Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
	Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
	Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
	Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
}));
/*!
* accepts
* Copyright(c) 2014 Jonathan Ong
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
var require_accepts = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Negotiator = require_negotiator();
	var mime = __require("mime-types");
	module.exports = Accepts;
	function Accepts(req) {
		if (!(this instanceof Accepts)) return new Accepts(req);
		this.headers = req.headers;
		this.negotiator = new Negotiator(req);
	}
	Accepts.prototype.type = Accepts.prototype.types = function(types_) {
		var types = types_;
		if (types && !Array.isArray(types)) {
			types = new Array(arguments.length);
			for (var i = 0; i < types.length; i++) types[i] = arguments[i];
		}
		if (!types || types.length === 0) return this.negotiator.mediaTypes();
		if (!this.headers.accept) return types[0];
		var mimes = types.map(extToMime);
		var first = this.negotiator.mediaTypes(mimes.filter(validMime))[0];
		return first ? types[mimes.indexOf(first)] : false;
	};
	Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
		var encodings = encodings_;
		if (encodings && !Array.isArray(encodings)) {
			encodings = new Array(arguments.length);
			for (var i = 0; i < encodings.length; i++) encodings[i] = arguments[i];
		}
		if (!encodings || encodings.length === 0) return this.negotiator.encodings();
		return this.negotiator.encodings(encodings)[0] || false;
	};
	Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
		var charsets = charsets_;
		if (charsets && !Array.isArray(charsets)) {
			charsets = new Array(arguments.length);
			for (var i = 0; i < charsets.length; i++) charsets[i] = arguments[i];
		}
		if (!charsets || charsets.length === 0) return this.negotiator.charsets();
		return this.negotiator.charsets(charsets)[0] || false;
	};
	Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
		var languages = languages_;
		if (languages && !Array.isArray(languages)) {
			languages = new Array(arguments.length);
			for (var i = 0; i < languages.length; i++) languages[i] = arguments[i];
		}
		if (!languages || languages.length === 0) return this.negotiator.languages();
		return this.negotiator.languages(languages)[0] || false;
	};
	function extToMime(type) {
		return type.indexOf("/") === -1 ? mime.lookup(type) : type;
	}
	function validMime(type) {
		return typeof type === "string";
	}
}));
function pack$2(value) {
	if (value === void 0 || value === null) return null;
	return base64.urlEncode(new MessageBuilder().build(value));
}
function canUnpack$2(encodedValue) {
	return typeof encodedValue === "string";
}
function unpack$2(encodedValue) {
	return new MessageBuilder().verify(base64.urlDecode(encodedValue, "utf-8", false));
}
function pack$1(key, value, encryption) {
	if (value === void 0 || value === null) return null;
	return `s:${encryption.getMessageVerifier().sign(value, void 0, key)}`;
}
function canUnpack$1(signedValue) {
	return typeof signedValue === "string" && signedValue.substring(0, 2) === "s:";
}
function unpack$1(key, signedValue, encryption) {
	const value = signedValue.slice(2);
	if (!value) return null;
	return encryption.getMessageVerifier().unsign(value, key);
}
function pack(key, value, encryption) {
	if (value === void 0 || value === null) return null;
	return `e:${encryption.encrypt(value, void 0, key)}`;
}
function canUnpack(encryptedValue) {
	return typeof encryptedValue === "string" && encryptedValue.substring(0, 2) === "e:";
}
function unpack(key, encryptedValue, encryption) {
	const value = encryptedValue.slice(2);
	if (!value) return null;
	return encryption.decrypt(value, key);
}
var CookieClient = class {
	#encryption;
	constructor(encryption) {
		this.#encryption = encryption;
	}
	encrypt(key, value) {
		return pack(key, value, this.#encryption);
	}
	sign(key, value) {
		return pack$1(key, value, this.#encryption);
	}
	encode(_, value, stringify = true) {
		return stringify ? pack$2(value) : value;
	}
	unsign(key, value) {
		return canUnpack$1(value) ? unpack$1(key, value, this.#encryption) : null;
	}
	decrypt(key, value) {
		return canUnpack(value) ? unpack(key, value, this.#encryption) : null;
	}
	decode(_, value, stringified = true) {
		if (!stringified) return value;
		return canUnpack$2(value) ? unpack$2(value) : null;
	}
	parse(key, value) {
		if (canUnpack$1(value)) return unpack$1(key, value, this.#encryption);
		if (canUnpack(value)) return unpack(key, value, this.#encryption);
		if (canUnpack$2(value)) return unpack$2(value);
	}
};
var CookieParser = class {
	#client;
	#cachedCookies = {
		signedCookies: {},
		plainCookies: {},
		encryptedCookies: {}
	};
	#cookies;
	constructor(cookieHeader, encryption) {
		this.#client = new CookieClient(encryption);
		this.#cookies = this.#parse(cookieHeader);
	}
	#parse(cookieHeader) {
		if (!cookieHeader) return {};
		return parse$1(cookieHeader);
	}
	#getCachedOrParse(key, cacheKey, parser) {
		const value = this.#cookies[key];
		if (value === null || value === void 0) return null;
		const cache = this.#cachedCookies[cacheKey];
		if (cache[key] !== void 0) return cache[key];
		const parsed = parser(value);
		if (parsed !== null) cache[key] = parsed;
		return parsed;
	}
	decode(key, stringified = true) {
		return this.#getCachedOrParse(key, "plainCookies", (value) => this.#client.decode(key, value, stringified));
	}
	unsign(key) {
		return this.#getCachedOrParse(key, "signedCookies", (value) => this.#client.unsign(key, value));
	}
	decrypt(key) {
		return this.#getCachedOrParse(key, "encryptedCookies", (value) => this.#client.decrypt(key, value));
	}
	list() {
		return this.#cookies;
	}
};
var import_accepts = /* @__PURE__ */ __toESM(require_accepts(), 1);
var HttpRequest = class extends Macroable {
	#qsParser;
	#encryption;
	#config;
	#requestBody = {};
	#requestData = {};
	#originalRequestData = {};
	#requestQs = {};
	#rawRequestBody;
	#lazyAccepts;
	#cookieParser;
	parsedUrl;
	ctx;
	constructor(request, response, encryption, config, qsParser) {
		super();
		this.request = request;
		this.response = response;
		this.#qsParser = qsParser;
		this.#config = config;
		this.#encryption = encryption;
		this.parsedUrl = safeDecodeURI(request.url, false);
		this.#parseQueryString();
	}
	#parseQueryString() {
		if (this.parsedUrl.query) {
			this.updateQs(this.#qsParser.parse(this.parsedUrl.query));
			this.#originalRequestData = { ...this.#requestData };
		}
	}
	#initiateCookieParser() {
		if (!this.#cookieParser) this.#cookieParser = new CookieParser(this.header("cookie"), this.#encryption);
	}
	#initiateAccepts() {
		this.#lazyAccepts = this.#lazyAccepts || (0, import_accepts.default)(this.request);
	}
	id() {
		let requestId = this.header("x-request-id");
		if (!requestId && this.#config.generateRequestId) {
			requestId = this.#config.createRequestId();
			this.request.headers["x-request-id"] = requestId;
		}
		return requestId;
	}
	setInitialBody(body) {
		if (this.#originalRequestData && Object.isFrozen(this.#originalRequestData)) throw new Error("Cannot re-set initial body. Use \"request.updateBody\" instead");
		this.updateBody(body);
		this.#originalRequestData = Object.freeze(lodash.cloneDeep(this.#requestData));
	}
	updateBody(body) {
		this.#requestBody = body;
		this.#requestData = {
			...this.#requestBody,
			...this.#requestQs
		};
	}
	updateRawBody(rawBody) {
		this.#rawRequestBody = rawBody;
	}
	updateQs(data) {
		this.#requestQs = data;
		this.#requestData = {
			...this.#requestBody,
			...this.#requestQs
		};
	}
	params() {
		return this.ctx?.params || {};
	}
	qs() {
		return this.#requestQs;
	}
	body() {
		return this.#requestBody;
	}
	all() {
		return this.#requestData;
	}
	original() {
		return this.#originalRequestData;
	}
	raw() {
		return this.#rawRequestBody || null;
	}
	input(key, defaultValue) {
		return lodash.get(this.#requestData, key, defaultValue);
	}
	param(key, defaultValue) {
		return lodash.get(this.params(), key, defaultValue);
	}
	except(keys) {
		return lodash.omit(this.#requestData, keys);
	}
	only(keys) {
		return lodash.pick(this.#requestData, keys);
	}
	intended() {
		return this.request.method;
	}
	method() {
		if (this.#config.allowMethodSpoofing && this.intended() === "POST") return this.input("_method", this.intended()).toUpperCase();
		return this.intended();
	}
	headers() {
		return this.request.headers;
	}
	header(key, defaultValue) {
		key = key.toLowerCase();
		const headers = this.headers();
		switch (key) {
			case "referer":
			case "referrer": return headers.referrer || headers.referer || defaultValue;
			default: return headers[key] || defaultValue;
		}
	}
	ip() {
		const ipFn = this.#config.getIp;
		if (typeof ipFn === "function") return ipFn(this);
		return proxyAddr(this.request, this.#config.trustProxy);
	}
	ips() {
		return proxyAddr.all(this.request, this.#config.trustProxy);
	}
	protocol() {
		if ("encrypted" in this.request.socket) return "https";
		if (trustProxy(this.request.socket.remoteAddress, this.#config.trustProxy)) {
			const forwardedProtocol = this.header("X-Forwarded-Proto");
			return forwardedProtocol ? forwardedProtocol.split(/\s*,\s*/)[0] : "http";
		}
		return "http";
	}
	secure() {
		return this.protocol() === "https";
	}
	host() {
		let host = this.header("host");
		if (trustProxy(this.request.socket.remoteAddress, this.#config.trustProxy)) host = this.header("X-Forwarded-Host") || host;
		if (!host) return null;
		return host;
	}
	hostname() {
		const host = this.host();
		if (!host) return null;
		const offset = host[0] === "[" ? host.indexOf("]") + 1 : 0;
		const index = host.indexOf(":", offset);
		return index !== -1 ? host.substring(0, index) : host;
	}
	subdomains() {
		const hostname = this.hostname();
		if (!hostname || isIP(hostname)) return [];
		const offset = this.#config.subdomainOffset;
		const subdomains = hostname.split(".").reverse().slice(offset);
		if (subdomains[subdomains.length - 1] === "www") subdomains.splice(subdomains.length - 1, 1);
		return subdomains;
	}
	ajax() {
		return this.header("X-Requested-With", "").toLowerCase() === "xmlhttprequest";
	}
	pjax() {
		return !!this.header("X-Pjax");
	}
	url(includeQueryString) {
		const pathname = this.parsedUrl.pathname;
		return includeQueryString && this.parsedUrl.query ? `${pathname}?${this.parsedUrl.query}` : pathname;
	}
	completeUrl(includeQueryString) {
		return `${this.protocol()}://${this.host()}${this.url(includeQueryString)}`;
	}
	matchesRoute(routeIdentifier) {
		if (!this.ctx || !this.ctx.route) return false;
		const route = this.ctx.route;
		return !!(Array.isArray(routeIdentifier) ? routeIdentifier : [routeIdentifier]).find((identifier) => {
			if (route.pattern === identifier || route.name === identifier) return true;
			if (typeof route.handler === "function") return false;
			return route.handler.reference === identifier;
		});
	}
	is(types) {
		return typeIs(this.request, types) || null;
	}
	accepts(types) {
		this.#initiateAccepts();
		return this.#lazyAccepts.type(types) || null;
	}
	types() {
		this.#initiateAccepts();
		return this.#lazyAccepts.types();
	}
	language(languages) {
		this.#initiateAccepts();
		return this.#lazyAccepts.language(languages) || null;
	}
	languages() {
		this.#initiateAccepts();
		return this.#lazyAccepts.languages();
	}
	charset(charsets) {
		this.#initiateAccepts();
		return this.#lazyAccepts.charset(charsets) || null;
	}
	charsets() {
		this.#initiateAccepts();
		return this.#lazyAccepts.charsets();
	}
	encoding(encodings) {
		this.#initiateAccepts();
		return this.#lazyAccepts.encoding(encodings) || null;
	}
	encodings() {
		this.#initiateAccepts();
		return this.#lazyAccepts.encodings();
	}
	hasBody() {
		return typeIs.hasBody(this.request);
	}
	fresh() {
		if (!["GET", "HEAD"].includes(this.intended())) return false;
		const status = this.response.statusCode;
		if (status >= 200 && status < 300 || status === 304) return fresh(this.headers(), this.response.getHeaders());
		return false;
	}
	stale() {
		return !this.fresh();
	}
	cookiesList() {
		this.#initiateCookieParser();
		return this.#cookieParser.list();
	}
	cookie(key, defaultValue) {
		this.#initiateCookieParser();
		return this.#cookieParser.unsign(key) || defaultValue;
	}
	encryptedCookie(key, defaultValue) {
		this.#initiateCookieParser();
		return this.#cookieParser.decrypt(key) || defaultValue;
	}
	plainCookie(key, defaultValueOrOptions, encoded) {
		this.#initiateCookieParser();
		if (is.object(defaultValueOrOptions)) return this.#cookieParser.decode(key, defaultValueOrOptions?.encoded) || defaultValueOrOptions.defaultValue;
		return this.#cookieParser.decode(key, encoded) || defaultValueOrOptions;
	}
	hasValidSignature(purpose) {
		const { signature, ...rest } = this.qs();
		if (!signature) return false;
		const signedUrl = this.#encryption.getMessageVerifier().unsign(signature, purpose);
		if (!signedUrl) return false;
		const queryString = this.#qsParser.stringify(rest);
		return queryString ? safeEqual(signedUrl, `${this.url()}?${queryString}`) : safeEqual(signedUrl, this.url());
	}
	serialize() {
		return {
			id: this.id(),
			url: this.url(),
			query: this.parsedUrl.query,
			body: this.all(),
			params: this.params(),
			headers: this.headers(),
			method: this.method(),
			protocol: this.protocol(),
			cookies: this.cookiesList(),
			hostname: this.hostname(),
			ip: this.ip(),
			subdomains: this.ctx?.subdomains || {}
		};
	}
	toJSON() {
		return this.serialize();
	}
};
var RoutesStore = class {
	usingDomains = false;
	tree = {
		tokens: [],
		domains: {}
	};
	#getDomainNode(domain) {
		if (!this.tree.domains[domain]) {
			this.tree.tokens.push(parseRoute(domain));
			this.tree.domains[domain] = {};
		}
		return this.tree.domains[domain];
	}
	#getMethodNode(domain, method) {
		const domainNode = this.#getDomainNode(domain);
		if (!domainNode[method]) domainNode[method] = {
			tokens: [],
			routes: {},
			routeKeys: {}
		};
		return domainNode[method];
	}
	#collectRouteParams(route, tokens) {
		const collectedParams = /* @__PURE__ */ new Set();
		for (let token of tokens) if ([1, 3].includes(token.type)) if (collectedParams.has(token.val)) throw new RuntimeException(`Duplicate param "${token.val}" found in "${route.pattern}"`);
		else collectedParams.add(token.val);
		const params = [...collectedParams];
		collectedParams.clear();
		return params;
	}
	#registerRoute(domain, method, tokens, route) {
		const methodRoutes = this.#getMethodNode(domain, method);
		if (methodRoutes.routes[route.pattern]) throw new RuntimeException(`Duplicate route found. "${method}: ${route.pattern}" route already exists`);
		if (debug_default.enabled) {
			debug_default("registering route to the store %O", route);
			debug_default("route middleware %O", route.middleware.all().entries());
		}
		methodRoutes.tokens.push(tokens);
		methodRoutes.routes[route.pattern] = route;
		methodRoutes.routeKeys[route.pattern] = domain !== "root" ? `${domain}-${method}-${route.pattern}` : `${method}-${route.pattern}`;
	}
	add(route) {
		if (route.domain !== "root") this.usingDomains = true;
		const routeNode = { ...route };
		routeNode.meta.params = this.#collectRouteParams(routeNode, route.tokens);
		route.methods.forEach((method) => {
			this.#registerRoute(route.domain, method, route.tokens, routeNode);
		});
		return this;
	}
	match(url, method, shouldDecodeParam, domain) {
		const domainName = domain?.tokens[0]?.old || "root";
		if (!this.tree.domains[domainName]) return null;
		const matchedMethod = this.tree.domains[domainName][method];
		if (!matchedMethod) return null;
		const matchedRoute = matchit.match(url, matchedMethod.tokens);
		if (!matchedRoute.length) return null;
		const route = matchedMethod.routes[matchedRoute[0].old];
		return {
			route,
			routeKey: matchedMethod.routeKeys[route.pattern],
			params: matchit.exec(url, matchedRoute, shouldDecodeParam),
			subdomains: domain?.hostname ? matchit.exec(domain.hostname, domain.tokens) : {}
		};
	}
	matchDomain(hostname) {
		if (!hostname || !this.usingDomains) return [];
		return matchit.match(hostname, this.tree.tokens);
	}
};
var UrlBuilder = class {
	#params = {};
	#qs = {};
	#shouldPerformLookup = true;
	#baseUrl;
	#router;
	#domain;
	constructor(router, domain) {
		this.#router = router;
		this.#domain = domain;
	}
	prefixUrl(url) {
		this.#baseUrl = url;
		return this;
	}
	disableRouteLookup() {
		this.#shouldPerformLookup = false;
		return this;
	}
	qs(queryString) {
		if (!queryString) return this;
		this.#qs = queryString;
		return this;
	}
	params(params) {
		if (!params) return this;
		this.#params = params;
		return this;
	}
	make(identifier) {
		return this.#router.makeUrl(identifier, this.#params, {
			prefixUrl: this.#baseUrl,
			disableRouteLookup: !this.#shouldPerformLookup,
			domain: this.#domain,
			qs: this.#qs
		});
	}
	makeSigned(identifier, options) {
		return this.#router.makeSignedUrl(identifier, this.#params, {
			prefixUrl: this.#baseUrl,
			disableRouteLookup: !this.#shouldPerformLookup,
			domain: this.#domain,
			qs: this.#qs,
			...options
		});
	}
};
var RouteMatchers = class extends Macroable {
	number() {
		return {
			match: /^[0-9]+$/,
			cast: (value) => Number(value)
		};
	}
	uuid() {
		return {
			match: /^[0-9a-zA-F]{8}-[0-9a-zA-F]{4}-[0-9a-zA-F]{4}-[0-9a-zA-F]{4}-[0-9a-zA-F]{12}$/,
			cast: (value) => value.toLowerCase()
		};
	}
	slug() {
		return { match: /^[^\s-_](?!.*?[-_]{2,})([a-z0-9-\\]{1,})[^\s]*[^-_\s]$/ };
	}
};
function middlewareReferenceBuilder(name, middleware) {
	const handler = moduleImporter(middleware, "handle").toHandleMethod();
	return function(...args) {
		return {
			...handler,
			name,
			reference: middleware,
			args: args[0]
		};
	};
}
function defineNamedMiddleware(collection) {
	return Object.keys(collection).reduce((result, key) => {
		result[key] = middlewareReferenceBuilder(key, collection[key]);
		return result;
	}, {});
}
function createSignedUrlBuilder(router, encryption, searchParamsStringifier) {
	let domainsList;
	function createSignedUrlForRoute(identifier, params, options, method) {
		if (!domainsList) domainsList = Object.keys(router.toJSON()).filter((domain) => domain !== "root");
		const domain = domainsList.find((name) => identifier.startsWith(`${name}@`));
		const routeIdentifier = domain ? identifier.replace(new RegExp(`^${domain}@`), "") : identifier;
		const route = router.findOrFail(routeIdentifier, domain, method, true);
		return createSignedURL(route.name ?? route.pattern, route.tokens, searchParamsStringifier, encryption, params, options);
	}
	const signedRoute = function route(...[identifier, params, options]) {
		return createSignedUrlForRoute(identifier, params, options);
	};
	signedRoute.get = function routeGet(...[identifier, params, options]) {
		const method = "GET";
		const url = createSignedUrlForRoute(identifier, params, options, method);
		return {
			url,
			method,
			toString() {
				return url;
			},
			form: {
				action: url,
				method
			}
		};
	};
	signedRoute.post = function routePost(...[identifier, params, options]) {
		const method = "POST";
		const url = createSignedUrlForRoute(identifier, params, options, method);
		return {
			url,
			method,
			toString() {
				return url;
			},
			form: {
				action: url,
				method
			}
		};
	};
	signedRoute.put = function routePut(...[identifier, params, options]) {
		const method = "PUT";
		const url = createSignedUrlForRoute(identifier, params, options, method);
		return {
			url,
			method,
			toString() {
				return url;
			},
			form: {
				action: url,
				method
			}
		};
	};
	signedRoute.patch = function routePatch(...[identifier, params, options]) {
		const method = "PATCH";
		const url = createSignedUrlForRoute(identifier, params, options, method);
		return {
			url,
			method,
			toString() {
				return url;
			},
			form: {
				action: url,
				method
			}
		};
	};
	signedRoute.delete = function routeDelete(...[identifier, params, options]) {
		const method = "DELETE";
		const url = createSignedUrlForRoute(identifier, params, options, method);
		return {
			url,
			method,
			toString() {
				return url;
			},
			form: {
				action: url,
				method
			}
		};
	};
	signedRoute.method = function routeGet(method, ...[identifier, params, options]) {
		const url = createSignedUrlForRoute(identifier, params, options, method);
		return {
			url,
			method,
			toString() {
				return url;
			},
			form: {
				action: url,
				method
			}
		};
	};
	return signedRoute;
}
var Router = class {
	#commited = false;
	#app;
	#store = new RoutesStore();
	#encryption;
	#globalMatchers = {};
	#middleware = [];
	#openedGroups = [];
	#routesToBeCommitted = [];
	usingDomains = false;
	matchers = new RouteMatchers();
	get commited() {
		return this.#commited;
	}
	qs;
	urlBuilder;
	routes = {};
	constructor(app, encryption, qsParser) {
		this.#app = app;
		this.#encryption = encryption;
		this.qs = qsParser;
		this.urlBuilder = {
			urlFor: createUrlBuilder(() => this.toJSON(), this.qs.stringify),
			signedUrlFor: createSignedUrlBuilder(this, this.#encryption, this.qs.stringify)
		};
	}
	register(route) {
		this.routes[route.domain] = this.routes[route.domain] || [];
		this.routes[route.domain].push(route);
	}
	#pushToRoutes(entity) {
		const openedGroup = this.#openedGroups[this.#openedGroups.length - 1];
		if (openedGroup) {
			openedGroup.routes.push(entity);
			return;
		}
		this.#routesToBeCommitted.push(entity);
	}
	parsePattern(pattern, matchers) {
		return parseRoute(pattern, matchers);
	}
	use(middleware) {
		middleware.forEach((one) => this.#middleware.push({
			reference: one,
			...moduleImporter(one, "handle").toHandleMethod()
		}));
		return this;
	}
	named(collection) {
		return defineNamedMiddleware(collection);
	}
	route(pattern, methods, handler) {
		const route = new Route(this.#app, this.#middleware, {
			pattern,
			methods,
			handler,
			globalMatchers: this.#globalMatchers
		});
		this.#pushToRoutes(route);
		return route;
	}
	any(pattern, handler) {
		return this.route(pattern, [
			"HEAD",
			"OPTIONS",
			"GET",
			"POST",
			"PUT",
			"PATCH",
			"DELETE"
		], handler);
	}
	get(pattern, handler) {
		return this.route(pattern, ["GET", "HEAD"], handler);
	}
	post(pattern, handler) {
		return this.route(pattern, ["POST"], handler);
	}
	put(pattern, handler) {
		return this.route(pattern, ["PUT"], handler);
	}
	patch(pattern, handler) {
		return this.route(pattern, ["PATCH"], handler);
	}
	delete(pattern, handler) {
		return this.route(pattern, ["DELETE"], handler);
	}
	group(callback) {
		const group = new RouteGroup([]);
		this.#pushToRoutes(group);
		this.#openedGroups.push(group);
		callback();
		this.#openedGroups.pop();
		return group;
	}
	resource(resource, controller) {
		const resourceInstance = new RouteResource(this.#app, this.#middleware, {
			resource,
			controller,
			shallow: false,
			globalMatchers: this.#globalMatchers
		});
		this.#pushToRoutes(resourceInstance);
		return resourceInstance;
	}
	shallowResource(resource, controller) {
		const resourceInstance = new RouteResource(this.#app, this.#middleware, {
			resource,
			controller,
			shallow: true,
			globalMatchers: this.#globalMatchers
		});
		this.#pushToRoutes(resourceInstance);
		return resourceInstance;
	}
	on(pattern) {
		const briskRoute = new BriskRoute(this.#app, this.#middleware, {
			pattern,
			globalMatchers: this.#globalMatchers
		});
		this.#pushToRoutes(briskRoute);
		return briskRoute;
	}
	where(param, matcher) {
		if (typeof matcher === "string") this.#globalMatchers[param] = { match: new RegExp(matcher) };
		else if (is.regExp(matcher)) this.#globalMatchers[param] = { match: matcher };
		else this.#globalMatchers[param] = matcher;
		return this;
	}
	commit() {
		if (this.#commited) return;
		debug_default("Committing routes to the routes store");
		const routeNamesByDomain = /* @__PURE__ */ new Map();
		toRoutesJSON(this.#routesToBeCommitted).forEach((route) => {
			if (!routeNamesByDomain.has(route.domain)) routeNamesByDomain.set(route.domain, /* @__PURE__ */ new Set());
			const routeNames = routeNamesByDomain.get(route.domain);
			if (route.name && routeNames.has(route.name)) throw new RuntimeException(`A route with name "${route.name}" already exists. It may happen when two routes use the same controller, so make sure to give explicit names to these routes`);
			if (route.name) routeNames.add(route.name);
			this.register(route);
			this.#store.add(route);
		});
		routeNamesByDomain.clear();
		this.usingDomains = this.#store.usingDomains;
		this.#routesToBeCommitted = [];
		this.#globalMatchers = {};
		this.#middleware = [];
		this.#openedGroups = [];
		this.#commited = true;
	}
	find(routeIdentifier, domain, method, disableLegacyLookup) {
		return findRoute(this.routes, routeIdentifier, domain, method, disableLegacyLookup);
	}
	findOrFail(routeIdentifier, domain, method, disableLegacyLookup) {
		const route = this.find(routeIdentifier, domain, method, disableLegacyLookup);
		if (!route) {
			if (method) throw new Error(`Cannot lookup route "${routeIdentifier}" for method "${method}"`);
			throw new Error(`Cannot lookup route "${routeIdentifier}"`);
		}
		return route;
	}
	has(routeIdentifier, domain, method, followLookupStrategy) {
		return !!this.find(routeIdentifier, domain, method, followLookupStrategy);
	}
	toJSON() {
		return this.routes;
	}
	generateTypes(indentation = 0) {
		const routesList = {};
		function trackRoute(route, domain) {
			let params = [];
			let paramsTuple = [];
			let hasRequiredParams = false;
			for (let token of route.tokens) if (token.type === 1) {
				hasRequiredParams = true;
				params.push(`'${token.val}': ParamValue`);
				paramsTuple.push("ParamValue");
			} else if (token.type === 3) {
				params.push(`'${token.val}'?: ParamValue`);
				paramsTuple.push("ParamValue?");
			} else if (token.type === 2) {
				hasRequiredParams = true;
				params.push(`'*': ParamValue[]`);
				paramsTuple.push("...ParamValue[]");
				break;
			}
			route.methods.forEach((method) => {
				routesList["ALL"] = routesList["ALL"] ?? {};
				routesList[method] = routesList[method] ?? {};
				const identifiers = [];
				if (route.name) identifiers.push(domain && routesList[method][route.name] ? `${domain}@${route.name}` : route.name);
				identifiers.forEach((identifier) => {
					routesList["ALL"][identifier] = {
						params,
						paramsTuple,
						hasRequiredParams
					};
					routesList[method][identifier] = {
						params,
						paramsTuple,
						hasRequiredParams
					};
				});
			});
		}
		const domains = Object.keys(this.routes).filter((domain) => domain !== "root");
		this.routes["root"]?.forEach((route) => trackRoute.bind(this)(route));
		domains.forEach((domain) => this.routes[domain].forEach((route) => trackRoute.bind(this)(route, domain)));
		return {
			imports: [],
			types: ["type ParamValue = string | number | bigint | boolean"],
			routes: Object.keys(routesList).reduce((result, method) => {
				result.push(`${" ".repeat(indentation)}${method}: {`);
				Object.keys(routesList[method]).forEach((identifier) => {
					const key = `'${identifier}'`;
					const { paramsTuple, hasRequiredParams, params } = routesList[method][identifier];
					const dictName = hasRequiredParams ? "params" : "params?";
					const tupleName = hasRequiredParams ? "paramsTuple" : "paramsTuple?";
					const dictValue = `{${params.join(",")}}`;
					const value = `{ ${tupleName}: ${`[${paramsTuple?.join(",")}]`}; ${dictName}: ${dictValue} }`;
					result.push(`${" ".repeat(indentation + 2)}${key}: ${value}`);
				});
				result.push(`${" ".repeat(indentation)}}`);
				return result;
			}, []).join("\n")
		};
	}
	match(uri, method, shouldDecodeParam, hostname) {
		const matchingDomain = this.#store.matchDomain(hostname);
		return matchingDomain.length ? this.#store.match(uri, method, shouldDecodeParam, {
			tokens: matchingDomain,
			hostname
		}) : this.#store.match(uri, method, shouldDecodeParam);
	}
	builder() {
		return new UrlBuilder(this);
	}
	builderForDomain(domain) {
		return new UrlBuilder(this, domain);
	}
	makeUrl(routeIdentifier, params, options) {
		const normalizedOptions = Object.assign({}, options);
		if (options?.disableRouteLookup) return createURL(routeIdentifier, parseRoute(routeIdentifier), this.qs.stringify, params, options);
		const route = this.findOrFail(routeIdentifier, normalizedOptions.domain);
		return createURL(route.name ?? route.pattern, route.tokens, this.qs.stringify, params, options);
	}
	makeSignedUrl(routeIdentifier, params, options) {
		const normalizedOptions = Object.assign({}, options);
		if (options?.disableRouteLookup) return createSignedURL(routeIdentifier, parseRoute(routeIdentifier), this.qs.stringify, this.#encryption, params, options);
		const route = this.findOrFail(routeIdentifier, normalizedOptions.domain);
		return createSignedURL(route.name ?? route.pattern, route.tokens, this.qs.stringify, this.#encryption, params, options);
	}
};
const ResponseStatus = {
	Continue: 100,
	SwitchingProtocols: 101,
	Processing: 102,
	EarlyHints: 103,
	Ok: 200,
	Created: 201,
	Accepted: 202,
	NonAuthoritativeInformation: 203,
	NoContent: 204,
	ResetContent: 205,
	PartialContent: 206,
	MultiStatus: 207,
	AlreadyReported: 208,
	IMUsed: 226,
	MultipleChoices: 300,
	MovedPermanently: 301,
	Found: 302,
	SeeOther: 303,
	NotModified: 304,
	UseProxy: 305,
	TemporaryRedirect: 307,
	PermanentRedirect: 308,
	BadRequest: 400,
	Unauthorized: 401,
	PaymentRequired: 402,
	Forbidden: 403,
	NotFound: 404,
	MethodNotAllowed: 405,
	NotAcceptable: 406,
	ProxyAuthenticationRequired: 407,
	RequestTimeout: 408,
	Conflict: 409,
	Gone: 410,
	LengthRequired: 411,
	PreconditionFailed: 412,
	PayloadTooLarge: 413,
	URITooLong: 414,
	UnsupportedMediaType: 415,
	RangeNotSatisfiable: 416,
	ExpectationFailed: 417,
	ImATeapot: 418,
	MisdirectedRequest: 421,
	UnprocessableEntity: 422,
	Locked: 423,
	FailedDependency: 424,
	TooEarly: 425,
	UpgradeRequired: 426,
	PreconditionRequired: 428,
	TooManyRequests: 429,
	RequestHeaderFieldsTooLarge: 431,
	UnavailableForLegalReasons: 451,
	InternalServerError: 500,
	NotImplemented: 501,
	BadGateway: 502,
	ServiceUnavailable: 503,
	GatewayTimeout: 504,
	HTTPVersionNotSupported: 505,
	VariantAlsoNegotiates: 506,
	InsufficientStorage: 507,
	LoopDetected: 508,
	NotExtended: 510,
	NetworkAuthenticationRequired: 511
};
var CookieSerializer = class {
	#client;
	constructor(encryption) {
		this.#client = new CookieClient(encryption);
	}
	encode(key, value, options) {
		const stringify = options?.stringify ?? options?.encode;
		const packedValue = this.#client.encode(key, value, stringify);
		if (packedValue === null || packedValue === void 0) return null;
		return serializeCookie(key, packedValue, options);
	}
	sign(key, value, options) {
		const packedValue = this.#client.sign(key, value);
		if (packedValue === null) return null;
		return serializeCookie(key, packedValue, options);
	}
	encrypt(key, value, options) {
		const packedValue = this.#client.encrypt(key, value);
		if (packedValue === null) return null;
		return serializeCookie(key, packedValue, options);
	}
};
const CACHEABLE_HTTP_METHODS = ["GET", "HEAD"];
const DATA_TYPES = {
	buffer: "buffer",
	regexp: "regexp",
	date: "date",
	object: "object",
	number: "number",
	boolean: "boolean",
	string: "string",
	bigint: "bigint"
};
const CONTENT_TYPES = {
	text: "text/plain; charset=utf-8",
	html: "text/html; charset=utf-8",
	script: "application/octet-stream; charset=utf-8",
	json: "application/json; charset=utf-8"
};
var HttpResponse = class extends Macroable {
	#qs;
	#headers = {};
	#hasExplicitStatus = false;
	#cookieSerializer;
	#router;
	#config;
	get hasLazyBody() {
		return !!(this.lazyBody.content || this.lazyBody.fileToStream || this.lazyBody.stream);
	}
	get hasContent() {
		return !!this.lazyBody.content;
	}
	get hasStream() {
		return !!this.lazyBody.stream;
	}
	get hasFileToStream() {
		return !!this.lazyBody.fileToStream;
	}
	get content() {
		return this.lazyBody.content;
	}
	get outgoingStream() {
		return this.lazyBody.stream?.[0];
	}
	get fileToStream() {
		return this.lazyBody.fileToStream ? {
			path: this.lazyBody.fileToStream[0],
			generateEtag: this.lazyBody.fileToStream[1]
		} : void 0;
	}
	lazyBody = {};
	ctx;
	constructor(request, response, encryption, config, router, qs) {
		super();
		this.request = request;
		this.response = response;
		this.#qs = qs;
		this.#config = config;
		this.#router = router;
		this.#cookieSerializer = new CookieSerializer(encryption);
	}
	get finished() {
		return this.response.writableFinished;
	}
	get headersSent() {
		return this.response.headersSent;
	}
	get isPending() {
		return !this.headersSent && !this.finished;
	}
	#castHeaderValue(value) {
		return Array.isArray(value) ? value.map(String) : String(value);
	}
	#endResponse(body, statusCode) {
		this.writeHead(statusCode);
		this.response.end(body, null, null);
	}
	writeBody(content, generateEtag, jsonpCallbackName) {
		const hasEmptyBody = content === null || content === void 0 || content === "";
		if (hasEmptyBody) this.safeStatus(204);
		const statusCode = this.response.statusCode;
		if (statusCode && (statusCode < ResponseStatus.Ok || statusCode === ResponseStatus.NoContent || statusCode === ResponseStatus.NotModified)) {
			this.removeHeader("Content-Type");
			this.removeHeader("Content-Length");
			this.removeHeader("Transfer-Encoding");
			this.#endResponse();
			return;
		}
		if (hasEmptyBody) {
			this.removeHeader("Content-Length");
			this.#endResponse();
			return;
		}
		let contentType;
		const dataType = typeof content;
		if (dataType === DATA_TYPES.string) contentType = content.trimStart().startsWith("<") ? CONTENT_TYPES.html : CONTENT_TYPES.text;
		else if (content instanceof Uint8Array) contentType = CONTENT_TYPES.script;
		else if (content instanceof RegExp) {
			content = String(content);
			contentType = CONTENT_TYPES.text;
		} else if (content instanceof Date) {
			content = content.toISOString();
			contentType = CONTENT_TYPES.text;
		} else if (dataType === "object") {
			content = this.#config.serializeJSON(content);
			contentType = CONTENT_TYPES.json;
		} else if (dataType === DATA_TYPES.number || dataType === DATA_TYPES.boolean || dataType === DATA_TYPES.bigint) {
			content = String(content);
			contentType = CONTENT_TYPES.text;
		} else throw new RuntimeException(`Cannot serialize "${dataType}" to HTTP response`);
		if (jsonpCallbackName) {
			content = content.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
			content = `/**/ typeof ${jsonpCallbackName} === 'function' && ${jsonpCallbackName}(${content});`;
		}
		if (generateEtag) this.setEtag(content);
		if (generateEtag && this.fresh()) {
			this.removeHeader("Content-Type");
			this.removeHeader("Content-Length");
			this.removeHeader("Transfer-Encoding");
			this.#endResponse(null, ResponseStatus.NotModified);
			return;
		}
		this.header("Content-Length", Buffer.byteLength(content));
		if (jsonpCallbackName) {
			this.header("X-Content-Type-Options", "nosniff");
			this.safeHeader("Content-Type", "text/javascript; charset=utf-8");
		} else this.safeHeader("Content-type", contentType);
		this.#endResponse(content);
	}
	streamBody(body, errorCallback) {
		const readable = body instanceof ReadableStream ? Readable.fromWeb(body) : body;
		return new Promise((resolve) => {
			let finished = false;
			readable.on("error", (error) => {
				/* c8 ignore next 3 */
				if (finished) return;
				finished = true;
				destroy(readable);
				this.type("text");
				if (!this.headersSent) if (typeof errorCallback === "function") this.#endResponse(...errorCallback(error));
				else this.#endResponse(error.code === "ENOENT" ? "File not found" : "Cannot process file", error.code === "ENOENT" ? ResponseStatus.NotFound : ResponseStatus.InternalServerError);
				else this.response.destroy();
				resolve();
			});
			readable.on("end", () => {
				if (!this.headersSent) this.#endResponse();
				resolve();
			});
			onFinished(this.response, () => {
				finished = true;
				destroy(readable);
			});
			this.relayHeaders();
			readable.pipe(this.response);
		});
	}
	async streamFileForDownload(filePath, generateEtag, errorCallback) {
		try {
			const stats = await stat(filePath);
			if (!stats || !stats.isFile()) throw new TypeError("response.download only accepts path to a file");
			this.header("Last-Modified", stats.mtime.toUTCString());
			this.type(extname(filePath));
			if (generateEtag) this.setEtag(stats, true);
			if (this.request.method === "HEAD") {
				this.#endResponse(null, generateEtag && this.fresh() ? ResponseStatus.NotModified : ResponseStatus.Ok);
				return;
			}
			if (generateEtag && this.fresh()) {
				this.#endResponse(null, ResponseStatus.NotModified);
				return;
			}
			this.header("Content-length", stats.size);
			return this.streamBody(createReadStream(filePath), errorCallback);
		} catch (error) {
			this.type("text");
			this.removeHeader("Etag");
			if (typeof errorCallback === "function") this.#endResponse(...errorCallback(error));
			else this.#endResponse(error.code === "ENOENT" ? "File not found" : "Cannot process file", error.code === "ENOENT" ? ResponseStatus.NotFound : ResponseStatus.InternalServerError);
		}
	}
	onFinish(callback) {
		onFinished(this.response, callback);
	}
	relayHeaders() {
		if (!this.headersSent) for (let key in this.#headers) {
			const value = this.#headers[key];
			if (value) this.response.setHeader(key, value);
		}
	}
	writeHead(statusCode) {
		this.response.writeHead(statusCode || this.response.statusCode, this.#headers);
		return this;
	}
	getHeader(key) {
		const value = this.#headers[key.toLowerCase()];
		return value === void 0 ? this.response.getHeader(key) : value;
	}
	getHeaders() {
		return {
			...this.response.getHeaders(),
			...this.#headers
		};
	}
	header(key, value) {
		if (value === null || value === void 0) return this;
		this.#headers[key.toLowerCase()] = this.#castHeaderValue(value);
		return this;
	}
	append(key, value) {
		if (value === null || value === void 0) return this;
		key = key.toLowerCase();
		let existingHeader = this.getHeader(key);
		let casted = this.#castHeaderValue(value);
		if (!existingHeader) {
			this.#headers[key] = casted;
			return this;
		}
		existingHeader = this.#castHeaderValue(existingHeader);
		casted = Array.isArray(existingHeader) ? existingHeader.concat(casted) : [existingHeader].concat(casted);
		this.#headers[key] = casted;
		return this;
	}
	safeHeader(key, value) {
		if (!this.getHeader(key)) this.header(key, value);
		return this;
	}
	removeHeader(key) {
		key = key.toLowerCase();
		this.response.removeHeader(key);
		if (this.#headers[key]) delete this.#headers[key.toLowerCase()];
		return this;
	}
	getStatus() {
		return this.response.statusCode;
	}
	status(code) {
		this.#hasExplicitStatus = true;
		this.response.statusCode = code;
		return this;
	}
	safeStatus(code) {
		if (this.#hasExplicitStatus) return this;
		this.status(code);
		return this;
	}
	type(type, charset) {
		type = charset ? `${type}; charset=${charset}` : type;
		this.header("Content-Type", mime$1.contentType(type));
		return this;
	}
	vary(field) {
		vary(this.response, field);
		return this;
	}
	setEtag(body, weak = false) {
		this.header("Etag", etag(body, { weak }));
		return this;
	}
	setRequestId() {
		const requestId = this.request.headers["x-request-id"];
		if (requestId) this.header("X-Request-Id", requestId);
		return this;
	}
	fresh() {
		if (this.request.method && !CACHEABLE_HTTP_METHODS.includes(this.request.method)) return false;
		const status = this.response.statusCode;
		if (status >= ResponseStatus.Ok && status < ResponseStatus.MultipleChoices || status === ResponseStatus.NotModified) return fresh(this.request.headers, this.#headers);
		return false;
	}
	getBody() {
		if (this.lazyBody.content) return this.lazyBody.content[0];
		return null;
	}
	send(body, generateEtag = this.#config.etag) {
		if (body instanceof Response) {
			body.headers.forEach((value, key) => this.header(key, value));
			this.safeStatus(body.status);
			if (body.body) this.stream(body.body);
			return;
		}
		this.lazyBody.content = [body, generateEtag];
	}
	json(body, generateEtag = this.#config.etag) {
		return this.send(body, generateEtag);
	}
	jsonp(body, callbackName = this.#config.jsonpCallbackName, generateEtag = this.#config.etag) {
		this.lazyBody.content = [
			body,
			generateEtag,
			callbackName
		];
	}
	stream(body, errorCallback) {
		if (body instanceof ReadableStream === false && (typeof body.pipe !== "function" || !body.readable || typeof body.read !== "function")) throw new TypeError("response.stream accepts a readable stream only");
		this.lazyBody.stream = [body, errorCallback];
	}
	download(filePath, generateEtag = this.#config.etag, errorCallback) {
		this.lazyBody.fileToStream = [
			filePath,
			generateEtag,
			errorCallback
		];
	}
	attachment(filePath, name, disposition, generateEtag, errorCallback) {
		name = name || filePath;
		this.header("Content-Disposition", contentDisposition(name, { type: disposition }));
		return this.download(filePath, generateEtag, errorCallback);
	}
	location(url) {
		this.header("Location", url);
		return this;
	}
	redirect(path, forwardQueryString = false, statusCode = ResponseStatus.Found) {
		const handler = new Redirect(this.request, this, this.#router, this.#qs);
		if (forwardQueryString) handler.withQs();
		if (path === "back") return handler.status(statusCode).back();
		if (path) return handler.status(statusCode).toPath(path);
		return handler;
	}
	abort(body, status) {
		throw E_HTTP_REQUEST_ABORTED.invoke(body, status || ResponseStatus.BadRequest);
	}
	abortIf(condition, body, status) {
		if (condition) this.abort(body, status);
	}
	abortUnless(condition, body, status) {
		if (!condition) this.abort(body, status);
	}
	cookie(key, value, options) {
		options = Object.assign({}, this.#config.cookie, options);
		const serialized = this.#cookieSerializer.sign(key, value, options);
		if (!serialized) return this;
		this.append("set-cookie", serialized);
		return this;
	}
	encryptedCookie(key, value, options) {
		options = Object.assign({}, this.#config.cookie, options);
		const serialized = this.#cookieSerializer.encrypt(key, value, options);
		if (!serialized) return this;
		this.append("set-cookie", serialized);
		return this;
	}
	plainCookie(key, value, options) {
		options = Object.assign({}, this.#config.cookie, options);
		const serialized = this.#cookieSerializer.encode(key, value, options);
		if (!serialized) return this;
		this.append("set-cookie", serialized);
		return this;
	}
	clearCookie(key, options) {
		options = Object.assign({}, this.#config.cookie, options);
		options.expires = /* @__PURE__ */ new Date(1);
		options.maxAge = -1;
		const serialized = this.#cookieSerializer.encode(key, "", {
			...options,
			encode: false
		});
		this.append("set-cookie", serialized);
		return this;
	}
	finish() {
		if (!this.isPending) return;
		this.setRequestId();
		if (this.content) {
			httpResponseSerializer.traceSync(this.writeBody, void 0, this, ...this.content);
			return;
		}
		if (this.lazyBody.stream) {
			this.streamBody(...this.lazyBody.stream);
			return;
		}
		if (this.lazyBody.fileToStream) {
			this.streamFileForDownload(...this.lazyBody.fileToStream);
			return;
		}
		this.#endResponse();
	}
	continue() {
		this.status(ResponseStatus.Continue);
		return this.send(null, false);
	}
	switchingProtocols() {
		this.status(ResponseStatus.SwitchingProtocols);
		return this.send(null, false);
	}
	ok(body, generateEtag) {
		this.status(ResponseStatus.Ok);
		return this.send(body, generateEtag);
	}
	created(body, generateEtag) {
		this.status(ResponseStatus.Created);
		return this.send(body, generateEtag);
	}
	accepted(body, generateEtag) {
		this.status(ResponseStatus.Accepted);
		return this.send(body, generateEtag);
	}
	nonAuthoritativeInformation(body, generateEtag) {
		this.status(ResponseStatus.NonAuthoritativeInformation);
		return this.send(body, generateEtag);
	}
	noContent() {
		this.status(ResponseStatus.NoContent);
		return this.send(null, false);
	}
	resetContent() {
		this.status(ResponseStatus.ResetContent);
		return this.send(null, false);
	}
	partialContent(body, generateEtag) {
		this.status(ResponseStatus.PartialContent);
		return this.send(body, generateEtag);
	}
	multipleChoices(body, generateEtag) {
		this.status(ResponseStatus.MultipleChoices);
		return this.send(body, generateEtag);
	}
	movedPermanently(body, generateEtag) {
		this.status(ResponseStatus.MovedPermanently);
		return this.send(body, generateEtag);
	}
	movedTemporarily(body, generateEtag) {
		this.status(ResponseStatus.Found);
		return this.send(body, generateEtag);
	}
	seeOther(body, generateEtag) {
		this.status(ResponseStatus.SeeOther);
		return this.send(body, generateEtag);
	}
	notModified(body, generateEtag) {
		this.status(ResponseStatus.NotModified);
		return this.send(body, generateEtag);
	}
	useProxy(body, generateEtag) {
		this.status(ResponseStatus.UseProxy);
		return this.send(body, generateEtag);
	}
	temporaryRedirect(body, generateEtag) {
		this.status(ResponseStatus.TemporaryRedirect);
		return this.send(body, generateEtag);
	}
	badRequest(body, generateEtag) {
		this.status(ResponseStatus.BadRequest);
		return this.send(body, generateEtag);
	}
	unauthorized(body, generateEtag) {
		this.status(ResponseStatus.Unauthorized);
		return this.send(body, generateEtag);
	}
	paymentRequired(body, generateEtag) {
		this.status(ResponseStatus.PaymentRequired);
		return this.send(body, generateEtag);
	}
	forbidden(body, generateEtag) {
		this.status(ResponseStatus.Forbidden);
		return this.send(body, generateEtag);
	}
	notFound(body, generateEtag) {
		this.status(ResponseStatus.NotFound);
		return this.send(body, generateEtag);
	}
	methodNotAllowed(body, generateEtag) {
		this.status(ResponseStatus.MethodNotAllowed);
		return this.send(body, generateEtag);
	}
	notAcceptable(body, generateEtag) {
		this.status(ResponseStatus.NotAcceptable);
		return this.send(body, generateEtag);
	}
	proxyAuthenticationRequired(body, generateEtag) {
		this.status(ResponseStatus.ProxyAuthenticationRequired);
		return this.send(body, generateEtag);
	}
	requestTimeout(body, generateEtag) {
		this.status(ResponseStatus.RequestTimeout);
		return this.send(body, generateEtag);
	}
	conflict(body, generateEtag) {
		this.status(ResponseStatus.Conflict);
		return this.send(body, generateEtag);
	}
	gone(body, generateEtag) {
		this.status(ResponseStatus.Gone);
		return this.send(body, generateEtag);
	}
	lengthRequired(body, generateEtag) {
		this.status(ResponseStatus.LengthRequired);
		return this.send(body, generateEtag);
	}
	preconditionFailed(body, generateEtag) {
		this.status(ResponseStatus.PreconditionFailed);
		return this.send(body, generateEtag);
	}
	requestEntityTooLarge(body, generateEtag) {
		this.status(ResponseStatus.PayloadTooLarge);
		return this.send(body, generateEtag);
	}
	requestUriTooLong(body, generateEtag) {
		this.status(ResponseStatus.URITooLong);
		return this.send(body, generateEtag);
	}
	unsupportedMediaType(body, generateEtag) {
		this.status(ResponseStatus.UnsupportedMediaType);
		return this.send(body, generateEtag);
	}
	requestedRangeNotSatisfiable(body, generateEtag) {
		this.status(ResponseStatus.RangeNotSatisfiable);
		return this.send(body, generateEtag);
	}
	expectationFailed(body, generateEtag) {
		this.status(ResponseStatus.ExpectationFailed);
		return this.send(body, generateEtag);
	}
	unprocessableEntity(body, generateEtag) {
		this.status(ResponseStatus.UnprocessableEntity);
		return this.send(body, generateEtag);
	}
	tooManyRequests(body, generateEtag) {
		this.status(ResponseStatus.TooManyRequests);
		return this.send(body, generateEtag);
	}
	internalServerError(body, generateEtag) {
		this.status(ResponseStatus.InternalServerError);
		return this.send(body, generateEtag);
	}
	notImplemented(body, generateEtag) {
		this.status(ResponseStatus.NotImplemented);
		return this.send(body, generateEtag);
	}
	badGateway(body, generateEtag) {
		this.status(ResponseStatus.BadGateway);
		return this.send(body, generateEtag);
	}
	serviceUnavailable(body, generateEtag) {
		this.status(ResponseStatus.ServiceUnavailable);
		return this.send(body, generateEtag);
	}
	gatewayTimeout(body, generateEtag) {
		this.status(ResponseStatus.GatewayTimeout);
		return this.send(body, generateEtag);
	}
	httpVersionNotSupported(body, generateEtag) {
		this.status(ResponseStatus.HTTPVersionNotSupported);
		return this.send(body, generateEtag);
	}
};
const asyncLocalStorage = {
	isEnabled: false,
	storage: null,
	create() {
		this.isEnabled = true;
		this.storage = new AsyncLocalStorage();
		return this.storage;
	},
	destroy() {
		this.isEnabled = false;
		this.storage = null;
	}
};
var HttpContext = class extends Macroable {
	static get usingAsyncLocalStorage() {
		return asyncLocalStorage.isEnabled;
	}
	static get() {
		if (!this.usingAsyncLocalStorage || !asyncLocalStorage.storage) return null;
		return asyncLocalStorage.storage.getStore() || null;
	}
	static getOrFail() {
		if (!this.usingAsyncLocalStorage || !asyncLocalStorage.storage) throw new RuntimeException("HTTP context is not available. Enable \"useAsyncLocalStorage\" inside \"config/app.ts\" file");
		const store = this.get();
		if (!store) throw new RuntimeException("Http context is not available outside of an HTTP request");
		return store;
	}
	static runOutsideContext(callback, ...args) {
		if (!asyncLocalStorage.storage) return callback(...args);
		return asyncLocalStorage.storage.exit(callback, ...args);
	}
	route;
	routeKey;
	params = {};
	subdomains = {};
	constructor(request, response, logger, containerResolver) {
		super();
		this.request = request;
		this.response = response;
		this.logger = logger;
		this.containerResolver = containerResolver;
		this.request.ctx = this;
		this.response.ctx = this;
	}
	/* c8 ignore next 3 */
	inspect() {
		return inspect(this, false, 1, true);
	}
};
function routeFinder(router, resolver, ctx, errorResponder) {
	return function() {
		const url = ctx.request.url();
		const method = ctx.request.method();
		const hostname = router.usingDomains ? ctx.request.hostname() : void 0;
		const route = router.match(url, method, ctx.request.parsedUrl.shouldDecodeParam, hostname);
		if (route) {
			ctx.params = route.params;
			ctx.subdomains = route.subdomains;
			ctx.route = route.route;
			ctx.routeKey = route.routeKey;
			return route.route.execute(route.route, resolver, ctx, errorResponder);
		}
		return Promise.reject(new E_ROUTE_NOT_FOUND([method, url]));
	};
}
function writeResponse(ctx) {
	return function() {
		try {
			ctx.response.finish();
		} catch (error) {
			ctx.logger.fatal({ err: error }, "Response serialization failed");
			ctx.response.internalServerError(error.message);
			ctx.response.finish();
		}
	};
}
function middlewareHandler(resolver, ctx) {
	return function(fn, next) {
		debug_default("executing middleware %s", fn.name);
		return httpMiddleware.tracePromise(fn.handle, httpMiddleware.hasSubscribers ? { middleware: fn } : void 0, void 0, resolver, ctx, next);
	};
}
var Server = class {
	#booted = false;
	#defaultErrorHandler = {
		report() {},
		handle(error, ctx) {
			ctx.response.status(error.status || 500).send(error.message || "Internal server error");
		}
	};
	#logger;
	#errorHandler;
	#resolvedErrorHandler = this.#defaultErrorHandler;
	#emitter;
	#app;
	#encryption;
	#config;
	#qsParser;
	#serverMiddlewareStack;
	#router;
	#nodeHttpServer;
	#middleware = [];
	#requestErrorResponder = async (error, ctx) => {
		await this.#resolvedErrorHandler.report(error, ctx);
		return httpExceptionHandler.tracePromise(this.#resolvedErrorHandler.handle, void 0, this.#resolvedErrorHandler, error, ctx);
	};
	get booted() {
		return this.#booted;
	}
	get usingAsyncLocalStorage() {
		return asyncLocalStorage.isEnabled;
	}
	constructor(app, encryption, emitter, logger, config) {
		this.#app = app;
		this.#emitter = emitter;
		this.#config = config;
		this.#logger = logger;
		this.#encryption = encryption;
		this.#qsParser = new Qs(this.#config.qs);
		this.#router = new Router(this.#app, this.#encryption, this.#qsParser);
		this.#createAsyncLocalStore();
		debug_default("server config: %O", this.#config);
	}
	#createAsyncLocalStore() {
		if (this.#config.useAsyncLocalStorage) {
			debug_default("creating ALS store for HTTP context");
			asyncLocalStorage.create();
		} else asyncLocalStorage.destroy();
	}
	#createServerMiddlewareStack() {
		this.#serverMiddlewareStack = new Middleware();
		this.#middleware.forEach((middleware) => this.#serverMiddlewareStack.add(middleware));
		this.#serverMiddlewareStack.freeze();
		this.#middleware = [];
	}
	#handleRequest(ctx, resolver) {
		return this.#serverMiddlewareStack.runner().errorHandler((error) => this.#requestErrorResponder(error, ctx)).finalHandler(routeFinder(this.#router, resolver, ctx, this.#requestErrorResponder)).run(middlewareHandler(resolver, ctx)).catch((error) => {
			ctx.logger.fatal({ err: error }, "Exception raised by error handler");
			return this.#defaultErrorHandler.handle(error, ctx);
		}).finally(writeResponse(ctx));
	}
	pipeline(middleware) {
		const middlewareStack = new Middleware();
		middleware.forEach((one) => {
			middlewareStack.add({
				reference: one,
				...moduleCaller(one, "handle").toHandleMethod()
			});
		});
		middlewareStack.freeze();
		const stackRunner = middlewareStack.runner();
		return {
			finalHandler(handler) {
				stackRunner.finalHandler(handler);
				return this;
			},
			errorHandler(handler) {
				stackRunner.errorHandler(handler);
				return this;
			},
			run(ctx) {
				return stackRunner.run((handler, next) => {
					return handler.handle(ctx.containerResolver, ctx, next);
				});
			}
		};
	}
	use(middleware) {
		middleware.forEach((one) => this.#middleware.push({
			reference: one,
			...moduleImporter(one, "handle").toHandleMethod()
		}));
		return this;
	}
	errorHandler(handler) {
		this.#errorHandler = handler;
		return this;
	}
	async boot() {
		if (this.#booted) return;
		debug_default("booting HTTP server");
		this.#createServerMiddlewareStack();
		this.#router.commit();
		if (this.#errorHandler) {
			if (debug_default.enabled) debug_default("using custom error handler \"%s\"", this.#errorHandler);
			const moduleExports = await this.#errorHandler();
			this.#resolvedErrorHandler = await this.#app.container.make(moduleExports.default);
		}
		this.#booted = true;
	}
	setNodeServer(server) {
		server.timeout = this.#config.timeout ?? server.timeout;
		server.keepAliveTimeout = this.#config.keepAliveTimeout ?? server.keepAliveTimeout;
		server.headersTimeout = this.#config.headersTimeout ?? server.headersTimeout;
		server.requestTimeout = this.#config.requestTimeout ?? server.requestTimeout;
		this.#nodeHttpServer = server;
	}
	getNodeServer() {
		return this.#nodeHttpServer;
	}
	getRouter() {
		return this.#router;
	}
	createRequest(req, res) {
		return new HttpRequest(req, res, this.#encryption, this.#config, this.#qsParser);
	}
	createResponse(req, res) {
		return new HttpResponse(req, res, this.#encryption, this.#config, this.#router, this.#qsParser);
	}
	createHttpContext(request, response, resolver) {
		return new HttpContext(request, response, this.#logger.child({ request_id: request.id() }), resolver);
	}
	getMiddlewareList() {
		return this.#serverMiddlewareStack ? Array.from(this.#serverMiddlewareStack.all()) : [...this.#middleware];
	}
	handle(req, res) {
		const startTime = this.#emitter.hasListeners("http:request_completed") ? process.hrtime() : null;
		const resolver = this.#app.container.createResolver();
		const ctx = this.createHttpContext(this.createRequest(req, res), this.createResponse(req, res), resolver);
		if (startTime) onFinished(res, () => {
			this.#emitter.emit("http:request_completed", {
				ctx,
				duration: process.hrtime(startTime)
			});
		});
		if (this.usingAsyncLocalStorage) return asyncLocalStorage.storage.run(ctx, () => httpRequest.tracePromise(this.#handleRequest, httpRequest.hasSubscribers ? { ctx } : void 0, this, ctx, resolver));
		return httpRequest.tracePromise(this.#handleRequest, httpRequest.hasSubscribers ? { ctx } : void 0, this, ctx, resolver);
	}
};
function defineConfig(config) {
	const { trustProxy, ...rest } = config;
	const defaults = {
		allowMethodSpoofing: false,
		trustProxy: proxyAddr.compile("loopback"),
		subdomainOffset: 2,
		generateRequestId: !!config.createRequestId,
		createRequestId() {
			return crypto.randomUUID();
		},
		serializeJSON: safeStringify,
		useAsyncLocalStorage: false,
		etag: false,
		jsonpCallbackName: "callback",
		cookie: {
			maxAge: "2h",
			path: "/",
			httpOnly: true,
			secure: true,
			sameSite: "lax"
		},
		qs: {
			parse: {
				depth: 5,
				parameterLimit: 1e3,
				allowSparse: false,
				arrayLimit: 20,
				comma: true
			},
			stringify: {
				encode: true,
				encodeValuesOnly: false,
				arrayFormat: "indices",
				skipNulls: false
			}
		}
	};
	const normalizedConfig = lodash.merge({}, defaults, rest);
	if (normalizedConfig.cookie.maxAge) normalizedConfig.cookie.maxAge = string.seconds.parse(normalizedConfig.cookie.maxAge);
	if (typeof trustProxy === "boolean") {
		const tpValue = trustProxy;
		normalizedConfig.trustProxy = (_, __) => tpValue;
	} else if (typeof trustProxy === "string") {
		const tpValue = trustProxy;
		normalizedConfig.trustProxy = proxyAddr.compile(tpValue);
	} else if (trustProxy) normalizedConfig.trustProxy = trustProxy;
	return normalizedConfig;
}
export { Qs as _, CookieSerializer as a, HttpRequest as c, Redirect as d, E_CANNOT_LOOKUP_ROUTE as f, errors_exports as g, E_ROUTE_NOT_FOUND as h, HttpResponse as i, CookieParser as l, E_HTTP_REQUEST_ABORTED as m, Server as n, ResponseStatus as o, E_HTTP_EXCEPTION as p, HttpContext as r, Router as s, defineConfig as t, CookieClient as u };
