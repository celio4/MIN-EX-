import type { Colors } from '@poppinss/colors/types';
import { type REPLServer, type ReplOptions } from 'node:repl';
import type { MethodCallback, MethodOptions, Compiler } from './types.ts';
/**
 * A REPL (Read-Eval-Print Loop) server implementation that provides an interactive
 * command line interface for executing JavaScript/TypeScript code with custom methods
 * and context management.
 *
 * @example
 * const repl = new Repl({ historyFilePath: '.repl_history' })
 *
 * repl.addMethod('greet', (repl, name) => `Hello ${name}!`, {
 *   description: 'Greets a person',
 *   usage: 'greet (name)'
 * })
 *
 * repl.start({ myVar: 'Hello World' })
 */
export declare class Repl {
    #private;
    /**
     * Colors reference
     */
    colors: Colors;
    /**
     * Reference to the repl server. Available after the `start` method
     * is invoked
     */
    server?: REPLServer;
    /**
     * Creates a new REPL instance with optional configuration
     *
     * @param options - Configuration options for the REPL
     * @param options.compiler - Custom compiler for transforming user input
     * @param options.historyFilePath - Path to store command history
     *
     * @example
     * const repl = new Repl({
     *   historyFilePath: '.repl_history',
     *   compiler: myTypeScriptCompiler
     * })
     */
    constructor(options?: {
        compiler?: Compiler;
        historyFilePath?: string;
    } & ReplOptions);
    /**
     * Notify by writing to the console
     *
     * @param message - The message to display
     *
     * @example
     * repl.notify('Server connected successfully')
     */
    notify(message: string): void;
    /**
     * Register a callback to be invoked once the server is ready
     *
     * @param callback - Function to call when the REPL is ready
     *
     * @example
     * repl.ready((repl) => {
     *   repl.notify('REPL is ready!')
     * })
     */
    ready(callback: (repl: Repl) => void): this;
    /**
     * Register a custom loader function to be added to the context
     *
     * @param name - The name of the method
     * @param handler - The function to execute
     * @param options - Optional configuration for the method
     *
     * @example
     * repl.addMethod('greet', (repl, name) => {
     *   return `Hello ${name}!`
     * }, {
     *   description: 'Greets a person by name',
     *   usage: 'greet (name)'
     * })
     */
    addMethod(name: string, handler: MethodCallback, options?: MethodOptions): this;
    /**
     * Returns the collection of registered methods
     *
     * @example
     * const methods = repl.getMethods()
     * console.log(Object.keys(methods)) // ['clear', 'p', 'myCustomMethod']
     */
    getMethods(): {
        [name: string]: {
            handler: MethodCallback;
            options: MethodOptions & {
                width: number;
            };
        };
    };
    /**
     * Register a compiler. Make sure register the compiler before
     * calling the start method
     *
     * @param compiler - The compiler instance to use for transforming code
     *
     * @example
     * const tsCompiler = {
     *   compile: (code, filename) => ts.transpile(code),
     *   supportsTypescript: true
     * }
     * repl.useCompiler(tsCompiler)
     */
    useCompiler(compiler: Compiler): this;
    /**
     * Start the REPL server
     *
     * @param context - Optional initial context to populate the REPL with
     *
     * @example
     * repl.start({
     *   db: databaseConnection,
     *   utils: myUtilities
     * })
     */
    start(context?: Record<string, any>): this;
}
