import "../chunk-iKc69rpz.js";
import "../debug-CGQmxzGt.js";
import { t as app_exports } from "../modules/app.js";
import { t as configProvider } from "../config_provider-FIAUgvae.js";
import { t as config_exports } from "../modules/config.js";
import { t as events_exports } from "../modules/events.js";
import { t as logger_exports } from "../modules/logger.js";
import { t as Dumper } from "../dumper-BBgqFX5a.js";
import { RuntimeException } from "../src/exceptions.js";
import { t as main_exports } from "../main-DN2qEEg5.js";
import "../errors-CrCO-k44.js";
import "../define_config-0oHaj43l.js";
import { Encryption } from "../modules/encryption/main.js";
import bodyparser_middleware_default from "../modules/bodyparser/bodyparser_middleware.js";
import { dirname } from "node:path";
import { mkdir, writeFile } from "node:fs/promises";
var AppServiceProvider = class {
	constructor(app) {
		this.app = app;
	}
	registerTestUtils() {
		this.app.container.singleton("testUtils", async () => {
			const { TestUtils } = await import("../src/test_utils/main.js");
			return new TestUtils(this.app);
		});
	}
	registerAce() {
		this.app.container.singleton("ace", async () => {
			const { createAceKernel } = await import("../create_kernel-BD0Iqi8e.js");
			return createAceKernel(this.app);
		});
	}
	registerApp() {
		this.app.container.singleton(app_exports.Application, () => this.app);
		this.app.container.alias("app", app_exports.Application);
	}
	registerLogger() {
		this.app.container.singleton(logger_exports.Logger, async (resolver) => {
			return (await resolver.make("logger")).use();
		});
	}
	registerLoggerManager() {
		this.app.container.singleton("logger", async () => {
			const { LoggerManager } = await import("../modules/logger.js");
			return new LoggerManager(this.app.config.get("logger"));
		});
	}
	registerConfig() {
		this.app.container.singleton(config_exports.Config, () => this.app.config);
		this.app.container.alias("config", config_exports.Config);
	}
	registerEmitter() {
		this.app.container.singleton(events_exports.Emitter, async () => {
			return new events_exports.Emitter(this.app);
		});
		this.app.container.alias("emitter", events_exports.Emitter);
	}
	registerEncryption() {
		this.app.container.singleton("encryption", async () => {
			const encryptionConfigProvider = this.app.config.get("encryption");
			const config = await configProvider.resolve(this.app, encryptionConfigProvider);
			if (!config) throw new RuntimeException("Invalid \"config/encryption.ts\" file. Make sure you are using the \"defineConfig\" method");
			const { EncryptionManager } = await import("../modules/encryption/main.js");
			return new EncryptionManager(config);
		});
		this.app.container.singleton(Encryption, async (resolver) => {
			return (await resolver.make("encryption")).use();
		});
	}
	registerServer() {
		this.app.container.singleton(main_exports.Server, async (resolver) => {
			const encryption = await resolver.make(Encryption);
			const emitter = await resolver.make("emitter");
			const logger = await resolver.make("logger");
			const config = this.app.config.get("app.http");
			return new main_exports.Server(this.app, encryption, emitter, logger, config);
		});
		this.app.container.alias("server", main_exports.Server);
	}
	registerRouter() {
		this.app.container.singleton(main_exports.Router, async (resolver) => {
			return (await resolver.make("server")).getRouter();
		});
		this.app.container.alias("router", main_exports.Router);
	}
	registerBodyParserMiddleware() {
		this.app.container.singleton(bodyparser_middleware_default, () => {
			return new bodyparser_middleware_default(this.app.config.get("bodyparser"), this.app.experimentalFlags);
		});
	}
	registerDumper() {
		this.app.container.singleton(Dumper, async () => {
			const config = this.app.config.get("app.dumper", {});
			const dumper = new Dumper(this.app);
			if (config.html) dumper.configureHtmlOutput(config.html);
			if (config.console) dumper.configureAnsiOutput(config.console);
			return dumper;
		});
		this.app.container.alias("dumper", Dumper);
	}
	async emitRoutes(router) {
		try {
			const { routes, imports, types } = router.generateTypes(2);
			const routesTypesPath = this.app.generatedServerPath("routes.d.ts");
			const routesJsonPath = this.app.generatedServerPath("routes.json");
			await mkdir(dirname(routesTypesPath), { recursive: true });
			await Promise.all([writeFile(routesTypesPath, [
				`import '@adonisjs/core/types/http'`,
				...imports,
				"",
				...types,
				"",
				"export type ScannedRoutes = {",
				routes,
				"}",
				`declare module '@adonisjs/core/types/http' {`,
				"  export interface RoutesList extends ScannedRoutes {}",
				"}"
			].join("\n")), writeFile(routesJsonPath, JSON.stringify(router.toJSON()))]);
			this.app.notify({
				isAdonisJS: true,
				routesFileLocation: routesJsonPath
			});
		} catch (error) {
			console.error("Unable to generate routes types file due to the following error. This won't impact the dev-server");
			console.error(error);
		}
	}
	register() {
		this.registerApp();
		this.registerAce();
		this.registerDumper();
		this.registerLoggerManager();
		this.registerLogger();
		this.registerConfig();
		this.registerEmitter();
		this.registerEncryption();
		this.registerTestUtils();
		this.registerServer();
		this.registerRouter();
		this.registerBodyParserMiddleware();
	}
	async boot() {
		events_exports.BaseEvent.useEmitter(await this.app.container.make("emitter"));
	}
	async ready() {
		if (!this.app.inProduction) {
			const router = await this.app.container.make("router");
			if (router.commited) await this.emitRoutes(router);
		}
	}
};
export { AppServiceProvider as default };
