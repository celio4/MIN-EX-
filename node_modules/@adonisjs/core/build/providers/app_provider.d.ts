import { Router } from '../modules/http/main.ts';
import type { ApplicationService } from '../src/types.ts';
/**
 * The Application Service provider registers all the baseline
 * features required to run the framework.
 *
 * This provider handles the registration of core services including:
 * - Application instance
 * - Logger and logger manager
 * - Configuration
 * - Event emitter
 * - Encryption service
 * - HTTP server and router
 * - Body parser middleware
 * - Dumper for debugging
 * - Test utilities and ACE kernel
 *
 * @example
 * const provider = new AppServiceProvider(app)
 * provider.register()
 * await provider.boot()
 * await provider.ready()
 */
export default class AppServiceProvider {
    protected app: ApplicationService;
    /**
     * Application service provider constructor
     *
     * @param app - The application service instance
     */
    constructor(app: ApplicationService);
    /**
     * Registers test utils with the container
     *
     * Creates a singleton binding for 'testUtils' that lazily imports
     * and instantiates the TestUtils class when first accessed.
     *
     * @example
     * const testUtils = await app.container.make('testUtils')
     * testUtils.createHttpContext()
     */
    protected registerTestUtils(): void;
    /**
     * Registers ace with the container
     *
     * Creates a singleton binding for 'ace' that lazily creates
     * the ACE kernel for command-line interface functionality.
     *
     * @example
     * const ace = await app.container.make('ace')
     * await ace.exec('make:controller', ['UserController'])
     */
    protected registerAce(): void;
    /**
     * Registers the application to the container
     *
     * Binds the application instance as both a class binding and an alias.
     * This allows access to the app instance throughout the container.
     *
     * @example
     * const app = await container.make('app')
     * const appPath = app.makePath('tmp')
     */
    protected registerApp(): void;
    /**
     * Registers the logger class to resolve the default logger
     *
     * Creates a singleton binding for the Logger class that resolves
     * the default logger instance from the logger manager.
     *
     * @example
     * const logger = await container.make(Logger)
     * logger.info('Application started')
     */
    protected registerLogger(): void;
    /**
     * Registers the logger manager to the container
     *
     * Creates a singleton binding for 'logger' that instantiates
     * the LoggerManager with configuration from config/logger.ts
     *
     * @example
     * const loggerManager = await container.make('logger')
     * const fileLogger = loggerManager.use('file')
     */
    protected registerLoggerManager(): void;
    /**
     * Registers the config to the container
     *
     * Binds the application's config instance as both a class binding
     * and an alias, allowing access to configuration values.
     *
     * @example
     * const config = await container.make('config')
     * const appKey = config.get('app.appKey')
     */
    protected registerConfig(): void;
    /**
     * Registers emitter service to the container
     *
     * Creates a singleton binding for the event emitter that handles
     * application-wide event dispatching and listening.
     *
     * @example
     * const emitter = await container.make('emitter')
     * emitter.emit('user:created', { userId: 123 })
     */
    protected registerEmitter(): void;
    /**
     * Registers the encryption service with the container
     *
     * Creates singleton bindings for both the encryption manager and
     * the default encryption instance. Resolves configuration from
     * config/encryption.ts file.
     *
     * @example
     * const encryption = await container.make('encryption')
     * const encrypted = encryption.encrypt('secret-data')
     */
    protected registerEncryption(): void;
    /**
     * Registers the HTTP server with the container as a singleton
     *
     * Creates a singleton binding for the HTTP server that handles
     * incoming requests, with dependencies on encryption, emitter,
     * logger, and HTTP configuration.
     *
     * @example
     * const server = await container.make('server')
     * server.start()
     */
    protected registerServer(): void;
    /**
     * Registers router with the container as a singleton
     *
     * Creates a singleton binding for the router by getting it from
     * the HTTP server instance. The router handles URL routing.
     *
     * @example
     * const router = await container.make('router')
     * router.get('/', ({ response }) => response.send('Hello'))
     */
    protected registerRouter(): void;
    /**
     * Self construct bodyparser middleware class, since it needs
     * config that cannot be resolved by the container
     *
     * Binds the BodyParserMiddleware with bodyparser configuration
     * and experimental flags for parsing request bodies.
     *
     * @example
     * const middleware = await container.make(BodyParserMiddleware)
     * await middleware.handle(ctx, next)
     */
    protected registerBodyParserMiddleware(): void;
    /**
     * Registeres singleton instance of the "Dumper" module configured
     * via the "config/app.ts" file.
     *
     * The dumper is used for debugging and variable inspection with
     * configurable HTML and console output formats.
     *
     * @example
     * const dumper = await container.make('dumper')
     * dumper.dump({ user: { name: 'John' } })
     */
    protected registerDumper(): void;
    /**
     * Generates TypeScript type definitions and JSON representation of routes
     *
     * Creates route type definitions for better IDE support and a JSON file
     * containing all registered routes. This is used in development mode for
     * tooling integration and type-safety.
     *
     * @param router - The router instance containing registered routes
     *
     * @example
     * const router = await container.make('router')
     * await this.emitRoutes(router)
     * // Generates .adonisjs/server/routes.d.ts and routes.json
     */
    protected emitRoutes(router: Router): Promise<void>;
    /**
     * Registers bindings
     *
     * Called during the application bootstrap phase to register
     * all core service bindings with the IoC container.
     *
     * @example
     * const provider = new AppServiceProvider(app)
     * provider.register() // Registers all core services
     */
    register(): void;
    /**
     * Boot the service provider
     *
     * Called after all providers have been registered. Sets up
     * event emitter for BaseEvent and adds transform macro to HttpContext.
     *
     * @example
     * await provider.boot()
     * // Now HttpContext has transform method available
     */
    boot(): Promise<void>;
    /**
     * Called when the application is ready
     *
     * In non-production environments, generates route types and
     * JSON files for development tooling when router is committed.
     *
     * @example
     * await provider.ready()
     * // Route types and JSON generated in development
     */
    ready(): Promise<void>;
}
