import { f as BaseCommand, l as flags, o as args, s as cliHelpers } from "../../main-MBAMnmJb.js";
import { t as __decorate } from "../../decorate-DmrZA614.js";
import stringWidth from "string-width";
import { middlewareInfo, routeInfo } from "@adonisjs/http-server/helpers";
var RoutesListFormatter = class {
	#router;
	#colors;
	#table;
	#options;
	#filters;
	constructor(router, ui, options, filters) {
		this.#router = router;
		this.#colors = ui.colors;
		this.#table = ui.table;
		this.#filters = filters;
		this.#options = options;
		this.#router.commit();
	}
	#isAllowedByFilters(route) {
		let allowRoute = true;
		if (this.#filters.middleware) allowRoute = this.#filters.middleware.every((name) => {
			if (name === "*") return route.middleware.length > 0;
			return route.middleware.find((middleware) => middleware.name === name);
		});
		if (allowRoute && this.#filters.ignoreMiddleware) allowRoute = this.#filters.ignoreMiddleware.every((name) => {
			if (name === "*") return route.middleware.length === 0;
			return !route.middleware.find((middleware) => middleware.name === name);
		});
		if (!this.#filters.match) return allowRoute;
		if (route.name.includes(this.#filters.match)) return true;
		if (route.pattern.includes(this.#filters.match)) return true;
		if (route.handler.type === "controller" ? route.handler.moduleNameOrPath.includes(this.#filters.match) : route.handler.name.includes(this.#filters.match)) return true;
		return false;
	}
	async #serializeRoute(route) {
		let methods = route.methods;
		if (!this.#options.displayHeadRoutes) methods = methods.filter((method) => method !== "HEAD");
		const middlewareList = await Promise.all([...route.middleware.all()].map((middleware) => {
			return middlewareInfo(middleware);
		}));
		return {
			name: route.name || "",
			pattern: route.pattern,
			methods,
			handler: await routeInfo(route),
			middleware: middlewareList.filter((info) => info.type !== "global")
		};
	}
	#formatRouteMethod(method) {
		return this.#colors.dim(method);
	}
	#formatRoutePattern(route) {
		const pattern = this.#router.parsePattern(route.pattern).map((token) => {
			if (token.type === 1) return this.#colors.yellow(`:${token.val}`);
			if (token.type === 3) return this.#colors.yellow(`:${token.val}?`);
			if (token.type === 2) return this.#colors.red(token.val);
			return token.val;
		}).join("/");
		return `${pattern === "/" ? pattern : `/${pattern}`}${route.name ? ` ${this.#colors.dim(`(${route.name})`)}` : ""} `;
	}
	#formatControllerName(route) {
		return route.handler.type === "controller" ? ` ${this.#colors.cyan(route.handler.moduleNameOrPath)}.` : "";
	}
	#formatAction(route) {
		if (route.handler.type === "controller") return `${this.#colors.cyan(route.handler.method)}`;
		const functionName = ` ${this.#colors.cyan(route.handler.name)}`;
		if (route.handler.args) return ` ${functionName}${this.#colors.dim(`(${route.handler.args})`)}`;
		return functionName;
	}
	#formatMiddleware(route, mode = "normal") {
		if (mode === "compact" && route.middleware.length > 3) {
			const firstMiddleware = route.middleware[0].name;
			const secondMiddleware = route.middleware[1].name;
			const diff = route.middleware.length - 2;
			return this.#colors.dim(`${firstMiddleware}, ${secondMiddleware}, and ${diff} more`);
		}
		return this.#colors.dim(`${route.middleware.map((one) => one.name).filter((one) => one).join(", ")}`);
	}
	#formatDomainHeadline(domain) {
		if (domain !== "root") return cliHelpers.justify([`${this.#colors.dim("..")} ${this.#colors.green(domain)} `], {
			maxWidth: this.#options.maxPrettyPrintWidth || cliHelpers.TERMINAL_SIZE,
			paddingChar: this.#colors.dim(".")
		})[0];
		return "";
	}
	#justifyListTables(tables) {
		return tables.map((table) => {
			const methods = table.rows.map((columns) => columns[0]);
			const largestMethodsLength = Math.max(...methods.map((method) => stringWidth(method)));
			const formattedMethods = cliHelpers.justify(methods, { maxWidth: largestMethodsLength });
			const patterns = table.rows.map((columns) => columns[1]);
			const largestPatternLength = Math.max(...patterns.map((pattern) => stringWidth(pattern)));
			const formattedPatterns = cliHelpers.justify(patterns, {
				maxWidth: largestPatternLength,
				paddingChar: this.#colors.dim(".")
			});
			const middleware = table.rows.map((columns) => columns[3]);
			const largestMiddlewareLength = Math.max(...middleware.map((one) => stringWidth(one)));
			const formattedMiddleware = cliHelpers.justify(middleware, {
				maxWidth: largestMiddlewareLength,
				align: "right",
				paddingChar: " "
			});
			const controllers = table.rows.map((columns) => columns[2]);
			const largestControllerLength = (this.#options.maxPrettyPrintWidth || cliHelpers.TERMINAL_SIZE) - (largestPatternLength + largestMethodsLength + largestMiddlewareLength);
			const formattedControllers = cliHelpers.truncate(cliHelpers.justify(controllers, {
				maxWidth: largestControllerLength,
				align: "right",
				paddingChar: this.#colors.dim(".")
			}), { maxWidth: largestControllerLength });
			return {
				heading: table.heading,
				rows: formattedMethods.reduce((result, method, index) => {
					result.push(`${method}${formattedPatterns[index]}${formattedControllers[index]}${formattedMiddleware[index]}`);
					return result;
				}, [])
			};
		});
	}
	async formatAsJSON() {
		const routes = this.#router.toJSON();
		const domains = Object.keys(routes);
		let routesJSON = [];
		for (let domain of domains) {
			const domainRoutes = await Promise.all(routes[domain].map((route) => this.#serializeRoute(route)));
			routesJSON.push({
				domain,
				routes: domainRoutes.filter((route) => this.#isAllowedByFilters(route))
			});
		}
		return routesJSON;
	}
	async formatAsAnsiList() {
		const routes = this.#router.toJSON();
		const domains = Object.keys(routes);
		const tables = [];
		for (let domain of domains) {
			const list = {
				heading: this.#formatDomainHeadline(domain),
				rows: [[
					this.#colors.dim("METHOD"),
					` ${this.#colors.dim("ROUTE")} `,
					` ${this.#colors.dim("HANDLER")}`,
					` ${this.#colors.dim("MIDDLEWARE")}`
				]]
			};
			for (let route of routes[domain]) {
				const serializedRoute = await this.#serializeRoute(route);
				if (this.#isAllowedByFilters(serializedRoute)) serializedRoute.methods.forEach((method) => {
					list.rows.push([
						this.#formatRouteMethod(method),
						` ${this.#formatRoutePattern(serializedRoute)}`,
						`${this.#formatControllerName(serializedRoute)}${this.#formatAction(serializedRoute)}`,
						` ${this.#formatMiddleware(serializedRoute, "compact")}`
					]);
				});
			}
			tables.push(list);
		}
		return this.#justifyListTables(tables);
	}
	async formatAsAnsiTable() {
		const routes = this.#router.toJSON();
		const domains = Object.keys(routes);
		const tables = [];
		for (let domain of domains) {
			const list = {
				heading: this.#formatDomainHeadline(domain),
				table: this.#table().fullWidth().fluidColumnIndex(2).head([
					this.#colors.dim("METHOD"),
					this.#colors.dim("ROUTE"),
					{
						hAlign: "right",
						content: this.#colors.dim("HANDLER")
					},
					{
						content: this.#colors.dim("MIDDLEWARE"),
						hAlign: "right"
					}
				])
			};
			for (let route of routes[domain]) {
				const serializedRoute = await this.#serializeRoute(route);
				if (this.#isAllowedByFilters(serializedRoute)) serializedRoute.methods.forEach((method) => {
					list.table.row([
						this.#formatRouteMethod(method),
						this.#formatRoutePattern(serializedRoute),
						{
							content: `${this.#formatControllerName(serializedRoute)}${this.#formatAction(serializedRoute)}`,
							hAlign: "right"
						},
						{
							content: this.#formatMiddleware(serializedRoute),
							hAlign: "right"
						}
					]);
				});
			}
			tables.push(list);
		}
		return tables;
	}
};
var ListRoutes = class extends BaseCommand {
	static commandName = "list:routes";
	static description = "List application routes. This command will boot the application in the console environment";
	static options = { startApp: true };
	async run() {
		const formatter = new RoutesListFormatter(await this.app.container.make("router"), this.ui, {}, {
			ignoreMiddleware: this.ignoreMiddleware,
			middleware: this.middleware,
			match: this.match
		});
		if (this.json) {
			this.logger.log(JSON.stringify(await formatter.formatAsJSON(), null, 2));
			return;
		}
		if (this.table) {
			(await formatter.formatAsAnsiTable()).forEach((table) => {
				this.logger.log("");
				if (table.heading) {
					this.logger.log(table.heading);
					this.logger.log("");
				}
				table.table.render();
			});
			return;
		}
		(await formatter.formatAsAnsiList()).forEach((item) => {
			this.logger.log("");
			if (item.heading) {
				this.logger.log(item.heading);
				this.logger.log("");
			}
			this.logger.log(item.rows.join("\n"));
		});
	}
};
__decorate([args.string({
	description: "Find routes matching the given keyword. Route name, pattern and controller name will be searched against the keyword",
	required: false
})], ListRoutes.prototype, "match", void 0);
__decorate([flags.array({ description: "View routes that includes all the mentioned middleware names. Use * to see routes that are using one or more middleware" })], ListRoutes.prototype, "middleware", void 0);
__decorate([flags.array({ description: "View routes that does not include all the mentioned middleware names. Use * to see routes that are using zero middleware" })], ListRoutes.prototype, "ignoreMiddleware", void 0);
__decorate([flags.boolean({ description: "Get routes list as a JSON string" })], ListRoutes.prototype, "json", void 0);
__decorate([flags.boolean({ description: "View list of routes as a table" })], ListRoutes.prototype, "table", void 0);
export { ListRoutes as default };
