import { t as importAssembler } from "../utils-rRkbAPnP.js";
import { f as BaseCommand, l as flags, o as args } from "../main-MBAMnmJb.js";
import { t as __decorate } from "../decorate-DmrZA614.js";
var Test = class extends BaseCommand {
	static commandName = "test";
	static description = "Run tests along with the file watcher to re-run tests on file change";
	static options = {
		allowUnknownFlags: true,
		staysAlive: true
	};
	#logMissingDevelopmentDependency(dependency) {
		this.logger.error([
			`Cannot find package "${dependency}"`,
			"",
			`The "${dependency}" package is a development dependency and therefore you should run tests with development dependencies installed.`,
			"",
			"If you are run tests inside a CI, make sure the NODE_ENV is set to \"development\""
		].join("\n"));
	}
	#getPassthroughFlags() {
		return this.parsed.unknownFlags.map((flag) => {
			const value = this.parsed.flags[flag];
			if (value === true) return [`--${flag}`];
			if (Array.isArray(value)) return value.map((v) => [`--${flag}`, v]);
			return [`--${flag}`, value];
		}).flat(2);
	}
	async run() {
		process.env.NODE_ENV = "test";
		const assembler = await importAssembler(this.app);
		if (!assembler) {
			this.#logMissingDevelopmentDependency("@adonisjs/assembler");
			this.exitCode = 1;
			return;
		}
		this.testsRunner = new assembler.TestRunner(this.app.appRoot, {
			clearScreen: this.clear === false ? false : true,
			nodeArgs: this.parsed.nodeArgs,
			scriptArgs: this.#getPassthroughFlags(),
			filters: {
				suites: this.suites,
				files: this.files,
				groups: this.groups,
				tags: this.tags,
				tests: this.tests
			},
			failed: this.failed,
			retries: this.retries,
			timeout: this.timeout,
			reporters: this.reporters,
			suites: this.app.rcFile.tests.suites.map((suite) => {
				return {
					name: suite.name,
					files: suite.files
				};
			}),
			env: { NODE_ENV: "test" },
			hooks: this.app.rcFile.hooks,
			metaFiles: this.app.rcFile.metaFiles
		});
		this.testsRunner.ui.logger = this.logger;
		this.testsRunner.onClose((exitCode) => {
			this.exitCode = exitCode;
			this.terminate();
		});
		this.testsRunner.onError(() => {
			this.exitCode = 1;
			this.terminate();
		});
		if (this.watch) await this.testsRunner.runAndWatch({ poll: this.poll || false });
		else await this.testsRunner.run();
	}
};
__decorate([args.spread({
	description: "Mention suite names to run tests for selected suites",
	required: false
})], Test.prototype, "suites", void 0);
__decorate([flags.array({ description: "Filter tests by the filename" })], Test.prototype, "files", void 0);
__decorate([flags.array({ description: "Filter tests by tags" })], Test.prototype, "tags", void 0);
__decorate([flags.array({ description: "Filter tests by parent group title" })], Test.prototype, "groups", void 0);
__decorate([flags.array({ description: "Filter tests by test title" })], Test.prototype, "tests", void 0);
__decorate([flags.array({ description: "Activate one or more test reporters" })], Test.prototype, "reporters", void 0);
__decorate([flags.boolean({ description: "Watch filesystem and re-run tests on file change" })], Test.prototype, "watch", void 0);
__decorate([flags.boolean({ description: "Use polling to detect filesystem changes" })], Test.prototype, "poll", void 0);
__decorate([flags.number({ description: "Define default timeout for all tests" })], Test.prototype, "timeout", void 0);
__decorate([flags.number({ description: "Define default retries for all tests" })], Test.prototype, "retries", void 0);
__decorate([flags.boolean({ description: "Execute tests failed during the last run" })], Test.prototype, "failed", void 0);
__decorate([flags.boolean({
	description: "Clear the terminal for new logs after file change",
	showNegatedVariantInHelp: true,
	default: true
})], Test.prototype, "clear", void 0);
export { Test as default };
