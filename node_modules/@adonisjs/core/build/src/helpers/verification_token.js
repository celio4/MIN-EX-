import string from "@poppinss/utils/string";
import base64 from "@poppinss/utils/base64";
import { Secret, safeEqual } from "@poppinss/utils";
import { createHash } from "node:crypto";
var VerificationToken = class {
	static decode(value) {
		if (typeof value !== "string") return null;
		if (!value) return null;
		const [identifier, ...tokenValue] = value.split(".");
		if (!identifier || tokenValue.length === 0) return null;
		const decodedIdentifier = base64.urlDecode(identifier);
		const decodedSecret = base64.urlDecode(tokenValue.join("."));
		if (!decodedIdentifier || !decodedSecret) return null;
		return {
			identifier: decodedIdentifier,
			secret: new Secret(decodedSecret)
		};
	}
	static createTransientToken(userId, size, expiresIn) {
		const expiresAt = /* @__PURE__ */ new Date();
		expiresAt.setSeconds(expiresAt.getSeconds() + string.seconds.parse(expiresIn));
		return {
			userId,
			expiresAt,
			...this.seed(size)
		};
	}
	static seed(size) {
		const secret = new Secret(string.random(size));
		return {
			secret,
			hash: createHash("sha256").update(secret.release()).digest("hex")
		};
	}
	computeValue(secret) {
		this.value = new Secret(`${base64.urlEncode(String(this.identifier))}.${base64.urlEncode(secret.release())}`);
	}
	isExpired() {
		return this.expiresAt < /* @__PURE__ */ new Date();
	}
	verify(secret) {
		const newHash = createHash("sha256").update(secret.release()).digest("hex");
		return safeEqual(this.hash, newHash);
	}
};
export { VerificationToken };
