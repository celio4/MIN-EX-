import vine, { BaseLiteralType, symbols } from "@vinejs/vine";
const MULTIPART_FILE = symbols.SUBTYPE ?? Symbol.for("subtype");
function isBodyParserFile(file) {
	return !!(file && typeof file === "object" && "isMultipartFile" in file);
}
const isMultipartFile = vine.createRule((file, options, field) => {
	if (!field.isDefined) return false;
	if (!isBodyParserFile(file)) {
		field.report("The {{ field }} must be a file", "file", field);
		return false;
	}
	const validationOptions = typeof options === "function" ? options(field) : options;
	if (file.sizeLimit === void 0 && validationOptions.size) file.sizeLimit = validationOptions.size;
	if (file.allowedExtensions === void 0 && validationOptions.extnames) file.allowedExtensions = validationOptions.extnames;
	file.validate();
	file.errors.forEach((error) => {
		field.report(error.message, `file.${error.type}`, field, validationOptions);
	});
	return file.isValid;
});
var VineMultipartFile = class VineMultipartFile extends BaseLiteralType {
	#validationOptions;
	[MULTIPART_FILE] = "multipartFile";
	constructor(validationOptions, options, validations) {
		super(options, validations || []);
		this.#validationOptions = validationOptions;
		this.dataTypeValidator = isMultipartFile(validationOptions || {});
	}
	clone() {
		return new VineMultipartFile(this.#validationOptions, this.cloneOptions(), this.cloneValidations());
	}
};
export { VineMultipartFile };
