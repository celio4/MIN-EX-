import { t as E_BLIND_INDEX_NOT_SUPPORTED } from "../../../errors-CrCO-k44.js";
import { BaseDriver, Hmac, base64UrlDecode, base64UrlEncode, errors } from "@boringnode/encryption";
import { MessageBuilder } from "@poppinss/utils";
import { createCipheriv, createDecipheriv, randomBytes } from "node:crypto";
function legacy(config) {
	return {
		driver: (key) => new Legacy({ key }),
		keys: config.keys
	};
}
var Legacy = class extends BaseDriver {
	constructor(config) {
		super(config);
		if (this.cryptoKey.length < 16) throw new errors.E_INSECURE_ENCRYPTER_KEY();
	}
	encrypt(payload, expiresInOrOptions, purpose) {
		let expiresIn;
		let actualPurpose;
		if (typeof expiresInOrOptions === "object" && expiresInOrOptions !== null) {
			expiresIn = expiresInOrOptions.expiresIn;
			actualPurpose = expiresInOrOptions.purpose;
		} else {
			expiresIn = expiresInOrOptions;
			actualPurpose = purpose;
		}
		const iv = randomBytes(16);
		const cipher = createCipheriv("aes-256-cbc", this.cryptoKey.subarray(0, 32), iv);
		const plainText = new MessageBuilder().build(payload, expiresIn, actualPurpose);
		const macPayload = `${base64UrlEncode(Buffer.concat([cipher.update(plainText), cipher.final()]))}${this.separator}${base64UrlEncode(iv)}`;
		const hmac = new Hmac(this.cryptoKey).generate(macPayload);
		return this.computeReturns([macPayload, hmac]);
	}
	decrypt(value, purpose) {
		if (typeof value !== "string") return null;
		const [cipherEncoded, ivEncoded, macEncoded] = value.split(this.separator);
		if (!cipherEncoded || !ivEncoded || !macEncoded) return null;
		const cipherText = base64UrlDecode(cipherEncoded);
		if (!cipherText) return null;
		const iv = base64UrlDecode(ivEncoded);
		if (!iv) return null;
		if (!new Hmac(this.cryptoKey).compare(`${cipherEncoded}${this.separator}${ivEncoded}`, macEncoded)) return null;
		try {
			const decipher = createDecipheriv("aes-256-cbc", this.cryptoKey.subarray(0, 32), iv);
			const plainTextBuffer = Buffer.concat([decipher.update(cipherText), decipher.final()]);
			return new MessageBuilder().verify(plainTextBuffer, purpose);
		} catch {
			return null;
		}
	}
	blindIndex(_payload, _purpose) {
		throw new E_BLIND_INDEX_NOT_SUPPORTED(["legacy"]);
	}
	blindIndexes(_payload, _purpose) {
		throw new E_BLIND_INDEX_NOT_SUPPORTED(["legacy"]);
	}
};
export { Legacy, legacy };
