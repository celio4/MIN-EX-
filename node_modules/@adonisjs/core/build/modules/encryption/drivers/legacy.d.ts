import { type Secret } from '@poppinss/utils';
import { BaseDriver } from '@boringnode/encryption';
import type { CypherText, EncryptOptions, EncryptionDriverContract } from '@boringnode/encryption/types';
/**
 * Configuration for the Legacy encryption driver.
 *
 * The Legacy driver maintains compatibility with the old AdonisJS v6
 * encryption format using AES-256-CBC with HMAC SHA-256.
 */
export interface LegacyConfig {
    key: string | Secret<string>;
}
/**
 * Configuration for the Legacy encryption driver factory.
 *
 * Used when configuring the driver through the defineConfig function.
 */
export interface LegacyDriverConfig {
    keys: (string | Secret<string>)[];
}
/**
 * Factory function to create a Legacy encryption configuration.
 *
 * @example
 * ```ts
 * drivers.legacy({
 *   keys: [env.get('APP_KEY')]
 * })
 * ```
 */
export declare function legacy(config: LegacyDriverConfig): {
    driver: (key: string | Secret<string>) => Legacy;
    keys: (string | Secret<string>)[];
};
/**
 * Legacy encryption driver for AdonisJS.
 *
 * This driver maintains compatibility with the old AdonisJS v6 encryption
 * format. It uses:
 * - AES-256-CBC for encryption
 * - HMAC SHA-256 for integrity verification
 * - MessageBuilder from @poppinss/utils for encoding values
 *
 * Encrypted format: `[encrypted_base64url].[iv_base64url].[hmac]`
 *
 * @example
 * ```ts
 * const driver = new Legacy({ key: 'your-32-character-secret-key!!' })
 *
 * const encrypted = driver.encrypt('sensitive data')
 * const decrypted = driver.decrypt(encrypted)
 * ```
 */
export declare class Legacy extends BaseDriver implements EncryptionDriverContract {
    constructor(config: LegacyConfig);
    /**
     * Encrypt a given piece of value using the app secret. A wide range of
     * data types are supported.
     *
     * - String
     * - Arrays
     * - Objects
     * - Booleans
     * - Numbers
     * - Dates
     *
     * You can optionally define a purpose for which the value was encrypted and
     * mentioning a different purpose/no purpose during decrypt will fail.
     */
    encrypt(payload: any, options?: EncryptOptions): CypherText;
    encrypt(payload: any, expiresIn?: string | number, purpose?: string): CypherText;
    /**
     * Decrypt value and verify it against a purpose
     */
    decrypt<T extends any>(value: string, purpose?: string): T | null;
    /**
     * Legacy driver does not support blind indexes.
     */
    blindIndex(_payload: any, _purpose: string): string;
    /**
     * Legacy driver does not support blind indexes.
     */
    blindIndexes(_payload: any, _purpose: string): string[];
}
