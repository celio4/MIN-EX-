import { BaseCommand as AceBaseCommand, ListCommand as AceListCommand } from '@adonisjs/ace';
import { type Kernel } from './kernel.ts';
import type { ApplicationService } from '../../src/types.ts';
import type { CommandOptions, ParsedOutput, UIPrimitives } from '../../types/ace.ts';
/**
 * The base command class for creating custom Ace commands in AdonisJS applications.
 * This class extends the base Ace command with AdonisJS-specific functionality like
 * dependency injection and application lifecycle management.
 *
 * @example
 * ```ts
 * export default class MakeUser extends BaseCommand {
 *   static commandName = 'make:user'
 *   static description = 'Create a new user'
 *
 *   async run() {
 *     this.logger.info('Creating user...')
 *     // Command implementation
 *   }
 * }
 * ```
 */
export declare class BaseCommand extends AceBaseCommand {
    app: ApplicationService;
    kernel: Kernel;
    static options: CommandOptions;
    get staysAlive(): boolean | undefined;
    get startApp(): boolean | undefined;
    constructor(app: ApplicationService, kernel: Kernel, parsed: ParsedOutput, ui: UIPrimitives, prompt: Kernel['prompt']);
    /**
     * Creates the codemods module to modify source files programmatically.
     * This method provides access to AST-based code transformations.
     *
     * @example
     * ```ts
     * const codemods = await this.createCodemods()
     * await codemods.makeUsingStub(stubsRoot, 'controller.stub', {
     *   filename: 'UserController',
     *   entity: { name: 'User' }
     * })
     * ```
     */
    createCodemods(): Promise<import("./codemods.js").Codemods>;
    /**
     * The prepare template method is used to prepare the
     * state for the command. This is the first method
     * executed on a given command instance.
     */
    prepare?(..._: any[]): any;
    /**
     * The interact template method is used to display the prompts
     * to the user. The method is called after the prepare
     * method.
     */
    interact?(..._: any[]): any;
    /**
     * The completed method is the method invoked after the command
     * finishes or results in an error.
     *
     * You can access the command error using the `this.error` property.
     * Returning `true` from completed method supresses the error
     * reporting to the kernel layer.
     */
    completed?(..._: any[]): any;
    /**
     * Executes the lifecycle hooks and the run method from the command
     */
    exec(): Promise<any>;
    /**
     * Terminate the application gracefully. This method should be preferred over
     * calling `app.terminate()` directly as it only triggers termination when
     * the current command is the main command responsible for the process.
     *
     * @example
     * ```ts
     * export default class SomeCommand extends BaseCommand {
     *   async run() {
     *     // Do some work
     *     await this.terminate()
     *   }
     * }
     * ```
     */
    terminate(): Promise<void>;
}
/**
 * The List command is used to display a list of available commands.
 * This command extends the base Ace ListCommand with AdonisJS-specific functionality.
 */
export declare class ListCommand extends AceListCommand implements BaseCommand {
    app: ApplicationService;
    kernel: Kernel;
    static options: CommandOptions;
    get staysAlive(): boolean | undefined;
    get startApp(): boolean | undefined;
    constructor(app: ApplicationService, kernel: Kernel, parsed: ParsedOutput, ui: UIPrimitives, prompt: Kernel['prompt']);
    /**
     * Creates the codemods module to modify source files programmatically.
     * This method provides access to AST-based code transformations.
     */
    createCodemods(): Promise<import("./codemods.js").Codemods>;
    /**
     * Terminate the app. A command should prefer calling this method
     * over the "app.terminate", because this method only triggers
     * app termination when the current command is in the charge
     * of the process.
     */
    terminate(): Promise<void>;
}
