import { t as debug_default } from "../../debug-CGQmxzGt.js";
import stringHelpers from "../../src/helpers/string.js";
import { EnvEditor } from "@adonisjs/env/editor";
import { isAbsolute } from "node:path";
import { readFile } from "node:fs/promises";
import { EventEmitter } from "node:events";
var Codemods = class extends EventEmitter {
	#codeTransformer;
	#app;
	#cliLogger;
	overwriteExisting = false;
	verboseInstallOutput = false;
	constructor(app, cliLogger) {
		super();
		this.#app = app;
		this.#cliLogger = cliLogger;
	}
	async #getCodeTransformer() {
		try {
			if (!this.#codeTransformer) {
				const { CodeTransformer } = await import("@adonisjs/assembler/code_transformer");
				this.#codeTransformer = new CodeTransformer(this.#app.appRoot);
			}
			return this.#codeTransformer;
		} catch {
			return null;
		}
	}
	#getInstallationCommands(packages, packageManager, isDev) {
		if (!packages.length) return "";
		const colors = this.#cliLogger.getColors();
		const devFlag = isDev ? " -D" : "";
		switch (packageManager) {
			case "yarn":
			case "yarn@berry": return `${colors.yellow(`yarn add${devFlag}`)} ${packages.join(" ")}`;
			case "pnpm": return `${colors.yellow(`pnpm add${devFlag}`)} ${packages.join(" ")}`;
			default: return `${colors.yellow(`npm i${devFlag}`)} ${packages.join(" ")}`;
		}
	}
	async defineEnvVariables(environmentVariables, options) {
		const editor = new EnvEditor(this.#app.appRoot);
		await editor.load();
		Object.keys(environmentVariables).forEach((key) => {
			const value = environmentVariables[key];
			editor.add(key, value, options?.omitFromExample?.includes(key));
		});
		await editor.save();
		this.#cliLogger.action("update .env file").succeeded();
	}
	async getTsMorphProject() {
		const transformer = await this.#getCodeTransformer();
		if (!transformer) {
			this.#cliLogger.warning("Cannot create CodeTransformer. Install \"@adonisjs/assembler\" to modify source files");
			return;
		}
		return transformer.project;
	}
	async defineEnvValidations(validations) {
		const transformer = await this.#getCodeTransformer();
		if (!transformer) {
			this.#cliLogger.warning("Cannot update \"start/env.ts\" file. Install \"@adonisjs/assembler\" to modify source files");
			return;
		}
		const action = this.#cliLogger.action("update start/env.ts file");
		try {
			await transformer.defineEnvValidations(validations);
			action.succeeded();
		} catch (error) {
			this.emit("error", error);
			action.failed(error.message);
		}
	}
	async registerMiddleware(stack, middleware) {
		const transformer = await this.#getCodeTransformer();
		if (!transformer) {
			this.#cliLogger.warning("Cannot update \"start/kernel.ts\" file. Install \"@adonisjs/assembler\" to modify source files");
			return;
		}
		const action = this.#cliLogger.action("update start/kernel.ts file");
		try {
			await transformer.addMiddlewareToStack(stack, middleware);
			action.succeeded();
		} catch (error) {
			this.emit("error", error);
			action.failed(error.message);
		}
	}
	async registerPolicies(policies) {
		const transformer = await this.#getCodeTransformer();
		if (!transformer) {
			this.#cliLogger.warning("Cannot update \"app/policies/main.ts\" file. Install \"@adonisjs/assembler\" to modify source files");
			return;
		}
		const action = this.#cliLogger.action("update app/policies/main.ts file");
		try {
			await transformer.addPolicies(policies);
			action.succeeded();
		} catch (error) {
			this.emit("error", error);
			action.failed(error.message);
		}
	}
	async updateRcFile(...params) {
		const transformer = await this.#getCodeTransformer();
		if (!transformer) {
			this.#cliLogger.warning("Cannot update \"adonisrc.ts\" file. Install \"@adonisjs/assembler\" to modify source files");
			return;
		}
		const action = this.#cliLogger.action("update adonisrc.ts file");
		try {
			await transformer.updateRcFile(...params);
			action.succeeded();
		} catch (error) {
			this.emit("error", error);
			action.failed(error.message);
		}
	}
	async registerVitePlugin(...params) {
		const transformer = await this.#getCodeTransformer();
		if (!transformer) {
			this.#cliLogger.warning("Cannot update \"vite.config.ts\" file. Install \"@adonisjs/assembler\" to modify source files");
			return;
		}
		const action = this.#cliLogger.action("update vite.config.ts file");
		try {
			await transformer.addVitePlugin(...params);
			action.succeeded();
		} catch (error) {
			this.emit("error", error);
			action.failed(error.message);
		}
	}
	async registerJapaPlugin(...params) {
		const transformer = await this.#getCodeTransformer();
		if (!transformer) {
			this.#cliLogger.warning("Cannot update \"tests/bootstrap.ts\" file. Install \"@adonisjs/assembler\" to modify source files");
			return;
		}
		const action = this.#cliLogger.action("update tests/bootstrap.ts file");
		try {
			await transformer.addJapaPlugin(...params);
			action.succeeded();
		} catch (error) {
			this.emit("error", error);
			action.failed(error.message);
		}
	}
	async addValidator(...params) {
		const transformer = await this.#getCodeTransformer();
		if (!transformer) {
			this.#cliLogger.warning("Cannot create validator file. Install \"@adonisjs/assembler\" to modify source files");
			return;
		}
		const action = this.#cliLogger.action("create validator file");
		try {
			await transformer.addValidator(...params);
			action.succeeded();
		} catch (error) {
			this.emit("error", error);
			action.failed(error.message);
		}
	}
	async addLimiter(...params) {
		const transformer = await this.#getCodeTransformer();
		if (!transformer) {
			this.#cliLogger.warning("Cannot create limiter file. Install \"@adonisjs/assembler\" to modify source files");
			return;
		}
		const action = this.#cliLogger.action("create limiter file");
		try {
			await transformer.addLimiter(...params);
			action.succeeded();
		} catch (error) {
			this.emit("error", error);
			action.failed(error.message);
		}
	}
	async addModelMixins(...params) {
		const transformer = await this.#getCodeTransformer();
		if (!transformer) {
			this.#cliLogger.warning("Cannot update model file. Install \"@adonisjs/assembler\" to modify source files");
			return;
		}
		const action = this.#cliLogger.action("update model file");
		try {
			await transformer.addModelMixins(...params);
			action.succeeded();
		} catch (error) {
			this.emit("error", error);
			action.failed(error.message);
		}
	}
	async addControllerMethod(...params) {
		const transformer = await this.#getCodeTransformer();
		if (!transformer) {
			this.#cliLogger.warning("Cannot update controller file. Install \"@adonisjs/assembler\" to modify source files");
			return;
		}
		const action = this.#cliLogger.action("update controller file");
		try {
			await transformer.addControllerMethod(...params);
			action.succeeded();
		} catch (error) {
			this.emit("error", error);
			action.failed(error.message);
		}
	}
	async makeUsingStub(stubsRoot, stubPath, stubState, options) {
		const stub = await (await this.#app.stubs.create()).build(stubPath, { source: stubsRoot });
		if (options?.contentsFromFile) {
			const source = isAbsolute(options.contentsFromFile) ? options.contentsFromFile : this.#app.makePath(options.contentsFromFile);
			try {
				debug_default("overwriting stub output with contents from file %s", source);
				stub.replaceWith(await readFile(source, "utf-8"));
			} catch (error) {
				if (error.code === "ENOENT") throw new Error(`Cannot replace stub output with "${options.contentsFromFile}" file contents as the file is missing`, { cause: error });
				throw error;
			}
		}
		const output = await stub.generate({
			force: this.overwriteExisting,
			...stubState
		});
		debug_default("generating file %O", output);
		const entityFileName = stringHelpers.toUnixSlash(this.#app.relativePath(output.destination));
		const result = {
			...output,
			relativeFileName: entityFileName
		};
		if (output.status === "skipped") {
			this.#cliLogger.action(`create ${entityFileName}`).skipped(output.skipReason);
			return result;
		}
		this.#cliLogger.action(`create ${entityFileName}`).succeeded();
		return result;
	}
	async installPackages(packages, packageManager) {
		const transformer = await this.#getCodeTransformer();
		const appPath = this.#app.makePath();
		const colors = this.#cliLogger.getColors();
		const devDependencies = packages.filter((pkg) => pkg.isDevDependency).map(({ name }) => {
			return name.startsWith("@adonisjs/") ? `${name}@next` : name;
		});
		const dependencies = packages.filter((pkg) => !pkg.isDevDependency).map(({ name }) => {
			return name.startsWith("@adonisjs/") ? `${name}@next` : name;
		});
		if (!transformer) {
			this.#cliLogger.warning("Cannot install packages. Install \"@adonisjs/assembler\" or manually install following packages");
			this.#cliLogger.log(`devDependencies: ${devDependencies.join(",")}`);
			this.#cliLogger.log(`dependencies: ${dependencies.join(",")}`);
			return false;
		}
		packageManager = packageManager ?? await transformer.detectPackageManager(appPath) ?? "npm";
		const spinner = this.#cliLogger.await(`installing dependencies using ${packageManager} `);
		const silentLogs = !this.verboseInstallOutput;
		if (silentLogs) spinner.start();
		try {
			if (dependencies.length) await transformer.installPackage(dependencies, {
				cwd: appPath,
				silent: silentLogs,
				packageManager
			});
			if (devDependencies.length) await transformer.installPackage(devDependencies, {
				dev: true,
				cwd: appPath,
				silent: silentLogs,
				packageManager
			});
			if (silentLogs) spinner.stop();
			this.#cliLogger.success("Packages installed");
			this.#cliLogger.log(devDependencies.map((dependency) => `    ${colors.dim("dev")} ${dependency} `).join("\n"));
			this.#cliLogger.log(dependencies.map((dependency) => `    ${colors.dim("prod")} ${dependency} `).join("\n"));
			return true;
		} catch (error) {
			if (silentLogs) {
				spinner.update("unable to install dependencies");
				spinner.stop();
			}
			this.#cliLogger.fatal(error);
			this.emit("error", error);
			return false;
		}
	}
	async listPackagesToInstall(packages) {
		const appPath = this.#app.makePath();
		const devDependencies = packages.filter((pkg) => pkg.isDevDependency).map(({ name }) => name);
		const dependencies = packages.filter((pkg) => !pkg.isDevDependency).map(({ name }) => name);
		let packageManager = null;
		const transformer = await this.#getCodeTransformer();
		if (transformer) packageManager = await transformer.detectPackageManager(appPath);
		this.#cliLogger.log("Please install following packages");
		this.#cliLogger.log(this.#getInstallationCommands(devDependencies, packageManager || "npm", true));
		this.#cliLogger.log(this.#getInstallationCommands(dependencies, packageManager || "npm", false));
	}
};
export { Codemods };
