import { t as debug_default } from "./debug-CGQmxzGt.js";
import { setApp } from "./services/app.js";
import { t as app_exports } from "./modules/app.js";
import { createServer } from "node:http";
var AceProcess = class {
	#ignitor;
	#configureCallback = () => {};
	constructor(ignitor) {
		this.#ignitor = ignitor;
	}
	configure(callback) {
		this.#configureCallback = callback;
		return this;
	}
	async handle(argv) {
		const app = this.#ignitor.createApp("console");
		await app.init();
		const { createAceKernel } = await import("./create_kernel-BD0Iqi8e.js");
		const commandName = argv[argv.findIndex((value) => !value.startsWith("-"))];
		const kernel = createAceKernel(app, commandName);
		app.container.bindValue("ace", kernel);
		kernel.loading(async (metaData) => {
			if (metaData.options.startApp && !app.isReady) {
				if (metaData.commandName === "repl") app.setEnvironment("repl");
				await app.boot();
				await app.start(() => {});
			}
		});
		await this.#configureCallback(app);
		app.terminating(() => {
			const mainCommand = kernel.getMainCommand();
			if (mainCommand?.staysAlive) process.exitCode = mainCommand.exitCode;
		});
		await kernel.handle(argv);
		const mainCommand = kernel.getMainCommand();
		if (!mainCommand || !mainCommand.staysAlive) {
			process.exitCode = kernel.exitCode;
			await app.terminate();
		}
	}
};
var TestRunnerProcess = class {
	#ignitor;
	#configureCallback = () => {};
	constructor(ignitor) {
		this.#ignitor = ignitor;
	}
	configure(callback) {
		this.#configureCallback = callback;
		return this;
	}
	async run(callback) {
		const app = this.#ignitor.createApp("test");
		await app.init();
		await app.boot();
		await app.start(this.#configureCallback);
		await callback(app);
	}
};
var HttpServerProcess = class {
	#ignitor;
	constructor(ignitor) {
		this.#ignitor = ignitor;
	}
	#close(nodeHttpServer) {
		return new Promise((resolve) => {
			debug_default("closing http server process");
			nodeHttpServer.close(() => resolve());
		});
	}
	#monitorAppAndServer(nodeHttpServer, app, logger) {
		app.terminating(async () => {
			debug_default("terminating signal received");
			await this.#close(nodeHttpServer);
		});
		nodeHttpServer.once("error", (error) => {
			debug_default("http server crashed with error \"%O\"", error);
			logger.fatal({ err: error }, error.message);
			process.exitCode = 1;
			app.terminate();
		});
	}
	#listen(nodeHttpServer) {
		return new Promise((resolve, reject) => {
			const host = process.env.HOST || "0.0.0.0";
			const port = Number(process.env.PORT || "3333");
			nodeHttpServer.listen(port, host);
			nodeHttpServer.once("listening", () => {
				debug_default("listening to http server, host :%s, port: %s", host, port);
				resolve({
					port,
					host
				});
			});
			nodeHttpServer.once("error", (error) => {
				reject(error);
			});
		});
	}
	#notifyServerHasStarted(app, logger, emitter, payload) {
		app.notify({
			isAdonisJS: true,
			environment: "web",
			...payload
		});
		logger.info("started HTTP server on %s:%s", payload.host, payload.port);
		emitter.emit("http:server_ready", payload);
	}
	async start(serverCallback) {
		const startTime = process.hrtime();
		const createHTTPServer = serverCallback || createServer;
		const app = this.#ignitor.createApp("web");
		await app.init();
		await app.boot();
		await app.start(async () => {
			const server = await app.container.make("server");
			await server.boot();
			const httpServer = createHTTPServer(server.handle.bind(server));
			server.setNodeServer(httpServer);
			const logger = await app.container.make("logger");
			const emitter = await app.container.make("emitter");
			const payload = await this.#listen(httpServer);
			this.#notifyServerHasStarted(app, logger, emitter, {
				...payload,
				duration: process.hrtime(startTime)
			});
			this.#monitorAppAndServer(httpServer, app, logger);
		});
	}
};
var Ignitor = class {
	#options;
	#appRoot;
	#app;
	#tapCallbacks = /* @__PURE__ */ new Set();
	constructor(appRoot, options = {}) {
		this.#appRoot = appRoot;
		this.#options = options;
	}
	#runTapCallbacks(app) {
		this.#tapCallbacks.forEach((tapCallback) => tapCallback(app));
	}
	getApp() {
		return this.#app;
	}
	createApp(environment) {
		debug_default("creating application instance");
		this.#app = new app_exports.Application(this.#appRoot, {
			environment,
			importer: this.#options.importer
		});
		setApp(this.#app);
		this.#runTapCallbacks(this.#app);
		return this.#app;
	}
	tap(callback) {
		this.#tapCallbacks.add(callback);
		return this;
	}
	httpServer() {
		return new HttpServerProcess(this);
	}
	ace() {
		return new AceProcess(this);
	}
	testRunner() {
		return new TestRunnerProcess(this);
	}
	async terminate() {
		await this.#app?.terminate();
	}
};
export { Ignitor as t };
