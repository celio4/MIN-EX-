import {
  Hmac
} from "./chunk-BCVNO66Y.js";
import {
  base64UrlDecode,
  base64UrlEncode
} from "./chunk-ACZGKXGJ.js";

// src/message_verifier.ts
import { createHash } from "crypto";
import { MessageBuilder } from "@poppinss/utils";
import { RuntimeException } from "@poppinss/utils/exception";
var MessageVerifier = class {
  /**
   * The keys for signing and verifying values. They are derived
   * from the user provided secrets.
   */
  #cryptoKeys;
  /**
   * Use `dot` as a separator for joining encrypted value, iv and the
   * hmac hash. The idea is borrowed from JWT's in which each part
   * of the payload is concatenated with a dot.
   */
  #separator = ".";
  constructor(secrets) {
    this.#cryptoKeys = secrets.map(
      (s) => createHash("sha256").update(typeof s === "string" ? s : s.release()).digest()
    );
  }
  /**
   * Sign a given piece of value using the app secret. A wide range of
   * data types are supported.
   *
   * - String
   * - Arrays
   * - Objects
   * - Booleans
   * - Numbers
   * - Dates
   *
   * You can optionally define a purpose for which the value was signed and
   * mentioning a different purpose/no purpose during unsign will fail.
   */
  sign(payload, expiresIn, purpose) {
    if (payload === null || payload === void 0) {
      throw new RuntimeException(`Cannot sign "${payload}" value`);
    }
    const encoded = base64UrlEncode(new MessageBuilder().build(payload, expiresIn, purpose));
    return `${encoded}${this.#separator}${new Hmac(this.#cryptoKeys[0]).generate(encoded)}`;
  }
  /**
   * Unsign a previously signed value with an optional purpose
   */
  unsign(payload, purpose) {
    if (typeof payload !== "string") {
      return null;
    }
    const [encoded, hash] = payload.split(this.#separator);
    if (!encoded || !hash) {
      return null;
    }
    const decoded = base64UrlDecode(encoded, "utf8");
    if (!decoded) {
      return null;
    }
    for (const cryptoKey of this.#cryptoKeys) {
      const isValid = new Hmac(cryptoKey).compare(encoded, hash);
      if (isValid) {
        return new MessageBuilder().verify(decoded, purpose);
      }
    }
    return null;
  }
};

export {
  MessageVerifier
};
/*
 * @boringnode/encryption
 *
 * @license MIT
 * @copyright Boring Node
 */
//# sourceMappingURL=chunk-SMDTGIFR.js.map