{"version":3,"sources":["../src/message_verifier.ts"],"sourcesContent":["/*\n * @boringnode/encryption\n *\n * @license MIT\n * @copyright Boring Node\n */\n\nimport { createHash } from 'node:crypto'\nimport { MessageBuilder, type Secret } from '@poppinss/utils'\nimport { RuntimeException } from '@poppinss/utils/exception'\nimport { base64UrlEncode, base64UrlDecode } from './base64.ts'\nimport { Hmac } from './hmac.ts'\n\n/**\n * Message verifier is similar to the encryption. However, the actual payload\n * is not encrypted and just base64 encoded. This is helpful when you are\n * not concerned about the confidentiality of the data, but just want to\n * make sure that is not tampered with after encoding.\n */\nexport class MessageVerifier {\n  /**\n   * The keys for signing and verifying values. They are derived\n   * from the user provided secrets.\n   */\n  #cryptoKeys: Buffer[]\n\n  /**\n   * Use `dot` as a separator for joining encrypted value, iv and the\n   * hmac hash. The idea is borrowed from JWT's in which each part\n   * of the payload is concatenated with a dot.\n   */\n  #separator = '.'\n\n  constructor(secrets: (string | Secret<string>)[]) {\n    this.#cryptoKeys = secrets.map((s) =>\n      createHash('sha256')\n        .update(typeof s === 'string' ? s : s.release())\n        .digest()\n    )\n  }\n\n  /**\n   * Sign a given piece of value using the app secret. A wide range of\n   * data types are supported.\n   *\n   * - String\n   * - Arrays\n   * - Objects\n   * - Booleans\n   * - Numbers\n   * - Dates\n   *\n   * You can optionally define a purpose for which the value was signed and\n   * mentioning a different purpose/no purpose during unsign will fail.\n   */\n  sign(payload: any, expiresIn?: string | number, purpose?: string) {\n    if (payload === null || payload === undefined) {\n      throw new RuntimeException(`Cannot sign \"${payload}\" value`)\n    }\n\n    const encoded = base64UrlEncode(new MessageBuilder().build(payload, expiresIn, purpose))\n    return `${encoded}${this.#separator}${new Hmac(this.#cryptoKeys[0]).generate(encoded)}`\n  }\n\n  /**\n   * Unsign a previously signed value with an optional purpose\n   */\n  unsign<T extends any>(payload: string, purpose?: string): T | null {\n    if (typeof payload !== 'string') {\n      return null\n    }\n\n    /**\n     * Ensure value is in correct format\n     */\n    const [encoded, hash] = payload.split(this.#separator)\n    if (!encoded || !hash) {\n      return null\n    }\n\n    /**\n     * Ensure value can be decoded\n     */\n    const decoded = base64UrlDecode(encoded, 'utf8')\n    if (!decoded) {\n      return null\n    }\n\n    for (const cryptoKey of this.#cryptoKeys) {\n      const isValid = new Hmac(cryptoKey).compare(encoded, hash)\n      if (isValid) {\n        return new MessageBuilder().verify(decoded, purpose)\n      }\n    }\n\n    return null\n  }\n}\n"],"mappings":";;;;;;;;;AAOA,SAAS,kBAAkB;AAC3B,SAAS,sBAAmC;AAC5C,SAAS,wBAAwB;AAU1B,IAAM,kBAAN,MAAsB;AAAA;AAAA;AAAA;AAAA;AAAA,EAK3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa;AAAA,EAEb,YAAY,SAAsC;AAChD,SAAK,cAAc,QAAQ;AAAA,MAAI,CAAC,MAC9B,WAAW,QAAQ,EAChB,OAAO,OAAO,MAAM,WAAW,IAAI,EAAE,QAAQ,CAAC,EAC9C,OAAO;AAAA,IACZ;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,KAAK,SAAc,WAA6B,SAAkB;AAChE,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC7C,YAAM,IAAI,iBAAiB,gBAAgB,OAAO,SAAS;AAAA,IAC7D;AAEA,UAAM,UAAU,gBAAgB,IAAI,eAAe,EAAE,MAAM,SAAS,WAAW,OAAO,CAAC;AACvF,WAAO,GAAG,OAAO,GAAG,KAAK,UAAU,GAAG,IAAI,KAAK,KAAK,YAAY,CAAC,CAAC,EAAE,SAAS,OAAO,CAAC;AAAA,EACvF;AAAA;AAAA;AAAA;AAAA,EAKA,OAAsB,SAAiB,SAA4B;AACjE,QAAI,OAAO,YAAY,UAAU;AAC/B,aAAO;AAAA,IACT;AAKA,UAAM,CAAC,SAAS,IAAI,IAAI,QAAQ,MAAM,KAAK,UAAU;AACrD,QAAI,CAAC,WAAW,CAAC,MAAM;AACrB,aAAO;AAAA,IACT;AAKA,UAAM,UAAU,gBAAgB,SAAS,MAAM;AAC/C,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,IACT;AAEA,eAAW,aAAa,KAAK,aAAa;AACxC,YAAM,UAAU,IAAI,KAAK,SAAS,EAAE,QAAQ,SAAS,IAAI;AACzD,UAAI,SAAS;AACX,eAAO,IAAI,eAAe,EAAE,OAAO,SAAS,OAAO;AAAA,MACrD;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACF;","names":[]}