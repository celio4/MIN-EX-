{"version":3,"sources":["../src/drivers/base_driver.ts","../src/exceptions.ts"],"sourcesContent":["/*\n * @boringnode/encryption\n *\n * @license MIT\n * @copyright Boring Node\n */\n\nimport { createHash, createHmac, hkdfSync } from 'node:crypto'\nimport { MessageBuilder, type Secret } from '@poppinss/utils'\nimport * as errors from '../exceptions.ts'\nimport { base64UrlEncode } from '../base64.ts'\nimport type { BaseConfig, CypherText, EncryptOptions } from '../types/main.ts'\n\nexport abstract class BaseDriver {\n  /**\n   * The key for encrypting values. It is derived\n   * from the user provided secret.\n   */\n  cryptoKey: Buffer\n  #blindIndexKey: Buffer\n\n  /**\n   * Use `dot` as a separator for joining encrypted value, iv and the\n   * hmac hash. The idea is borrowed from JWTs.\n   */\n  separator = '.'\n\n  protected constructor(config: BaseConfig) {\n    const key = this.#validateAndGetSecret(config.key)\n    this.#validateId(config.id)\n    this.cryptoKey = createHash('sha256').update(key).digest()\n\n    const rawBlindIndexKey = hkdfSync(\n      'sha256',\n      this.cryptoKey,\n      Buffer.alloc(0),\n      Buffer.from(`blind-index:${config.id || 'default'}`),\n      32\n    )\n    this.#blindIndexKey = Buffer.isBuffer(rawBlindIndexKey)\n      ? rawBlindIndexKey\n      : Buffer.from(rawBlindIndexKey)\n  }\n\n  /**\n   * Validates the app secret and returns it back as a string\n   */\n  #validateAndGetSecret(secret: string | Secret<string>): string {\n    if (!secret) {\n      throw new errors.E_MISSING_ENCRYPTER_KEY()\n    }\n\n    const revealedSecret = typeof secret === 'string' ? secret : secret.release()\n    if (revealedSecret.length < 16) {\n      throw new errors.E_INSECURE_ENCRYPTER_KEY()\n    }\n\n    return revealedSecret\n  }\n\n  /**\n   * Validates encrypter id format when provided.\n   */\n  #validateId(id?: string) {\n    if (typeof id !== 'string') {\n      return\n    }\n\n    if (id.trim().length === 0 || id.includes(this.separator)) {\n      throw new errors.E_INVALID_ENCRYPTER_ID()\n    }\n  }\n\n  protected computeReturns(values: string[]) {\n    return values.join(this.separator) as CypherText\n  }\n\n  blindIndex(payload: any, purpose: string): string {\n    if (typeof purpose !== 'string' || purpose.trim().length === 0) {\n      throw new errors.E_BLIND_INDEX_PURPOSE_REQUIRED()\n    }\n\n    const rawPayload = new MessageBuilder().build(payload)\n    const payloadBuffer = Buffer.isBuffer(rawPayload) ? rawPayload : Buffer.from(rawPayload)\n    const indexPayload = Buffer.concat([\n      Buffer.from(purpose),\n      Buffer.from(this.separator),\n      payloadBuffer,\n    ])\n\n    return base64UrlEncode(createHmac('sha256', this.#blindIndexKey).update(indexPayload).digest())\n  }\n\n  blindIndexes(payload: any, purpose: string): string[] {\n    return [this.blindIndex(payload, purpose)]\n  }\n\n  /**\n   * Encrypt a given piece of value using the app secret. A wide range of\n   * data types are supported.\n   *\n   * - String\n   * - Arrays\n   * - Objects\n   * - Booleans\n   * - Numbers\n   * - Dates\n   *\n   * You can optionally define a purpose for which the value was encrypted and\n   * mentioning a different purpose/no purpose during decrypt will fail.\n   */\n  abstract encrypt(payload: any, options?: EncryptOptions): CypherText\n  abstract encrypt(payload: any, expiresIn?: string | number, purpose?: string): CypherText\n\n  /**\n   * Decrypt value and verify it against a purpose\n   */\n  abstract decrypt<T extends any>(value: string, purpose?: string): T | null\n}\n","/*\n * @boringnode/encryption\n *\n * @license MIT\n * @copyright Boring Node\n */\n\nimport { createError } from '@poppinss/utils/exception'\n\nexport const E_INSECURE_ENCRYPTER_KEY = createError(\n  'The value of your key should be at least 16 characters long',\n  'E_INSECURE_ENCRYPTER_KEY'\n)\n\nexport const E_MISSING_ENCRYPTER_KEY = createError(\n  'Missing key. The key is required to encrypt values',\n  'E_MISSING_ENCRYPTER_KEY'\n)\n\nexport const E_MISSING_ENCRYPTER_ID = createError(\n  'Missing id. The id is required to encrypt values',\n  'E_MISSING_ENCRYPTER_ID'\n)\n\nexport const E_INVALID_ENCRYPTER_ID = createError(\n  'Invalid id. The id must be a non-empty string and cannot contain \".\"',\n  'E_INVALID_ENCRYPTER_ID'\n)\n\nexport const E_DETERMINISTIC_DRIVER_EXPIRES_IN_NOT_SUPPORTED = createError(\n  'Deterministic encryption does not support expiresIn',\n  'E_DETERMINISTIC_DRIVER_EXPIRES_IN_NOT_SUPPORTED'\n)\n\nexport const E_BLIND_INDEX_PURPOSE_REQUIRED = createError(\n  'Blind index requires a non-empty purpose',\n  'E_BLIND_INDEX_PURPOSE_REQUIRED'\n)\n"],"mappings":";;;;;;AAOA,SAAS,YAAY,YAAY,gBAAgB;AACjD,SAAS,sBAAmC;;;ACR5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA,SAAS,mBAAmB;AAErB,IAAM,2BAA2B;AAAA,EACtC;AAAA,EACA;AACF;AAEO,IAAM,0BAA0B;AAAA,EACrC;AAAA,EACA;AACF;AAEO,IAAM,yBAAyB;AAAA,EACpC;AAAA,EACA;AACF;AAEO,IAAM,yBAAyB;AAAA,EACpC;AAAA,EACA;AACF;AAEO,IAAM,kDAAkD;AAAA,EAC7D;AAAA,EACA;AACF;AAEO,IAAM,iCAAiC;AAAA,EAC5C;AAAA,EACA;AACF;;;ADxBO,IAAe,aAAf,MAA0B;AAAA;AAAA;AAAA;AAAA;AAAA,EAK/B;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY;AAAA,EAEF,YAAY,QAAoB;AACxC,UAAM,MAAM,KAAK,sBAAsB,OAAO,GAAG;AACjD,SAAK,YAAY,OAAO,EAAE;AAC1B,SAAK,YAAY,WAAW,QAAQ,EAAE,OAAO,GAAG,EAAE,OAAO;AAEzD,UAAM,mBAAmB;AAAA,MACvB;AAAA,MACA,KAAK;AAAA,MACL,OAAO,MAAM,CAAC;AAAA,MACd,OAAO,KAAK,eAAe,OAAO,MAAM,SAAS,EAAE;AAAA,MACnD;AAAA,IACF;AACA,SAAK,iBAAiB,OAAO,SAAS,gBAAgB,IAClD,mBACA,OAAO,KAAK,gBAAgB;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKA,sBAAsB,QAAyC;AAC7D,QAAI,CAAC,QAAQ;AACX,YAAM,IAAW,wBAAwB;AAAA,IAC3C;AAEA,UAAM,iBAAiB,OAAO,WAAW,WAAW,SAAS,OAAO,QAAQ;AAC5E,QAAI,eAAe,SAAS,IAAI;AAC9B,YAAM,IAAW,yBAAyB;AAAA,IAC5C;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,IAAa;AACvB,QAAI,OAAO,OAAO,UAAU;AAC1B;AAAA,IACF;AAEA,QAAI,GAAG,KAAK,EAAE,WAAW,KAAK,GAAG,SAAS,KAAK,SAAS,GAAG;AACzD,YAAM,IAAW,uBAAuB;AAAA,IAC1C;AAAA,EACF;AAAA,EAEU,eAAe,QAAkB;AACzC,WAAO,OAAO,KAAK,KAAK,SAAS;AAAA,EACnC;AAAA,EAEA,WAAW,SAAc,SAAyB;AAChD,QAAI,OAAO,YAAY,YAAY,QAAQ,KAAK,EAAE,WAAW,GAAG;AAC9D,YAAM,IAAW,+BAA+B;AAAA,IAClD;AAEA,UAAM,aAAa,IAAI,eAAe,EAAE,MAAM,OAAO;AACrD,UAAM,gBAAgB,OAAO,SAAS,UAAU,IAAI,aAAa,OAAO,KAAK,UAAU;AACvF,UAAM,eAAe,OAAO,OAAO;AAAA,MACjC,OAAO,KAAK,OAAO;AAAA,MACnB,OAAO,KAAK,KAAK,SAAS;AAAA,MAC1B;AAAA,IACF,CAAC;AAED,WAAO,gBAAgB,WAAW,UAAU,KAAK,cAAc,EAAE,OAAO,YAAY,EAAE,OAAO,CAAC;AAAA,EAChG;AAAA,EAEA,aAAa,SAAc,SAA2B;AACpD,WAAO,CAAC,KAAK,WAAW,SAAS,OAAO,CAAC;AAAA,EAC3C;AAuBF;","names":[]}