{"version":3,"sources":["../src/drivers/chacha20_poly1305.ts"],"sourcesContent":["/*\n * @boringnode/encryption\n *\n * @license MIT\n * @copyright Boring Node\n */\n\nimport { createCipheriv, createDecipheriv, randomBytes } from 'node:crypto'\nimport { MessageBuilder, type Secret } from '@poppinss/utils'\nimport { BaseDriver } from './base_driver.ts'\nimport * as errors from '../exceptions.ts'\nimport type {\n  ChaCha20Poly1305Config,\n  CypherText,\n  EncryptionConfig,\n  EncryptionDriverContract,\n  EncryptOptions,\n} from '../types/main.ts'\nimport { base64UrlDecode, base64UrlEncode } from '../base64.ts'\n\nexport interface ChaCha20Poly1305DriverConfig {\n  id: string\n  keys: (string | Secret<string>)[]\n}\n\nexport function chacha20poly1305(config: ChaCha20Poly1305DriverConfig) {\n  return {\n    driver: (key) => new ChaCha20Poly1305({ id: config.id, key }),\n    keys: config.keys,\n  } satisfies EncryptionConfig\n}\n\nexport class ChaCha20Poly1305 extends BaseDriver implements EncryptionDriverContract {\n  #config: ChaCha20Poly1305Config\n\n  constructor(config: ChaCha20Poly1305Config) {\n    super(config)\n\n    this.#config = config\n\n    if (typeof config.id !== 'string') {\n      throw new errors.E_MISSING_ENCRYPTER_ID()\n    }\n  }\n\n  /**\n   * Encrypt a given piece of value using the app secret. A wide range of\n   * data types are supported.\n   *\n   * - String\n   * - Arrays\n   * - Objects\n   * - Booleans\n   * - Numbers\n   * - Dates\n   *\n   * You can optionally define a purpose for which the value was encrypted and\n   * mentioning a different purpose/no purpose during decrypt will fail.\n   */\n  encrypt(payload: any, options?: EncryptOptions): CypherText\n  encrypt(payload: any, expiresIn?: string | number, purpose?: string): CypherText\n  encrypt(\n    payload: any,\n    expiresInOrOptions?: string | number | EncryptOptions,\n    purpose?: string\n  ): CypherText {\n    let expiresIn: string | number | undefined\n    let actualPurpose: string | undefined\n\n    if (typeof expiresInOrOptions === 'object' && expiresInOrOptions !== null) {\n      expiresIn = expiresInOrOptions.expiresIn\n      actualPurpose = expiresInOrOptions.purpose\n    } else {\n      expiresIn = expiresInOrOptions\n      actualPurpose = purpose\n    }\n\n    /**\n     * Using a random string as the iv for generating unpredictable values\n     */\n    const iv = randomBytes(12)\n\n    /**\n     * Creating cipher\n     */\n    const cipher = createCipheriv('chacha20-poly1305', this.cryptoKey, iv, {\n      authTagLength: 16,\n    })\n\n    if (actualPurpose) {\n      cipher.setAAD(Buffer.from(actualPurpose), {\n        plaintextLength: Buffer.byteLength(actualPurpose),\n      })\n    }\n\n    /**\n     * Encoding value to a string so that we can set it on the cipher\n     */\n    const plainText = new MessageBuilder().build(payload, expiresIn)\n\n    /**\n     * Set final to the cipher instance and encrypt it\n     */\n    const cipherText = Buffer.concat([cipher.update(plainText), cipher.final()])\n\n    const tag = cipher.getAuthTag()\n\n    return this.computeReturns([\n      this.#config.id,\n      base64UrlEncode(cipherText),\n      base64UrlEncode(iv),\n      base64UrlEncode(tag),\n    ])\n  }\n\n  /**\n   * Decrypt value and verify it against a purpose\n   */\n  decrypt<T extends any>(value: string, purpose?: string): T | null {\n    if (typeof value !== 'string') {\n      return null\n    }\n\n    /**\n     * Make sure the encrypted value is in the correct format.\n     * i.e.: [id].[encrypted value].[iv].[tag]\n     */\n    const [id, cipherEncoded, ivEncoded, tagEncoded] = value.split(this.separator)\n    if (!id || !cipherEncoded || !ivEncoded || !tagEncoded) {\n      return null\n    }\n\n    /**\n     * Make sure the id is correct\n     */\n    if (id !== this.#config.id) {\n      return null\n    }\n\n    /**\n     * Make sure we are able to decode the encrypted value\n     */\n    const cipherText = base64UrlDecode(cipherEncoded)\n    if (!cipherText) {\n      return null\n    }\n\n    /**\n     * Make sure we are able to decode the iv\n     */\n    const iv = base64UrlDecode(ivEncoded)\n    if (!iv) {\n      return null\n    }\n\n    /**\n     * Make sure we are able to decode the tag\n     */\n    const tag = base64UrlDecode(tagEncoded)\n    if (!tag) {\n      return null\n    }\n\n    /**\n     * The Decipher can raise exceptions with malformed input, so we wrap it\n     * to avoid leaking sensitive information\n     */\n    try {\n      const decipher = createDecipheriv('chacha20-poly1305', this.cryptoKey, iv, {\n        authTagLength: 16,\n      })\n\n      if (purpose) {\n        decipher.setAAD(Buffer.from(purpose), { plaintextLength: Buffer.byteLength(purpose) })\n      }\n\n      decipher.setAuthTag(tag)\n\n      const plain = Buffer.concat([decipher.update(cipherText), decipher.final()])\n      return new MessageBuilder().verify(plain)\n    } catch {\n      return null\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;AAOA,SAAS,gBAAgB,kBAAkB,mBAAmB;AAC9D,SAAS,sBAAmC;AAiBrC,SAAS,iBAAiB,QAAsC;AACrE,SAAO;AAAA,IACL,QAAQ,CAAC,QAAQ,IAAI,iBAAiB,EAAE,IAAI,OAAO,IAAI,IAAI,CAAC;AAAA,IAC5D,MAAM,OAAO;AAAA,EACf;AACF;AAEO,IAAM,mBAAN,cAA+B,WAA+C;AAAA,EACnF;AAAA,EAEA,YAAY,QAAgC;AAC1C,UAAM,MAAM;AAEZ,SAAK,UAAU;AAEf,QAAI,OAAO,OAAO,OAAO,UAAU;AACjC,YAAM,IAAW,uBAAuB;AAAA,IAC1C;AAAA,EACF;AAAA,EAkBA,QACE,SACA,oBACA,SACY;AACZ,QAAI;AACJ,QAAI;AAEJ,QAAI,OAAO,uBAAuB,YAAY,uBAAuB,MAAM;AACzE,kBAAY,mBAAmB;AAC/B,sBAAgB,mBAAmB;AAAA,IACrC,OAAO;AACL,kBAAY;AACZ,sBAAgB;AAAA,IAClB;AAKA,UAAM,KAAK,YAAY,EAAE;AAKzB,UAAM,SAAS,eAAe,qBAAqB,KAAK,WAAW,IAAI;AAAA,MACrE,eAAe;AAAA,IACjB,CAAC;AAED,QAAI,eAAe;AACjB,aAAO,OAAO,OAAO,KAAK,aAAa,GAAG;AAAA,QACxC,iBAAiB,OAAO,WAAW,aAAa;AAAA,MAClD,CAAC;AAAA,IACH;AAKA,UAAM,YAAY,IAAI,eAAe,EAAE,MAAM,SAAS,SAAS;AAK/D,UAAM,aAAa,OAAO,OAAO,CAAC,OAAO,OAAO,SAAS,GAAG,OAAO,MAAM,CAAC,CAAC;AAE3E,UAAM,MAAM,OAAO,WAAW;AAE9B,WAAO,KAAK,eAAe;AAAA,MACzB,KAAK,QAAQ;AAAA,MACb,gBAAgB,UAAU;AAAA,MAC1B,gBAAgB,EAAE;AAAA,MAClB,gBAAgB,GAAG;AAAA,IACrB,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,QAAuB,OAAe,SAA4B;AAChE,QAAI,OAAO,UAAU,UAAU;AAC7B,aAAO;AAAA,IACT;AAMA,UAAM,CAAC,IAAI,eAAe,WAAW,UAAU,IAAI,MAAM,MAAM,KAAK,SAAS;AAC7E,QAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,aAAa,CAAC,YAAY;AACtD,aAAO;AAAA,IACT;AAKA,QAAI,OAAO,KAAK,QAAQ,IAAI;AAC1B,aAAO;AAAA,IACT;AAKA,UAAM,aAAa,gBAAgB,aAAa;AAChD,QAAI,CAAC,YAAY;AACf,aAAO;AAAA,IACT;AAKA,UAAM,KAAK,gBAAgB,SAAS;AACpC,QAAI,CAAC,IAAI;AACP,aAAO;AAAA,IACT;AAKA,UAAM,MAAM,gBAAgB,UAAU;AACtC,QAAI,CAAC,KAAK;AACR,aAAO;AAAA,IACT;AAMA,QAAI;AACF,YAAM,WAAW,iBAAiB,qBAAqB,KAAK,WAAW,IAAI;AAAA,QACzE,eAAe;AAAA,MACjB,CAAC;AAED,UAAI,SAAS;AACX,iBAAS,OAAO,OAAO,KAAK,OAAO,GAAG,EAAE,iBAAiB,OAAO,WAAW,OAAO,EAAE,CAAC;AAAA,MACvF;AAEA,eAAS,WAAW,GAAG;AAEvB,YAAM,QAAQ,OAAO,OAAO,CAAC,SAAS,OAAO,UAAU,GAAG,SAAS,MAAM,CAAC,CAAC;AAC3E,aAAO,IAAI,eAAe,EAAE,OAAO,KAAK;AAAA,IAC1C,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AACF;","names":[]}