import {
  __export,
  base64UrlEncode
} from "./chunk-ACZGKXGJ.js";

// src/drivers/base_driver.ts
import { createHash, createHmac, hkdfSync } from "crypto";
import { MessageBuilder } from "@poppinss/utils";

// src/exceptions.ts
var exceptions_exports = {};
__export(exceptions_exports, {
  E_BLIND_INDEX_PURPOSE_REQUIRED: () => E_BLIND_INDEX_PURPOSE_REQUIRED,
  E_DETERMINISTIC_DRIVER_EXPIRES_IN_NOT_SUPPORTED: () => E_DETERMINISTIC_DRIVER_EXPIRES_IN_NOT_SUPPORTED,
  E_INSECURE_ENCRYPTER_KEY: () => E_INSECURE_ENCRYPTER_KEY,
  E_INVALID_ENCRYPTER_ID: () => E_INVALID_ENCRYPTER_ID,
  E_MISSING_ENCRYPTER_ID: () => E_MISSING_ENCRYPTER_ID,
  E_MISSING_ENCRYPTER_KEY: () => E_MISSING_ENCRYPTER_KEY
});
import { createError } from "@poppinss/utils/exception";
var E_INSECURE_ENCRYPTER_KEY = createError(
  "The value of your key should be at least 16 characters long",
  "E_INSECURE_ENCRYPTER_KEY"
);
var E_MISSING_ENCRYPTER_KEY = createError(
  "Missing key. The key is required to encrypt values",
  "E_MISSING_ENCRYPTER_KEY"
);
var E_MISSING_ENCRYPTER_ID = createError(
  "Missing id. The id is required to encrypt values",
  "E_MISSING_ENCRYPTER_ID"
);
var E_INVALID_ENCRYPTER_ID = createError(
  'Invalid id. The id must be a non-empty string and cannot contain "."',
  "E_INVALID_ENCRYPTER_ID"
);
var E_DETERMINISTIC_DRIVER_EXPIRES_IN_NOT_SUPPORTED = createError(
  "Deterministic encryption does not support expiresIn",
  "E_DETERMINISTIC_DRIVER_EXPIRES_IN_NOT_SUPPORTED"
);
var E_BLIND_INDEX_PURPOSE_REQUIRED = createError(
  "Blind index requires a non-empty purpose",
  "E_BLIND_INDEX_PURPOSE_REQUIRED"
);

// src/drivers/base_driver.ts
var BaseDriver = class {
  /**
   * The key for encrypting values. It is derived
   * from the user provided secret.
   */
  cryptoKey;
  #blindIndexKey;
  /**
   * Use `dot` as a separator for joining encrypted value, iv and the
   * hmac hash. The idea is borrowed from JWTs.
   */
  separator = ".";
  constructor(config) {
    const key = this.#validateAndGetSecret(config.key);
    this.#validateId(config.id);
    this.cryptoKey = createHash("sha256").update(key).digest();
    const rawBlindIndexKey = hkdfSync(
      "sha256",
      this.cryptoKey,
      Buffer.alloc(0),
      Buffer.from(`blind-index:${config.id || "default"}`),
      32
    );
    this.#blindIndexKey = Buffer.isBuffer(rawBlindIndexKey) ? rawBlindIndexKey : Buffer.from(rawBlindIndexKey);
  }
  /**
   * Validates the app secret and returns it back as a string
   */
  #validateAndGetSecret(secret) {
    if (!secret) {
      throw new E_MISSING_ENCRYPTER_KEY();
    }
    const revealedSecret = typeof secret === "string" ? secret : secret.release();
    if (revealedSecret.length < 16) {
      throw new E_INSECURE_ENCRYPTER_KEY();
    }
    return revealedSecret;
  }
  /**
   * Validates encrypter id format when provided.
   */
  #validateId(id) {
    if (typeof id !== "string") {
      return;
    }
    if (id.trim().length === 0 || id.includes(this.separator)) {
      throw new E_INVALID_ENCRYPTER_ID();
    }
  }
  computeReturns(values) {
    return values.join(this.separator);
  }
  blindIndex(payload, purpose) {
    if (typeof purpose !== "string" || purpose.trim().length === 0) {
      throw new E_BLIND_INDEX_PURPOSE_REQUIRED();
    }
    const rawPayload = new MessageBuilder().build(payload);
    const payloadBuffer = Buffer.isBuffer(rawPayload) ? rawPayload : Buffer.from(rawPayload);
    const indexPayload = Buffer.concat([
      Buffer.from(purpose),
      Buffer.from(this.separator),
      payloadBuffer
    ]);
    return base64UrlEncode(createHmac("sha256", this.#blindIndexKey).update(indexPayload).digest());
  }
  blindIndexes(payload, purpose) {
    return [this.blindIndex(payload, purpose)];
  }
};

export {
  E_MISSING_ENCRYPTER_ID,
  E_DETERMINISTIC_DRIVER_EXPIRES_IN_NOT_SUPPORTED,
  exceptions_exports,
  BaseDriver
};
/*
 * @boringnode/encryption
 *
 * @license MIT
 * @copyright Boring Node
 */
//# sourceMappingURL=chunk-7R6WELCL.js.map