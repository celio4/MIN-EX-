import {
  Encryption
} from "./chunk-5QCRCQLG.js";
import "./chunk-SMDTGIFR.js";
import {
  Hmac
} from "./chunk-BCVNO66Y.js";
import "./chunk-RQR5RUKG.js";
import {
  BaseDriver,
  exceptions_exports
} from "./chunk-7R6WELCL.js";
import {
  base64UrlDecode,
  base64UrlEncode
} from "./chunk-ACZGKXGJ.js";

// src/encryption_manager.ts
import { RuntimeException } from "@poppinss/utils/exception";

// src/debug.ts
import { debuglog } from "util";
var debug_default = debuglog("boringnode:encryption");

// src/encryption_manager.ts
var EncryptionManager = class {
  /**
   * Encryption manager config with the
   * list of encrypters in use.
   */
  #config;
  /**
   * Cache of encryption instances.
   */
  #encryptionCache = {};
  constructor(config) {
    this.#config = config;
    debug_default("creating encryption manager. config: %O", this.#config);
  }
  /**
   * Use one of the registered encrypters to encrypt values.
   *
   * ```ts
   * manager.use() // returns default encrypter
   * manager.use('aes_256_cbc')
   * ```
   */
  use(encrypterName) {
    let encrypterToUse = encrypterName || this.#config.default;
    if (!encrypterToUse) {
      throw new RuntimeException(
        "Cannot create encryption instance. No default encryption is defined in the config"
      );
    }
    const cachedEncryption = this.#encryptionCache[encrypterToUse];
    if (cachedEncryption) {
      debug_default('using encrypter from cache. name: "%s"', encrypterToUse);
      return cachedEncryption;
    }
    const encrypterConfig = this.#config.list[encrypterToUse];
    debug_default('creating encryption instance. name: "%s"', encrypterToUse);
    const encryption = new Encryption(encrypterConfig);
    this.#encryptionCache[encrypterToUse] = encryption;
    return encryption;
  }
  getMessageVerifier() {
    return this.use().getMessageVerifier();
  }
  encrypt(payload, expiresInOrOptions, purpose) {
    let expiresIn;
    let actualPurpose;
    if (typeof expiresInOrOptions === "object" && expiresInOrOptions !== null) {
      expiresIn = expiresInOrOptions.expiresIn;
      actualPurpose = expiresInOrOptions.purpose;
    } else {
      expiresIn = expiresInOrOptions;
      actualPurpose = purpose;
    }
    return this.use().encrypt(payload, expiresIn, actualPurpose);
  }
  decrypt(value, purpose) {
    return this.use().decrypt(value, purpose);
  }
  blindIndex(payload, purpose) {
    return this.use().blindIndex(payload, purpose);
  }
  blindIndexes(payload, purpose) {
    return this.use().blindIndexes(payload, purpose);
  }
};
export {
  BaseDriver,
  Encryption,
  EncryptionManager,
  Hmac,
  base64UrlDecode,
  base64UrlEncode,
  exceptions_exports as errors
};
/*
 * @boringnode/encryption
 *
 * @license MIT
 * @copyright Boring Node
 */
//# sourceMappingURL=index.js.map