{"version":3,"sources":["../../../src/drivers/aes_siv.ts"],"sourcesContent":["/*\n * @boringnode/encryption\n *\n * @license MIT\n * @copyright Boring Node\n */\n\nimport { createCipheriv, createDecipheriv, hkdfSync } from 'node:crypto'\nimport { MessageBuilder, type Secret } from '@poppinss/utils'\nimport { BaseDriver } from './base_driver.ts'\nimport { base64UrlDecode, base64UrlEncode } from '../base64.ts'\nimport * as errors from '../exceptions.ts'\nimport { safeEqual } from '../safe_equal.ts'\nimport type {\n  AESSIVConfig,\n  CypherText,\n  EncryptionConfig,\n  EncryptionDriverContract,\n  EncryptOptions,\n} from '../types/main.ts'\n\nexport interface AESSIVDriverConfig {\n  id: string\n  key: string | Secret<string>\n}\n\nexport function aessiv(config: AESSIVDriverConfig) {\n  return {\n    driver: (key) => new AESSIV({ id: config.id, key }),\n    keys: [config.key],\n  } satisfies EncryptionConfig\n}\n\nexport class AESSIV extends BaseDriver implements EncryptionDriverContract {\n  #config: AESSIVConfig\n  static readonly #BLOCK_SIZE = 16\n  static readonly #ZERO_BLOCK = Buffer.alloc(AESSIV.#BLOCK_SIZE, 0)\n\n  constructor(config: AESSIVConfig) {\n    super(config)\n\n    this.#config = config\n\n    if (typeof config.id !== 'string') {\n      throw new errors.E_MISSING_ENCRYPTER_ID()\n    }\n  }\n\n  encrypt(payload: any, options?: EncryptOptions): CypherText\n  encrypt(payload: any, expiresIn?: string | number, purpose?: string): CypherText\n  encrypt(\n    payload: any,\n    expiresInOrOptions?: string | number | EncryptOptions,\n    purpose?: string\n  ): CypherText {\n    let expiresIn: string | number | undefined\n    let actualPurpose: string | undefined\n\n    if (typeof expiresInOrOptions === 'object' && expiresInOrOptions !== null) {\n      expiresIn = expiresInOrOptions.expiresIn\n      actualPurpose = expiresInOrOptions.purpose\n    } else {\n      expiresIn = expiresInOrOptions\n      actualPurpose = purpose\n    }\n\n    if (expiresIn !== undefined) {\n      throw new errors.E_DETERMINISTIC_DRIVER_EXPIRES_IN_NOT_SUPPORTED()\n    }\n\n    const { macKey, encryptionKey } = this.#deriveKeys()\n    const plainTextValue = new MessageBuilder().build(payload)\n    const plainText = Buffer.isBuffer(plainTextValue) ? plainTextValue : Buffer.from(plainTextValue)\n    const associatedData = actualPurpose ? [Buffer.from(actualPurpose)] : []\n\n    const { syntheticIv, cipherText } = AESSIV.encryptRaw(\n      macKey,\n      encryptionKey,\n      plainText,\n      associatedData\n    )\n\n    return this.computeReturns([\n      this.#config.id,\n      base64UrlEncode(cipherText),\n      base64UrlEncode(syntheticIv),\n    ])\n  }\n\n  decrypt<T extends any>(value: string, purpose?: string): T | null {\n    if (typeof value !== 'string') {\n      return null\n    }\n\n    const parts = value.split(this.separator)\n    if (parts.length !== 3) {\n      return null\n    }\n\n    const [id, cipherEncoded, syntheticIvEncoded] = parts\n    if (!id || !cipherEncoded || !syntheticIvEncoded) {\n      return null\n    }\n\n    if (id !== this.#config.id) {\n      return null\n    }\n\n    const cipherText = base64UrlDecode(cipherEncoded)\n    if (!cipherText) {\n      return null\n    }\n\n    const syntheticIv = base64UrlDecode(syntheticIvEncoded)\n    if (!syntheticIv || syntheticIv.length !== AESSIV.#BLOCK_SIZE) {\n      return null\n    }\n\n    try {\n      const { macKey, encryptionKey } = this.#deriveKeys()\n      const associatedData = purpose ? [Buffer.from(purpose)] : []\n      const plainText = AESSIV.decryptRaw(\n        macKey,\n        encryptionKey,\n        syntheticIv,\n        cipherText,\n        associatedData\n      )\n      if (!plainText) return null\n\n      return new MessageBuilder().verify(plainText)\n    } catch {\n      return null\n    }\n  }\n\n  #deriveKeys() {\n    const rawDerivedKey = hkdfSync(\n      'sha256',\n      this.cryptoKey,\n      Buffer.alloc(0),\n      Buffer.from(`aes-siv:${this.#config.id}`),\n      64\n    )\n\n    const derivedKey = Buffer.isBuffer(rawDerivedKey) ? rawDerivedKey : Buffer.from(rawDerivedKey)\n\n    return {\n      macKey: derivedKey.subarray(0, 32),\n      encryptionKey: derivedKey.subarray(32),\n    }\n  }\n\n  /**\n   * Low-level AES-SIV primitive. Exposed as static for RFC 5297 conformance tests.\n   */\n  static encryptRaw(\n    macKey: Buffer,\n    encryptionKey: Buffer,\n    plainText: Buffer,\n    associatedData: Buffer[] = []\n  ): {\n    syntheticIv: Buffer\n    cipherText: Buffer\n  } {\n    AESSIV.#ensureSupportedKeyLength(macKey, encryptionKey)\n\n    const syntheticIv = AESSIV.#s2v(macKey, associatedData, plainText)\n    const iv = AESSIV.#toCtrIv(syntheticIv)\n    const cipher = createCipheriv(AESSIV.#getCtrAlgorithm(encryptionKey), encryptionKey, iv)\n    const cipherText = Buffer.concat([cipher.update(plainText), cipher.final()])\n\n    return { syntheticIv, cipherText }\n  }\n\n  static decryptRaw(\n    macKey: Buffer,\n    encryptionKey: Buffer,\n    syntheticIv: Buffer,\n    cipherText: Buffer,\n    associatedData: Buffer[] = []\n  ): Buffer | null {\n    AESSIV.#ensureSupportedKeyLength(macKey, encryptionKey)\n\n    const iv = AESSIV.#toCtrIv(syntheticIv)\n    const decipher = createDecipheriv(AESSIV.#getCtrAlgorithm(encryptionKey), encryptionKey, iv)\n    const plainText = Buffer.concat([decipher.update(cipherText), decipher.final()])\n    const expectedSyntheticIv = AESSIV.#s2v(macKey, associatedData, plainText)\n\n    if (!safeEqual(expectedSyntheticIv, syntheticIv)) {\n      return null\n    }\n\n    return plainText\n  }\n  static #toCtrIv(syntheticIv: Buffer): Buffer {\n    const iv = Buffer.from(syntheticIv)\n    iv[8] &= 0x7f\n    iv[12] &= 0x7f\n    return iv\n  }\n\n  static #s2v(macKey: Buffer, associatedData: Buffer[], plainText: Buffer): Buffer {\n    let d = AESSIV.#cmac(macKey, AESSIV.#ZERO_BLOCK)\n\n    for (const item of associatedData) {\n      d = AESSIV.#xorBuffers(AESSIV.#dbl(d), AESSIV.#cmac(macKey, item))\n    }\n\n    const t =\n      plainText.length >= AESSIV.#BLOCK_SIZE\n        ? AESSIV.#xorEnd(plainText, d)\n        : AESSIV.#xorBuffers(AESSIV.#dbl(d), AESSIV.#pad(plainText))\n\n    return AESSIV.#cmac(macKey, t)\n  }\n\n  static #cmac(key: Buffer, message: Buffer): Buffer {\n    const l = AESSIV.#aesEcbEncryptBlock(key, AESSIV.#ZERO_BLOCK)\n    const k1 = AESSIV.#dbl(l)\n    const k2 = AESSIV.#dbl(k1)\n\n    let blockCount = Math.ceil(message.length / AESSIV.#BLOCK_SIZE)\n    blockCount = blockCount === 0 ? 1 : blockCount\n\n    const isLastBlockComplete = message.length !== 0 && message.length % AESSIV.#BLOCK_SIZE === 0\n    let lastBlock: Buffer\n    if (isLastBlockComplete) {\n      const lastStart = (blockCount - 1) * AESSIV.#BLOCK_SIZE\n      lastBlock = AESSIV.#xorBuffers(\n        message.subarray(lastStart, lastStart + AESSIV.#BLOCK_SIZE),\n        k1\n      )\n    } else {\n      const lastStart = (blockCount - 1) * AESSIV.#BLOCK_SIZE\n      lastBlock = AESSIV.#xorBuffers(AESSIV.#pad(message.subarray(lastStart)), k2)\n    }\n\n    let x: Buffer<ArrayBufferLike> = Buffer.alloc(AESSIV.#BLOCK_SIZE, 0)\n    for (let index = 0; index < blockCount - 1; index++) {\n      const start = index * AESSIV.#BLOCK_SIZE\n      const block = message.subarray(start, start + AESSIV.#BLOCK_SIZE)\n      x = AESSIV.#aesEcbEncryptBlock(key, AESSIV.#xorBuffers(x, block))\n    }\n\n    return AESSIV.#aesEcbEncryptBlock(key, AESSIV.#xorBuffers(x, lastBlock))\n  }\n\n  static #aesEcbEncryptBlock(key: Buffer, block: Buffer): Buffer {\n    const cipher = createCipheriv(AESSIV.#getEcbAlgorithm(key), key, null)\n    cipher.setAutoPadding(false)\n    return Buffer.concat([cipher.update(block), cipher.final()])\n  }\n\n  static #dbl(block: Buffer): Buffer {\n    const output = Buffer.alloc(AESSIV.#BLOCK_SIZE)\n    const msbSet = (block[0] & 0x80) !== 0\n\n    let carry = 0\n    for (let index = AESSIV.#BLOCK_SIZE - 1; index >= 0; index--) {\n      const value = block[index]\n      output[index] = ((value << 1) & 0xff) | carry\n      carry = (value & 0x80) !== 0 ? 1 : 0\n    }\n\n    if (msbSet) {\n      output[AESSIV.#BLOCK_SIZE - 1] ^= 0x87\n    }\n\n    return output\n  }\n\n  static #xorBuffers(left: Buffer, right: Buffer): Buffer {\n    const output = Buffer.alloc(left.length)\n    for (const [index, value] of left.entries()) {\n      output[index] = value ^ right[index]\n    }\n    return output\n  }\n\n  static #xorEnd(buffer: Buffer, block: Buffer): Buffer {\n    const output = Buffer.from(buffer)\n    const offset = output.length - AESSIV.#BLOCK_SIZE\n    for (let index = 0; index < AESSIV.#BLOCK_SIZE; index++) {\n      output[offset + index] ^= block[index]\n    }\n    return output\n  }\n\n  static #pad(buffer: Buffer): Buffer {\n    const output = Buffer.alloc(AESSIV.#BLOCK_SIZE, 0)\n    buffer.copy(output)\n    output[buffer.length] = 0x80\n    return output\n  }\n\n  static #getEcbAlgorithm(key: Buffer): 'aes-128-ecb' | 'aes-192-ecb' | 'aes-256-ecb' {\n    switch (key.length) {\n      case 16: {\n        return 'aes-128-ecb'\n      }\n      case 24: {\n        return 'aes-192-ecb'\n      }\n      case 32: {\n        return 'aes-256-ecb'\n      }\n      default: {\n        throw new TypeError('Invalid AES key length for SIV')\n      }\n    }\n  }\n\n  static #getCtrAlgorithm(key: Buffer): 'aes-128-ctr' | 'aes-192-ctr' | 'aes-256-ctr' {\n    switch (key.length) {\n      case 16: {\n        return 'aes-128-ctr'\n      }\n      case 24: {\n        return 'aes-192-ctr'\n      }\n      case 32: {\n        return 'aes-256-ctr'\n      }\n      default: {\n        throw new TypeError('Invalid AES key length for SIV')\n      }\n    }\n  }\n\n  static #ensureSupportedKeyLength(macKey: Buffer, encryptionKey: Buffer) {\n    if (macKey.length !== encryptionKey.length) {\n      throw new TypeError('SIV subkeys must have the same length')\n    }\n\n    AESSIV.#getEcbAlgorithm(macKey)\n    AESSIV.#getCtrAlgorithm(encryptionKey)\n  }\n}\n"],"mappings":"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","names":[]}