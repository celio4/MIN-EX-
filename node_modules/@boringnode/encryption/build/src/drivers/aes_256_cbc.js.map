{"version":3,"sources":["../../../src/drivers/aes_256_cbc.ts"],"sourcesContent":["/*\n * @boringnode/encryption\n *\n * @license MIT\n * @copyright Boring Node\n */\n\nimport { createCipheriv, createDecipheriv, hkdfSync, randomBytes } from 'node:crypto'\nimport { MessageBuilder, type Secret } from '@poppinss/utils'\nimport { BaseDriver } from './base_driver.ts'\nimport { Hmac } from '../hmac.ts'\nimport * as errors from '../exceptions.ts'\nimport type {\n  AES256CBCConfig,\n  CypherText,\n  EncryptionConfig,\n  EncryptionDriverContract,\n  EncryptOptions,\n} from '../types/main.ts'\nimport { base64UrlDecode, base64UrlEncode } from '../base64.ts'\n\nexport interface AES256CBCDriverConfig {\n  id: string\n  keys: (string | Secret<string>)[]\n}\n\nexport function aes256cbc(config: AES256CBCDriverConfig) {\n  return {\n    driver: (key) => new AES256CBC({ id: config.id, key }),\n    keys: config.keys,\n  } satisfies EncryptionConfig\n}\n\nexport class AES256CBC extends BaseDriver implements EncryptionDriverContract {\n  #config: AES256CBCConfig\n\n  constructor(config: AES256CBCConfig) {\n    super(config)\n\n    this.#config = config\n\n    if (typeof config.id !== 'string') {\n      throw new errors.E_MISSING_ENCRYPTER_ID()\n    }\n  }\n\n  /**\n   * Encrypt a given piece of value using the app secret. A wide range of\n   * data types are supported.\n   *\n   * - String\n   * - Arrays\n   * - Objects\n   * - Booleans\n   * - Numbers\n   * - Dates\n   *\n   * You can optionally define a purpose for which the value was encrypted and\n   * mentioning a different purpose/no purpose during decrypt will fail.\n   */\n  encrypt(payload: any, options?: EncryptOptions): CypherText\n  encrypt(payload: any, expiresIn?: string | number, purpose?: string): CypherText\n  encrypt(\n    payload: any,\n    expiresInOrOptions?: string | number | EncryptOptions,\n    purpose?: string\n  ): CypherText {\n    let expiresIn: string | number | undefined\n    let actualPurpose: string | undefined\n\n    if (typeof expiresInOrOptions === 'object' && expiresInOrOptions !== null) {\n      expiresIn = expiresInOrOptions.expiresIn\n      actualPurpose = expiresInOrOptions.purpose\n    } else {\n      expiresIn = expiresInOrOptions\n      actualPurpose = purpose\n    }\n\n    /**\n     * Using a random string as the iv for generating unpredictable values\n     */\n    const iv = randomBytes(16)\n\n    const { encryptionKey, authenticationKey } = this.#deriveKey(this.cryptoKey, iv)\n\n    /**\n     * Creating chiper\n     */\n    const cipher = createCipheriv('aes-256-cbc', encryptionKey, iv)\n\n    /**\n     * Encoding value to a string so that we can set it on the cipher\n     */\n    const plainText = new MessageBuilder().build(payload, expiresIn, actualPurpose)\n\n    /**\n     * Set final to the cipher instance and encrypt it\n     */\n    const cipherText = Buffer.concat([cipher.update(plainText), cipher.final()])\n\n    /**\n     * Concatenate `encrypted value` and `iv` by urlEncoding them. The concatenation is required\n     * to generate the HMAC, so that HMAC checks for integrity of both the `encrypted value`\n     * and the `iv`.\n     */\n    const macPayload = `${base64UrlEncode(cipherText)}${this.separator}${base64UrlEncode(iv)}`\n\n    /**\n     * Returns the id + result + hmac\n     */\n    const hmac = new Hmac(authenticationKey).generate(macPayload)\n    return this.computeReturns([this.#config.id, macPayload, hmac])\n  }\n\n  /**\n   * Decrypt value and verify it against a purpose\n   */\n  decrypt<T extends any>(value: string, purpose?: string): T | null {\n    if (typeof value !== 'string') {\n      return null\n    }\n\n    /**\n     * Make sure the encrypted value is in the correct format.\n     * i.e.: [id].[encrypted value].[iv].[mac]\n     */\n    const [id, cipherEncoded, ivEncoded, macEncoded] = value.split(this.separator)\n    if (!id || !cipherEncoded || !ivEncoded || !macEncoded) {\n      return null\n    }\n\n    /**\n     * Make sure the id is correct\n     */\n    if (id !== this.#config.id) {\n      return null\n    }\n\n    /**\n     * Make sure we are able to decode the encrypted value\n     */\n    const cipherText = base64UrlDecode(cipherEncoded)\n    if (!cipherText) {\n      return null\n    }\n\n    /**\n     * Make sure we are able to decode the iv\n     */\n    const iv = base64UrlDecode(ivEncoded)\n    if (!iv) {\n      return null\n    }\n\n    /**\n     * Make sure the hash is correct, it means the first 2 parts of the\n     * string are not tampered.\n     */\n    const { encryptionKey, authenticationKey } = this.#deriveKey(this.cryptoKey, iv)\n\n    const isValidHmac = new Hmac(authenticationKey).compare(\n      `${cipherEncoded}${this.separator}${ivEncoded}`,\n      macEncoded\n    )\n\n    if (!isValidHmac) {\n      return null\n    }\n\n    /**\n     * The Decipher can raise exceptions with malformed input, so we wrap it\n     * to avoid leaking sensitive information\n     */\n    try {\n      const decipher = createDecipheriv('aes-256-cbc', encryptionKey, iv)\n      const plainTextBuffer = Buffer.concat([decipher.update(cipherText), decipher.final()])\n      return new MessageBuilder().verify(plainTextBuffer, purpose)\n    } catch {\n      return null\n    }\n  }\n\n  #deriveKey(masterKey: Buffer, iv: Buffer) {\n    const info = Buffer.from(this.#config.id)\n    const rawDerivedKey = hkdfSync('sha256', masterKey, iv, info, 64)\n\n    const derivedKey = Buffer.isBuffer(rawDerivedKey) ? rawDerivedKey : Buffer.from(rawDerivedKey)\n\n    return {\n      encryptionKey: derivedKey.subarray(0, 32),\n      authenticationKey: derivedKey.subarray(32),\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;AAOA,SAAS,gBAAgB,kBAAkB,UAAU,mBAAmB;AACxE,SAAS,sBAAmC;AAkBrC,SAAS,UAAU,QAA+B;AACvD,SAAO;AAAA,IACL,QAAQ,CAAC,QAAQ,IAAI,UAAU,EAAE,IAAI,OAAO,IAAI,IAAI,CAAC;AAAA,IACrD,MAAM,OAAO;AAAA,EACf;AACF;AAEO,IAAM,YAAN,cAAwB,WAA+C;AAAA,EAC5E;AAAA,EAEA,YAAY,QAAyB;AACnC,UAAM,MAAM;AAEZ,SAAK,UAAU;AAEf,QAAI,OAAO,OAAO,OAAO,UAAU;AACjC,YAAM,IAAW,uBAAuB;AAAA,IAC1C;AAAA,EACF;AAAA,EAkBA,QACE,SACA,oBACA,SACY;AACZ,QAAI;AACJ,QAAI;AAEJ,QAAI,OAAO,uBAAuB,YAAY,uBAAuB,MAAM;AACzE,kBAAY,mBAAmB;AAC/B,sBAAgB,mBAAmB;AAAA,IACrC,OAAO;AACL,kBAAY;AACZ,sBAAgB;AAAA,IAClB;AAKA,UAAM,KAAK,YAAY,EAAE;AAEzB,UAAM,EAAE,eAAe,kBAAkB,IAAI,KAAK,WAAW,KAAK,WAAW,EAAE;AAK/E,UAAM,SAAS,eAAe,eAAe,eAAe,EAAE;AAK9D,UAAM,YAAY,IAAI,eAAe,EAAE,MAAM,SAAS,WAAW,aAAa;AAK9E,UAAM,aAAa,OAAO,OAAO,CAAC,OAAO,OAAO,SAAS,GAAG,OAAO,MAAM,CAAC,CAAC;AAO3E,UAAM,aAAa,GAAG,gBAAgB,UAAU,CAAC,GAAG,KAAK,SAAS,GAAG,gBAAgB,EAAE,CAAC;AAKxF,UAAM,OAAO,IAAI,KAAK,iBAAiB,EAAE,SAAS,UAAU;AAC5D,WAAO,KAAK,eAAe,CAAC,KAAK,QAAQ,IAAI,YAAY,IAAI,CAAC;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA,EAKA,QAAuB,OAAe,SAA4B;AAChE,QAAI,OAAO,UAAU,UAAU;AAC7B,aAAO;AAAA,IACT;AAMA,UAAM,CAAC,IAAI,eAAe,WAAW,UAAU,IAAI,MAAM,MAAM,KAAK,SAAS;AAC7E,QAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,aAAa,CAAC,YAAY;AACtD,aAAO;AAAA,IACT;AAKA,QAAI,OAAO,KAAK,QAAQ,IAAI;AAC1B,aAAO;AAAA,IACT;AAKA,UAAM,aAAa,gBAAgB,aAAa;AAChD,QAAI,CAAC,YAAY;AACf,aAAO;AAAA,IACT;AAKA,UAAM,KAAK,gBAAgB,SAAS;AACpC,QAAI,CAAC,IAAI;AACP,aAAO;AAAA,IACT;AAMA,UAAM,EAAE,eAAe,kBAAkB,IAAI,KAAK,WAAW,KAAK,WAAW,EAAE;AAE/E,UAAM,cAAc,IAAI,KAAK,iBAAiB,EAAE;AAAA,MAC9C,GAAG,aAAa,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,MAC7C;AAAA,IACF;AAEA,QAAI,CAAC,aAAa;AAChB,aAAO;AAAA,IACT;AAMA,QAAI;AACF,YAAM,WAAW,iBAAiB,eAAe,eAAe,EAAE;AAClE,YAAM,kBAAkB,OAAO,OAAO,CAAC,SAAS,OAAO,UAAU,GAAG,SAAS,MAAM,CAAC,CAAC;AACrF,aAAO,IAAI,eAAe,EAAE,OAAO,iBAAiB,OAAO;AAAA,IAC7D,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEA,WAAW,WAAmB,IAAY;AACxC,UAAM,OAAO,OAAO,KAAK,KAAK,QAAQ,EAAE;AACxC,UAAM,gBAAgB,SAAS,UAAU,WAAW,IAAI,MAAM,EAAE;AAEhE,UAAM,aAAa,OAAO,SAAS,aAAa,IAAI,gBAAgB,OAAO,KAAK,aAAa;AAE7F,WAAO;AAAA,MACL,eAAe,WAAW,SAAS,GAAG,EAAE;AAAA,MACxC,mBAAmB,WAAW,SAAS,EAAE;AAAA,IAC3C;AAAA,EACF;AACF;","names":[]}