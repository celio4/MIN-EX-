import {
  Hmac
} from "../../chunk-BCVNO66Y.js";
import "../../chunk-RQR5RUKG.js";
import {
  BaseDriver,
  E_MISSING_ENCRYPTER_ID
} from "../../chunk-7R6WELCL.js";
import {
  base64UrlDecode,
  base64UrlEncode
} from "../../chunk-ACZGKXGJ.js";

// src/drivers/aes_256_cbc.ts
import { createCipheriv, createDecipheriv, hkdfSync, randomBytes } from "crypto";
import { MessageBuilder } from "@poppinss/utils";
function aes256cbc(config) {
  return {
    driver: (key) => new AES256CBC({ id: config.id, key }),
    keys: config.keys
  };
}
var AES256CBC = class extends BaseDriver {
  #config;
  constructor(config) {
    super(config);
    this.#config = config;
    if (typeof config.id !== "string") {
      throw new E_MISSING_ENCRYPTER_ID();
    }
  }
  encrypt(payload, expiresInOrOptions, purpose) {
    let expiresIn;
    let actualPurpose;
    if (typeof expiresInOrOptions === "object" && expiresInOrOptions !== null) {
      expiresIn = expiresInOrOptions.expiresIn;
      actualPurpose = expiresInOrOptions.purpose;
    } else {
      expiresIn = expiresInOrOptions;
      actualPurpose = purpose;
    }
    const iv = randomBytes(16);
    const { encryptionKey, authenticationKey } = this.#deriveKey(this.cryptoKey, iv);
    const cipher = createCipheriv("aes-256-cbc", encryptionKey, iv);
    const plainText = new MessageBuilder().build(payload, expiresIn, actualPurpose);
    const cipherText = Buffer.concat([cipher.update(plainText), cipher.final()]);
    const macPayload = `${base64UrlEncode(cipherText)}${this.separator}${base64UrlEncode(iv)}`;
    const hmac = new Hmac(authenticationKey).generate(macPayload);
    return this.computeReturns([this.#config.id, macPayload, hmac]);
  }
  /**
   * Decrypt value and verify it against a purpose
   */
  decrypt(value, purpose) {
    if (typeof value !== "string") {
      return null;
    }
    const [id, cipherEncoded, ivEncoded, macEncoded] = value.split(this.separator);
    if (!id || !cipherEncoded || !ivEncoded || !macEncoded) {
      return null;
    }
    if (id !== this.#config.id) {
      return null;
    }
    const cipherText = base64UrlDecode(cipherEncoded);
    if (!cipherText) {
      return null;
    }
    const iv = base64UrlDecode(ivEncoded);
    if (!iv) {
      return null;
    }
    const { encryptionKey, authenticationKey } = this.#deriveKey(this.cryptoKey, iv);
    const isValidHmac = new Hmac(authenticationKey).compare(
      `${cipherEncoded}${this.separator}${ivEncoded}`,
      macEncoded
    );
    if (!isValidHmac) {
      return null;
    }
    try {
      const decipher = createDecipheriv("aes-256-cbc", encryptionKey, iv);
      const plainTextBuffer = Buffer.concat([decipher.update(cipherText), decipher.final()]);
      return new MessageBuilder().verify(plainTextBuffer, purpose);
    } catch {
      return null;
    }
  }
  #deriveKey(masterKey, iv) {
    const info = Buffer.from(this.#config.id);
    const rawDerivedKey = hkdfSync("sha256", masterKey, iv, info, 64);
    const derivedKey = Buffer.isBuffer(rawDerivedKey) ? rawDerivedKey : Buffer.from(rawDerivedKey);
    return {
      encryptionKey: derivedKey.subarray(0, 32),
      authenticationKey: derivedKey.subarray(32)
    };
  }
};
export {
  AES256CBC,
  aes256cbc
};
/*
 * @boringnode/encryption
 *
 * @license MIT
 * @copyright Boring Node
 */
//# sourceMappingURL=aes_256_cbc.js.map