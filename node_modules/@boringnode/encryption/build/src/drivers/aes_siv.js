import {
  safeEqual
} from "../../chunk-RQR5RUKG.js";
import {
  BaseDriver,
  E_DETERMINISTIC_DRIVER_EXPIRES_IN_NOT_SUPPORTED,
  E_MISSING_ENCRYPTER_ID
} from "../../chunk-7R6WELCL.js";
import {
  base64UrlDecode,
  base64UrlEncode
} from "../../chunk-ACZGKXGJ.js";

// src/drivers/aes_siv.ts
import { createCipheriv, createDecipheriv, hkdfSync } from "crypto";
import { MessageBuilder } from "@poppinss/utils";
function aessiv(config) {
  return {
    driver: (key) => new AESSIV({ id: config.id, key }),
    keys: [config.key]
  };
}
var AESSIV = class _AESSIV extends BaseDriver {
  #config;
  static #BLOCK_SIZE = 16;
  static #ZERO_BLOCK = Buffer.alloc(_AESSIV.#BLOCK_SIZE, 0);
  constructor(config) {
    super(config);
    this.#config = config;
    if (typeof config.id !== "string") {
      throw new E_MISSING_ENCRYPTER_ID();
    }
  }
  encrypt(payload, expiresInOrOptions, purpose) {
    let expiresIn;
    let actualPurpose;
    if (typeof expiresInOrOptions === "object" && expiresInOrOptions !== null) {
      expiresIn = expiresInOrOptions.expiresIn;
      actualPurpose = expiresInOrOptions.purpose;
    } else {
      expiresIn = expiresInOrOptions;
      actualPurpose = purpose;
    }
    if (expiresIn !== void 0) {
      throw new E_DETERMINISTIC_DRIVER_EXPIRES_IN_NOT_SUPPORTED();
    }
    const { macKey, encryptionKey } = this.#deriveKeys();
    const plainTextValue = new MessageBuilder().build(payload);
    const plainText = Buffer.isBuffer(plainTextValue) ? plainTextValue : Buffer.from(plainTextValue);
    const associatedData = actualPurpose ? [Buffer.from(actualPurpose)] : [];
    const { syntheticIv, cipherText } = _AESSIV.encryptRaw(
      macKey,
      encryptionKey,
      plainText,
      associatedData
    );
    return this.computeReturns([
      this.#config.id,
      base64UrlEncode(cipherText),
      base64UrlEncode(syntheticIv)
    ]);
  }
  decrypt(value, purpose) {
    if (typeof value !== "string") {
      return null;
    }
    const parts = value.split(this.separator);
    if (parts.length !== 3) {
      return null;
    }
    const [id, cipherEncoded, syntheticIvEncoded] = parts;
    if (!id || !cipherEncoded || !syntheticIvEncoded) {
      return null;
    }
    if (id !== this.#config.id) {
      return null;
    }
    const cipherText = base64UrlDecode(cipherEncoded);
    if (!cipherText) {
      return null;
    }
    const syntheticIv = base64UrlDecode(syntheticIvEncoded);
    if (!syntheticIv || syntheticIv.length !== _AESSIV.#BLOCK_SIZE) {
      return null;
    }
    try {
      const { macKey, encryptionKey } = this.#deriveKeys();
      const associatedData = purpose ? [Buffer.from(purpose)] : [];
      const plainText = _AESSIV.decryptRaw(
        macKey,
        encryptionKey,
        syntheticIv,
        cipherText,
        associatedData
      );
      if (!plainText) return null;
      return new MessageBuilder().verify(plainText);
    } catch {
      return null;
    }
  }
  #deriveKeys() {
    const rawDerivedKey = hkdfSync(
      "sha256",
      this.cryptoKey,
      Buffer.alloc(0),
      Buffer.from(`aes-siv:${this.#config.id}`),
      64
    );
    const derivedKey = Buffer.isBuffer(rawDerivedKey) ? rawDerivedKey : Buffer.from(rawDerivedKey);
    return {
      macKey: derivedKey.subarray(0, 32),
      encryptionKey: derivedKey.subarray(32)
    };
  }
  /**
   * Low-level AES-SIV primitive. Exposed as static for RFC 5297 conformance tests.
   */
  static encryptRaw(macKey, encryptionKey, plainText, associatedData = []) {
    _AESSIV.#ensureSupportedKeyLength(macKey, encryptionKey);
    const syntheticIv = _AESSIV.#s2v(macKey, associatedData, plainText);
    const iv = _AESSIV.#toCtrIv(syntheticIv);
    const cipher = createCipheriv(_AESSIV.#getCtrAlgorithm(encryptionKey), encryptionKey, iv);
    const cipherText = Buffer.concat([cipher.update(plainText), cipher.final()]);
    return { syntheticIv, cipherText };
  }
  static decryptRaw(macKey, encryptionKey, syntheticIv, cipherText, associatedData = []) {
    _AESSIV.#ensureSupportedKeyLength(macKey, encryptionKey);
    const iv = _AESSIV.#toCtrIv(syntheticIv);
    const decipher = createDecipheriv(_AESSIV.#getCtrAlgorithm(encryptionKey), encryptionKey, iv);
    const plainText = Buffer.concat([decipher.update(cipherText), decipher.final()]);
    const expectedSyntheticIv = _AESSIV.#s2v(macKey, associatedData, plainText);
    if (!safeEqual(expectedSyntheticIv, syntheticIv)) {
      return null;
    }
    return plainText;
  }
  static #toCtrIv(syntheticIv) {
    const iv = Buffer.from(syntheticIv);
    iv[8] &= 127;
    iv[12] &= 127;
    return iv;
  }
  static #s2v(macKey, associatedData, plainText) {
    let d = _AESSIV.#cmac(macKey, _AESSIV.#ZERO_BLOCK);
    for (const item of associatedData) {
      d = _AESSIV.#xorBuffers(_AESSIV.#dbl(d), _AESSIV.#cmac(macKey, item));
    }
    const t = plainText.length >= _AESSIV.#BLOCK_SIZE ? _AESSIV.#xorEnd(plainText, d) : _AESSIV.#xorBuffers(_AESSIV.#dbl(d), _AESSIV.#pad(plainText));
    return _AESSIV.#cmac(macKey, t);
  }
  static #cmac(key, message) {
    const l = _AESSIV.#aesEcbEncryptBlock(key, _AESSIV.#ZERO_BLOCK);
    const k1 = _AESSIV.#dbl(l);
    const k2 = _AESSIV.#dbl(k1);
    let blockCount = Math.ceil(message.length / _AESSIV.#BLOCK_SIZE);
    blockCount = blockCount === 0 ? 1 : blockCount;
    const isLastBlockComplete = message.length !== 0 && message.length % _AESSIV.#BLOCK_SIZE === 0;
    let lastBlock;
    if (isLastBlockComplete) {
      const lastStart = (blockCount - 1) * _AESSIV.#BLOCK_SIZE;
      lastBlock = _AESSIV.#xorBuffers(
        message.subarray(lastStart, lastStart + _AESSIV.#BLOCK_SIZE),
        k1
      );
    } else {
      const lastStart = (blockCount - 1) * _AESSIV.#BLOCK_SIZE;
      lastBlock = _AESSIV.#xorBuffers(_AESSIV.#pad(message.subarray(lastStart)), k2);
    }
    let x = Buffer.alloc(_AESSIV.#BLOCK_SIZE, 0);
    for (let index = 0; index < blockCount - 1; index++) {
      const start = index * _AESSIV.#BLOCK_SIZE;
      const block = message.subarray(start, start + _AESSIV.#BLOCK_SIZE);
      x = _AESSIV.#aesEcbEncryptBlock(key, _AESSIV.#xorBuffers(x, block));
    }
    return _AESSIV.#aesEcbEncryptBlock(key, _AESSIV.#xorBuffers(x, lastBlock));
  }
  static #aesEcbEncryptBlock(key, block) {
    const cipher = createCipheriv(_AESSIV.#getEcbAlgorithm(key), key, null);
    cipher.setAutoPadding(false);
    return Buffer.concat([cipher.update(block), cipher.final()]);
  }
  static #dbl(block) {
    const output = Buffer.alloc(_AESSIV.#BLOCK_SIZE);
    const msbSet = (block[0] & 128) !== 0;
    let carry = 0;
    for (let index = _AESSIV.#BLOCK_SIZE - 1; index >= 0; index--) {
      const value = block[index];
      output[index] = value << 1 & 255 | carry;
      carry = (value & 128) !== 0 ? 1 : 0;
    }
    if (msbSet) {
      output[_AESSIV.#BLOCK_SIZE - 1] ^= 135;
    }
    return output;
  }
  static #xorBuffers(left, right) {
    const output = Buffer.alloc(left.length);
    for (const [index, value] of left.entries()) {
      output[index] = value ^ right[index];
    }
    return output;
  }
  static #xorEnd(buffer, block) {
    const output = Buffer.from(buffer);
    const offset = output.length - _AESSIV.#BLOCK_SIZE;
    for (let index = 0; index < _AESSIV.#BLOCK_SIZE; index++) {
      output[offset + index] ^= block[index];
    }
    return output;
  }
  static #pad(buffer) {
    const output = Buffer.alloc(_AESSIV.#BLOCK_SIZE, 0);
    buffer.copy(output);
    output[buffer.length] = 128;
    return output;
  }
  static #getEcbAlgorithm(key) {
    switch (key.length) {
      case 16: {
        return "aes-128-ecb";
      }
      case 24: {
        return "aes-192-ecb";
      }
      case 32: {
        return "aes-256-ecb";
      }
      default: {
        throw new TypeError("Invalid AES key length for SIV");
      }
    }
  }
  static #getCtrAlgorithm(key) {
    switch (key.length) {
      case 16: {
        return "aes-128-ctr";
      }
      case 24: {
        return "aes-192-ctr";
      }
      case 32: {
        return "aes-256-ctr";
      }
      default: {
        throw new TypeError("Invalid AES key length for SIV");
      }
    }
  }
  static #ensureSupportedKeyLength(macKey, encryptionKey) {
    if (macKey.length !== encryptionKey.length) {
      throw new TypeError("SIV subkeys must have the same length");
    }
    _AESSIV.#getEcbAlgorithm(macKey);
    _AESSIV.#getCtrAlgorithm(encryptionKey);
  }
};
export {
  AESSIV,
  aessiv
};
/*
 * @boringnode/encryption
 *
 * @license MIT
 * @copyright Boring Node
 */
//# sourceMappingURL=aes_siv.js.map