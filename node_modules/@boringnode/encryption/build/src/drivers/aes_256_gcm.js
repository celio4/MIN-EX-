import {
  BaseDriver,
  E_MISSING_ENCRYPTER_ID
} from "../../chunk-7R6WELCL.js";
import {
  base64UrlDecode,
  base64UrlEncode
} from "../../chunk-ACZGKXGJ.js";

// src/drivers/aes_256_gcm.ts
import { createCipheriv, createDecipheriv, randomBytes } from "crypto";
import { MessageBuilder } from "@poppinss/utils";
function aes256gcm(config) {
  return {
    driver: (key) => new AES256GCM({ id: config.id, key }),
    keys: config.keys
  };
}
var AES256GCM = class extends BaseDriver {
  #config;
  constructor(config) {
    super(config);
    this.#config = config;
    if (typeof config.id !== "string") {
      throw new E_MISSING_ENCRYPTER_ID();
    }
  }
  encrypt(payload, expiresInOrOptions, purpose) {
    let expiresIn;
    let actualPurpose;
    if (typeof expiresInOrOptions === "object" && expiresInOrOptions !== null) {
      expiresIn = expiresInOrOptions.expiresIn;
      actualPurpose = expiresInOrOptions.purpose;
    } else {
      expiresIn = expiresInOrOptions;
      actualPurpose = purpose;
    }
    const iv = randomBytes(12);
    const cipher = createCipheriv("aes-256-gcm", this.cryptoKey, iv);
    if (actualPurpose) {
      cipher.setAAD(Buffer.from(actualPurpose), {
        plaintextLength: Buffer.byteLength(actualPurpose)
      });
    }
    const plainText = new MessageBuilder().build(payload, expiresIn);
    const cipherText = Buffer.concat([cipher.update(plainText), cipher.final()]);
    const tag = cipher.getAuthTag();
    return this.computeReturns([
      this.#config.id,
      base64UrlEncode(cipherText),
      base64UrlEncode(iv),
      base64UrlEncode(tag)
    ]);
  }
  /**
   * Decrypt value and verify it against a purpose
   */
  decrypt(value, purpose) {
    if (typeof value !== "string") {
      return null;
    }
    const [id, cipherEncoded, ivEncoded, tagEncoded] = value.split(this.separator);
    if (!id || !cipherEncoded || !ivEncoded || !tagEncoded) {
      return null;
    }
    if (id !== this.#config.id) {
      return null;
    }
    const cipherText = base64UrlDecode(cipherEncoded);
    if (!cipherText) {
      return null;
    }
    const iv = base64UrlDecode(ivEncoded);
    if (!iv) {
      return null;
    }
    const tag = base64UrlDecode(tagEncoded);
    if (!tag) {
      return null;
    }
    try {
      const decipher = createDecipheriv("aes-256-gcm", this.cryptoKey, iv);
      if (purpose) {
        decipher.setAAD(Buffer.from(purpose), { plaintextLength: Buffer.byteLength(purpose) });
      }
      decipher.setAuthTag(tag);
      const plain = Buffer.concat([decipher.update(cipherText), decipher.final()]);
      return new MessageBuilder().verify(plain);
    } catch {
      return null;
    }
  }
};
export {
  AES256GCM,
  aes256gcm
};
/*
 * @boringnode/encryption
 *
 * @license MIT
 * @copyright Boring Node
 */
//# sourceMappingURL=aes_256_gcm.js.map